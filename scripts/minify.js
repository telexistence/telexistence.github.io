!function(n,r){"object"==typeof module&&"object"==typeof module.exports?module.exports=n.document?r(n,!0):function(n){if(!n.document)throw new Error("jQuery requires a window with a document");return r(n)}:r(n)}("undefined"!=typeof window?window:this,function(n,r){function e(n){var r="length"in n&&n.length,e=$.type(n);return"function"===e||$.isWindow(n)?!1:1===n.nodeType&&r?!0:"array"===e||0===r||"number"==typeof r&&r>0&&r-1 in n}function t(n,r,e){if($.isFunction(r))return $.grep(n,function(n,t){return!!r.call(n,t,n)!==e});if(r.nodeType)return $.grep(n,function(n){return n===r!==e});if("string"==typeof r){if(ln.test(r))return $.filter(r,n,e);r=$.filter(r,n)}return $.grep(n,function(n){return q.call(r,n)>=0!==e})}function i(n,r){for(;(n=n[r])&&1!==n.nodeType;);return n}function a(n){var r=mn[n]={};return $.each(n.match(fn)||[],function(n,e){r[e]=!0}),r}function o(){Q.removeEventListener("DOMContentLoaded",o,!1),n.removeEventListener("load",o,!1),$.ready()}function s(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=$.expando+s.uid++}function l(n,r,e){var t;if(void 0===e&&1===n.nodeType)if(t="data-"+r.replace(xn,"-$1").toLowerCase(),e=n.getAttribute(t),"string"==typeof e){try{e="true"===e?!0:"false"===e?!1:"null"===e?null:+e+""===e?+e:bn.test(e)?$.parseJSON(e):e}catch(i){}En.set(n,r,e)}else e=void 0;return e}function c(){return!0}function u(){return!1}function h(){try{return Q.activeElement}catch(n){}}function d(n,r){return $.nodeName(n,"table")&&$.nodeName(11!==r.nodeType?r:r.firstChild,"tr")?n.getElementsByTagName("tbody")[0]||n.appendChild(n.ownerDocument.createElement("tbody")):n}function p(n){return n.type=(null!==n.getAttribute("type"))+"/"+n.type,n}function f(n){var r=Dn.exec(n.type);return r?n.type=r[1]:n.removeAttribute("type"),n}function m(n,r){for(var e=0,t=n.length;t>e;e++)yn.set(n[e],"globalEval",!r||yn.get(r[e],"globalEval"))}function g(n,r){var e,t,i,a,o,s,l,c;if(1===r.nodeType){if(yn.hasData(n)&&(a=yn.access(n),o=yn.set(r,a),c=a.events)){delete o.handle,o.events={};for(i in c)for(e=0,t=c[i].length;t>e;e++)$.event.add(r,i,c[i][e])}En.hasData(n)&&(s=En.access(n),l=$.extend({},s),En.set(r,l))}}function v(n,r){var e=n.getElementsByTagName?n.getElementsByTagName(r||"*"):n.querySelectorAll?n.querySelectorAll(r||"*"):[];return void 0===r||r&&$.nodeName(n,r)?$.merge([n],e):e}function y(n,r){var e=r.nodeName.toLowerCase();"input"===e&&Rn.test(n.type)?r.checked=n.checked:("input"===e||"textarea"===e)&&(r.defaultValue=n.defaultValue)}function E(r,e){var t,i=$(e.createElement(r)).appendTo(e.body),a=n.getDefaultComputedStyle&&(t=n.getDefaultComputedStyle(i[0]))?t.display:$.css(i[0],"display");return i.detach(),a}function b(n){var r=Q,e=Nn[n];return e||(e=E(n,r),"none"!==e&&e||(Bn=(Bn||$("<iframe frameborder='0' width='0' height='0'/>")).appendTo(r.documentElement),r=Bn[0].contentDocument,r.write(),r.close(),e=E(n,r),Bn.detach()),Nn[n]=e),e}function x(n,r,e){var t,i,a,o,s=n.style;return e=e||Gn(n),e&&(o=e.getPropertyValue(r)||e[r]),e&&(""!==o||$.contains(n.ownerDocument,n)||(o=$.style(n,r)),Vn.test(o)&&Un.test(r)&&(t=s.width,i=s.minWidth,a=s.maxWidth,s.minWidth=s.maxWidth=s.width=o,o=e.width,s.width=t,s.minWidth=i,s.maxWidth=a)),void 0!==o?o+"":o}function T(n,r){return{get:function(){return n()?void delete this.get:(this.get=r).apply(this,arguments)}}}function _(n,r){if(r in n)return r;for(var e=r[0].toUpperCase()+r.slice(1),t=r,i=Zn.length;i--;)if(r=Zn[i]+e,r in n)return r;return t}function w(n,r,e){var t=qn.exec(r);return t?Math.max(0,t[1]-(e||0))+(t[2]||"px"):r}function R(n,r,e,t,i){for(var a=e===(t?"border":"content")?4:"width"===r?1:0,o=0;4>a;a+=2)"margin"===e&&(o+=$.css(n,e+_n[a],!0,i)),t?("content"===e&&(o-=$.css(n,"padding"+_n[a],!0,i)),"margin"!==e&&(o-=$.css(n,"border"+_n[a]+"Width",!0,i))):(o+=$.css(n,"padding"+_n[a],!0,i),"padding"!==e&&(o+=$.css(n,"border"+_n[a]+"Width",!0,i)));return o}function H(n,r,e){var t=!0,i="width"===r?n.offsetWidth:n.offsetHeight,a=Gn(n),o="border-box"===$.css(n,"boxSizing",!1,a);if(0>=i||null==i){if(i=x(n,r,a),(0>i||null==i)&&(i=n.style[r]),Vn.test(i))return i;t=o&&(Z.boxSizingReliable()||i===n.style[r]),i=parseFloat(i)||0}return i+R(n,r,e||(o?"border":"content"),t,a)+"px"}function S(n,r){for(var e,t,i,a=[],o=0,s=n.length;s>o;o++)t=n[o],t.style&&(a[o]=yn.get(t,"olddisplay"),e=t.style.display,r?(a[o]||"none"!==e||(t.style.display=""),""===t.style.display&&wn(t)&&(a[o]=yn.access(t,"olddisplay",b(t.nodeName)))):(i=wn(t),"none"===e&&i||yn.set(t,"olddisplay",i?e:$.css(t,"display"))));for(o=0;s>o;o++)t=n[o],t.style&&(r&&"none"!==t.style.display&&""!==t.style.display||(t.style.display=r?a[o]||"":"none"));return n}function A(n,r,e,t,i){return new A.prototype.init(n,r,e,t,i)}function M(){return setTimeout(function(){Qn=void 0}),Qn=$.now()}function C(n,r){var e,t=0,i={height:n};for(r=r?1:0;4>t;t+=2-r)e=_n[t],i["margin"+e]=i["padding"+e]=n;return r&&(i.opacity=i.width=n),i}function k(n,r,e){for(var t,i=(tr[r]||[]).concat(tr["*"]),a=0,o=i.length;o>a;a++)if(t=i[a].call(e,r,n))return t}function j(n,r,e){var t,i,a,o,s,l,c,u,h=this,d={},p=n.style,f=n.nodeType&&wn(n),m=yn.get(n,"fxshow");e.queue||(s=$._queueHooks(n,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,h.always(function(){h.always(function(){s.unqueued--,$.queue(n,"fx").length||s.empty.fire()})})),1===n.nodeType&&("height"in r||"width"in r)&&(e.overflow=[p.overflow,p.overflowX,p.overflowY],c=$.css(n,"display"),u="none"===c?yn.get(n,"olddisplay")||b(n.nodeName):c,"inline"===u&&"none"===$.css(n,"float")&&(p.display="inline-block")),e.overflow&&(p.overflow="hidden",h.always(function(){p.overflow=e.overflow[0],p.overflowX=e.overflow[1],p.overflowY=e.overflow[2]}));for(t in r)if(i=r[t],$n.exec(i)){if(delete r[t],a=a||"toggle"===i,i===(f?"hide":"show")){if("show"!==i||!m||void 0===m[t])continue;f=!0}d[t]=m&&m[t]||$.style(n,t)}else c=void 0;if($.isEmptyObject(d))"inline"===("none"===c?b(n.nodeName):c)&&(p.display=c);else{m?"hidden"in m&&(f=m.hidden):m=yn.access(n,"fxshow",{}),a&&(m.hidden=!f),f?$(n).show():h.done(function(){$(n).hide()}),h.done(function(){var r;yn.remove(n,"fxshow");for(r in d)$.style(n,r,d[r])});for(t in d)o=k(f?m[t]:0,t,h),t in m||(m[t]=o.start,f&&(o.end=o.start,o.start="width"===t||"height"===t?1:0))}}function P(n,r){var e,t,i,a,o;for(e in n)if(t=$.camelCase(e),i=r[t],a=n[e],$.isArray(a)&&(i=a[1],a=n[e]=a[0]),e!==t&&(n[t]=a,delete n[e]),o=$.cssHooks[t],o&&"expand"in o){a=o.expand(a),delete n[t];for(e in a)e in n||(n[e]=a[e],r[e]=i)}else r[t]=i}function L(n,r,e){var t,i,a=0,o=er.length,s=$.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;for(var r=Qn||M(),e=Math.max(0,c.startTime+c.duration-r),t=e/c.duration||0,a=1-t,o=0,l=c.tweens.length;l>o;o++)c.tweens[o].run(a);return s.notifyWith(n,[c,a,e]),1>a&&l?e:(s.resolveWith(n,[c]),!1)},c=s.promise({elem:n,props:$.extend({},r),opts:$.extend(!0,{specialEasing:{}},e),originalProperties:r,originalOptions:e,startTime:Qn||M(),duration:e.duration,tweens:[],createTween:function(r,e){var t=$.Tween(n,c.opts,r,e,c.opts.specialEasing[r]||c.opts.easing);return c.tweens.push(t),t},stop:function(r){var e=0,t=r?c.tweens.length:0;if(i)return this;for(i=!0;t>e;e++)c.tweens[e].run(1);return r?s.resolveWith(n,[c,r]):s.rejectWith(n,[c,r]),this}}),u=c.props;for(P(u,c.opts.specialEasing);o>a;a++)if(t=er[a].call(c,n,u,c.opts))return t;return $.map(u,k,c),$.isFunction(c.opts.start)&&c.opts.start.call(n,c),$.fx.timer($.extend(l,{elem:n,anim:c,queue:c.opts.queue})),c.progress(c.opts.progress).done(c.opts.done,c.opts.complete).fail(c.opts.fail).always(c.opts.always)}function F(n){return function(r,e){"string"!=typeof r&&(e=r,r="*");var t,i=0,a=r.toLowerCase().match(fn)||[];if($.isFunction(e))for(;t=a[i++];)"+"===t[0]?(t=t.slice(1)||"*",(n[t]=n[t]||[]).unshift(e)):(n[t]=n[t]||[]).push(e)}}function O(n,r,e,t){function i(s){var l;return a[s]=!0,$.each(n[s]||[],function(n,s){var c=s(r,e,t);return"string"!=typeof c||o||a[c]?o?!(l=c):void 0:(r.dataTypes.unshift(c),i(c),!1)}),l}var a={},o=n===br;return i(r.dataTypes[0])||!a["*"]&&i("*")}function D(n,r){var e,t,i=$.ajaxSettings.flatOptions||{};for(e in r)void 0!==r[e]&&((i[e]?n:t||(t={}))[e]=r[e]);return t&&$.extend(!0,n,t),n}function I(n,r,e){for(var t,i,a,o,s=n.contents,l=n.dataTypes;"*"===l[0];)l.shift(),void 0===t&&(t=n.mimeType||r.getResponseHeader("Content-Type"));if(t)for(i in s)if(s[i]&&s[i].test(t)){l.unshift(i);break}if(l[0]in e)a=l[0];else{for(i in e){if(!l[0]||n.converters[i+" "+l[0]]){a=i;break}o||(o=i)}a=a||o}return a?(a!==l[0]&&l.unshift(a),e[a]):void 0}function z(n,r,e,t){var i,a,o,s,l,c={},u=n.dataTypes.slice();if(u[1])for(o in n.converters)c[o.toLowerCase()]=n.converters[o];for(a=u.shift();a;)if(n.responseFields[a]&&(e[n.responseFields[a]]=r),!l&&t&&n.dataFilter&&(r=n.dataFilter(r,n.dataType)),l=a,a=u.shift())if("*"===a)a=l;else if("*"!==l&&l!==a){if(o=c[l+" "+a]||c["* "+a],!o)for(i in c)if(s=i.split(" "),s[1]===a&&(o=c[l+" "+s[0]]||c["* "+s[0]])){o===!0?o=c[i]:c[i]!==!0&&(a=s[0],u.unshift(s[1]));break}if(o!==!0)if(o&&n["throws"])r=o(r);else try{r=o(r)}catch(h){return{state:"parsererror",error:o?h:"No conversion from "+l+" to "+a}}}return{state:"success",data:r}}function B(n,r,e,t){var i;if($.isArray(r))$.each(r,function(r,i){e||Rr.test(n)?t(n,i):B(n+"["+("object"==typeof i?r:"")+"]",i,e,t)});else if(e||"object"!==$.type(r))t(n,r);else for(i in r)B(n+"["+i+"]",r[i],e,t)}function N(n){return $.isWindow(n)?n:9===n.nodeType&&n.defaultView}var U=[],V=U.slice,G=U.concat,W=U.push,q=U.indexOf,X={},Y=X.toString,K=X.hasOwnProperty,Z={},Q=n.document,J="2.1.4",$=function(n,r){return new $.fn.init(n,r)},nn=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,rn=/^-ms-/,en=/-([\da-z])/gi,tn=function(n,r){return r.toUpperCase()};$.fn=$.prototype={jquery:J,constructor:$,selector:"",length:0,toArray:function(){return V.call(this)},get:function(n){return null!=n?0>n?this[n+this.length]:this[n]:V.call(this)},pushStack:function(n){var r=$.merge(this.constructor(),n);return r.prevObject=this,r.context=this.context,r},each:function(n,r){return $.each(this,n,r)},map:function(n){return this.pushStack($.map(this,function(r,e){return n.call(r,e,r)}))},slice:function(){return this.pushStack(V.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(n){var r=this.length,e=+n+(0>n?r:0);return this.pushStack(e>=0&&r>e?[this[e]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:W,sort:U.sort,splice:U.splice},$.extend=$.fn.extend=function(){var n,r,e,t,i,a,o=arguments[0]||{},s=1,l=arguments.length,c=!1;for("boolean"==typeof o&&(c=o,o=arguments[s]||{},s++),"object"==typeof o||$.isFunction(o)||(o={}),s===l&&(o=this,s--);l>s;s++)if(null!=(n=arguments[s]))for(r in n)e=o[r],t=n[r],o!==t&&(c&&t&&($.isPlainObject(t)||(i=$.isArray(t)))?(i?(i=!1,a=e&&$.isArray(e)?e:[]):a=e&&$.isPlainObject(e)?e:{},o[r]=$.extend(c,a,t)):void 0!==t&&(o[r]=t));return o},$.extend({expando:"jQuery"+(J+Math.random()).replace(/\D/g,""),isReady:!0,error:function(n){throw new Error(n)},noop:function(){},isFunction:function(n){return"function"===$.type(n)},isArray:Array.isArray,isWindow:function(n){return null!=n&&n===n.window},isNumeric:function(n){return!$.isArray(n)&&n-parseFloat(n)+1>=0},isPlainObject:function(n){return"object"!==$.type(n)||n.nodeType||$.isWindow(n)?!1:n.constructor&&!K.call(n.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(n){var r;for(r in n)return!1;return!0},type:function(n){return null==n?n+"":"object"==typeof n||"function"==typeof n?X[Y.call(n)]||"object":typeof n},globalEval:function(n){var r,e=eval;n=$.trim(n),n&&(1===n.indexOf("use strict")?(r=Q.createElement("script"),r.text=n,Q.head.appendChild(r).parentNode.removeChild(r)):e(n))},camelCase:function(n){return n.replace(rn,"ms-").replace(en,tn)},nodeName:function(n,r){return n.nodeName&&n.nodeName.toLowerCase()===r.toLowerCase()},each:function(n,r,t){var i,a=0,o=n.length,s=e(n);if(t){if(s)for(;o>a&&(i=r.apply(n[a],t),i!==!1);a++);else for(a in n)if(i=r.apply(n[a],t),i===!1)break}else if(s)for(;o>a&&(i=r.call(n[a],a,n[a]),i!==!1);a++);else for(a in n)if(i=r.call(n[a],a,n[a]),i===!1)break;return n},trim:function(n){return null==n?"":(n+"").replace(nn,"")},makeArray:function(n,r){var t=r||[];return null!=n&&(e(Object(n))?$.merge(t,"string"==typeof n?[n]:n):W.call(t,n)),t},inArray:function(n,r,e){return null==r?-1:q.call(r,n,e)},merge:function(n,r){for(var e=+r.length,t=0,i=n.length;e>t;t++)n[i++]=r[t];return n.length=i,n},grep:function(n,r,e){for(var t,i=[],a=0,o=n.length,s=!e;o>a;a++)t=!r(n[a],a),t!==s&&i.push(n[a]);return i},map:function(n,r,t){var i,a=0,o=n.length,s=e(n),l=[];if(s)for(;o>a;a++)i=r(n[a],a,t),null!=i&&l.push(i);else for(a in n)i=r(n[a],a,t),null!=i&&l.push(i);return G.apply([],l)},guid:1,proxy:function(n,r){var e,t,i;return"string"==typeof r&&(e=n[r],r=n,n=e),$.isFunction(n)?(t=V.call(arguments,2),i=function(){return n.apply(r||this,t.concat(V.call(arguments)))},i.guid=n.guid=n.guid||$.guid++,i):void 0},now:Date.now,support:Z}),$.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(n,r){X["[object "+r+"]"]=r.toLowerCase()});var an=function(n){function r(n,r,e,t){var i,a,o,s,l,c,h,p,f,m;if((r?r.ownerDocument||r:B)!==j&&k(r),r=r||j,e=e||[],s=r.nodeType,"string"!=typeof n||!n||1!==s&&9!==s&&11!==s)return e;if(!t&&L){if(11!==s&&(i=En.exec(n)))if(o=i[1]){if(9===s){if(a=r.getElementById(o),!a||!a.parentNode)return e;if(a.id===o)return e.push(a),e}else if(r.ownerDocument&&(a=r.ownerDocument.getElementById(o))&&I(r,a)&&a.id===o)return e.push(a),e}else{if(i[2])return J.apply(e,r.getElementsByTagName(n)),e;if((o=i[3])&&x.getElementsByClassName)return J.apply(e,r.getElementsByClassName(o)),e}if(x.qsa&&(!F||!F.test(n))){if(p=h=z,f=r,m=1!==s&&n,1===s&&"object"!==r.nodeName.toLowerCase()){for(c=R(n),(h=r.getAttribute("id"))?p=h.replace(xn,"\\$&"):r.setAttribute("id",p),p="[id='"+p+"'] ",l=c.length;l--;)c[l]=p+d(c[l]);f=bn.test(n)&&u(r.parentNode)||r,m=c.join(",")}if(m)try{return J.apply(e,f.querySelectorAll(m)),e}catch(g){}finally{h||r.removeAttribute("id")}}}return S(n.replace(cn,"$1"),r,e,t)}function e(){function n(e,t){return r.push(e+" ")>T.cacheLength&&delete n[r.shift()],n[e+" "]=t}var r=[];return n}function t(n){return n[z]=!0,n}function i(n){var r=j.createElement("div");try{return!!n(r)}catch(e){return!1}finally{r.parentNode&&r.parentNode.removeChild(r),r=null}}function a(n,r){for(var e=n.split("|"),t=n.length;t--;)T.attrHandle[e[t]]=r}function o(n,r){var e=r&&n,t=e&&1===n.nodeType&&1===r.nodeType&&(~r.sourceIndex||X)-(~n.sourceIndex||X);if(t)return t;if(e)for(;e=e.nextSibling;)if(e===r)return-1;return n?1:-1}function s(n){return function(r){var e=r.nodeName.toLowerCase();return"input"===e&&r.type===n}}function l(n){return function(r){var e=r.nodeName.toLowerCase();return("input"===e||"button"===e)&&r.type===n}}function c(n){return t(function(r){return r=+r,t(function(e,t){for(var i,a=n([],e.length,r),o=a.length;o--;)e[i=a[o]]&&(e[i]=!(t[i]=e[i]))})})}function u(n){return n&&"undefined"!=typeof n.getElementsByTagName&&n}function h(){}function d(n){for(var r=0,e=n.length,t="";e>r;r++)t+=n[r].value;return t}function p(n,r,e){var t=r.dir,i=e&&"parentNode"===t,a=U++;return r.first?function(r,e,a){for(;r=r[t];)if(1===r.nodeType||i)return n(r,e,a)}:function(r,e,o){var s,l,c=[N,a];if(o){for(;r=r[t];)if((1===r.nodeType||i)&&n(r,e,o))return!0}else for(;r=r[t];)if(1===r.nodeType||i){if(l=r[z]||(r[z]={}),(s=l[t])&&s[0]===N&&s[1]===a)return c[2]=s[2];if(l[t]=c,c[2]=n(r,e,o))return!0}}}function f(n){return n.length>1?function(r,e,t){for(var i=n.length;i--;)if(!n[i](r,e,t))return!1;return!0}:n[0]}function m(n,e,t){for(var i=0,a=e.length;a>i;i++)r(n,e[i],t);return t}function g(n,r,e,t,i){for(var a,o=[],s=0,l=n.length,c=null!=r;l>s;s++)(a=n[s])&&(!e||e(a,t,i))&&(o.push(a),c&&r.push(s));return o}function v(n,r,e,i,a,o){return i&&!i[z]&&(i=v(i)),a&&!a[z]&&(a=v(a,o)),t(function(t,o,s,l){var c,u,h,d=[],p=[],f=o.length,v=t||m(r||"*",s.nodeType?[s]:s,[]),y=!n||!t&&r?v:g(v,d,n,s,l),E=e?a||(t?n:f||i)?[]:o:y;if(e&&e(y,E,s,l),i)for(c=g(E,p),i(c,[],s,l),u=c.length;u--;)(h=c[u])&&(E[p[u]]=!(y[p[u]]=h));if(t){if(a||n){if(a){for(c=[],u=E.length;u--;)(h=E[u])&&c.push(y[u]=h);a(null,E=[],c,l)}for(u=E.length;u--;)(h=E[u])&&(c=a?nn(t,h):d[u])>-1&&(t[c]=!(o[c]=h))}}else E=g(E===o?E.splice(f,E.length):E),a?a(null,o,E,l):J.apply(o,E)})}function y(n){for(var r,e,t,i=n.length,a=T.relative[n[0].type],o=a||T.relative[" "],s=a?1:0,l=p(function(n){return n===r},o,!0),c=p(function(n){return nn(r,n)>-1},o,!0),u=[function(n,e,t){var i=!a&&(t||e!==A)||((r=e).nodeType?l(n,e,t):c(n,e,t));return r=null,i}];i>s;s++)if(e=T.relative[n[s].type])u=[p(f(u),e)];else{if(e=T.filter[n[s].type].apply(null,n[s].matches),e[z]){for(t=++s;i>t&&!T.relative[n[t].type];t++);return v(s>1&&f(u),s>1&&d(n.slice(0,s-1).concat({value:" "===n[s-2].type?"*":""})).replace(cn,"$1"),e,t>s&&y(n.slice(s,t)),i>t&&y(n=n.slice(t)),i>t&&d(n))}u.push(e)}return f(u)}function E(n,e){var i=e.length>0,a=n.length>0,o=function(t,o,s,l,c){var u,h,d,p=0,f="0",m=t&&[],v=[],y=A,E=t||a&&T.find.TAG("*",c),b=N+=null==y?1:Math.random()||.1,x=E.length;for(c&&(A=o!==j&&o);f!==x&&null!=(u=E[f]);f++){if(a&&u){for(h=0;d=n[h++];)if(d(u,o,s)){l.push(u);break}c&&(N=b)}i&&((u=!d&&u)&&p--,t&&m.push(u))}if(p+=f,i&&f!==p){for(h=0;d=e[h++];)d(m,v,o,s);if(t){if(p>0)for(;f--;)m[f]||v[f]||(v[f]=Z.call(l));v=g(v)}J.apply(l,v),c&&!t&&v.length>0&&p+e.length>1&&r.uniqueSort(l)}return c&&(N=b,A=y),m};return i?t(o):o}var b,x,T,_,w,R,H,S,A,M,C,k,j,P,L,F,O,D,I,z="sizzle"+1*new Date,B=n.document,N=0,U=0,V=e(),G=e(),W=e(),q=function(n,r){return n===r&&(C=!0),0},X=1<<31,Y={}.hasOwnProperty,K=[],Z=K.pop,Q=K.push,J=K.push,$=K.slice,nn=function(n,r){for(var e=0,t=n.length;t>e;e++)if(n[e]===r)return e;return-1},rn="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",en="[\\x20\\t\\r\\n\\f]",tn="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",an=tn.replace("w","w#"),on="\\["+en+"*("+tn+")(?:"+en+"*([*^$|!~]?=)"+en+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+an+"))|)"+en+"*\\]",sn=":("+tn+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+on+")*)|.*)\\)|)",ln=new RegExp(en+"+","g"),cn=new RegExp("^"+en+"+|((?:^|[^\\\\])(?:\\\\.)*)"+en+"+$","g"),un=new RegExp("^"+en+"*,"+en+"*"),hn=new RegExp("^"+en+"*([>+~]|"+en+")"+en+"*"),dn=new RegExp("="+en+"*([^\\]'\"]*?)"+en+"*\\]","g"),pn=new RegExp(sn),fn=new RegExp("^"+an+"$"),mn={ID:new RegExp("^#("+tn+")"),CLASS:new RegExp("^\\.("+tn+")"),TAG:new RegExp("^("+tn.replace("w","w*")+")"),ATTR:new RegExp("^"+on),PSEUDO:new RegExp("^"+sn),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+en+"*(even|odd|(([+-]|)(\\d*)n|)"+en+"*(?:([+-]|)"+en+"*(\\d+)|))"+en+"*\\)|)","i"),bool:new RegExp("^(?:"+rn+")$","i"),needsContext:new RegExp("^"+en+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+en+"*((?:-\\d)?\\d*)"+en+"*\\)|)(?=[^-]|$)","i")},gn=/^(?:input|select|textarea|button)$/i,vn=/^h\d$/i,yn=/^[^{]+\{\s*\[native \w/,En=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,bn=/[+~]/,xn=/'|\\/g,Tn=new RegExp("\\\\([\\da-f]{1,6}"+en+"?|("+en+")|.)","ig"),_n=function(n,r,e){var t="0x"+r-65536;return t!==t||e?r:0>t?String.fromCharCode(t+65536):String.fromCharCode(t>>10|55296,1023&t|56320)},wn=function(){k()};try{J.apply(K=$.call(B.childNodes),B.childNodes),K[B.childNodes.length].nodeType}catch(Rn){J={apply:K.length?function(n,r){Q.apply(n,$.call(r))}:function(n,r){for(var e=n.length,t=0;n[e++]=r[t++];);n.length=e-1}}}x=r.support={},w=r.isXML=function(n){var r=n&&(n.ownerDocument||n).documentElement;return r?"HTML"!==r.nodeName:!1},k=r.setDocument=function(n){var r,e,t=n?n.ownerDocument||n:B;return t!==j&&9===t.nodeType&&t.documentElement?(j=t,P=t.documentElement,e=t.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",wn,!1):e.attachEvent&&e.attachEvent("onunload",wn)),L=!w(t),x.attributes=i(function(n){return n.className="i",!n.getAttribute("className")}),x.getElementsByTagName=i(function(n){return n.appendChild(t.createComment("")),!n.getElementsByTagName("*").length}),x.getElementsByClassName=yn.test(t.getElementsByClassName),x.getById=i(function(n){return P.appendChild(n).id=z,!t.getElementsByName||!t.getElementsByName(z).length}),x.getById?(T.find.ID=function(n,r){if("undefined"!=typeof r.getElementById&&L){var e=r.getElementById(n);return e&&e.parentNode?[e]:[]}},T.filter.ID=function(n){var r=n.replace(Tn,_n);return function(n){return n.getAttribute("id")===r}}):(delete T.find.ID,T.filter.ID=function(n){var r=n.replace(Tn,_n);return function(n){var e="undefined"!=typeof n.getAttributeNode&&n.getAttributeNode("id");return e&&e.value===r}}),T.find.TAG=x.getElementsByTagName?function(n,r){return"undefined"!=typeof r.getElementsByTagName?r.getElementsByTagName(n):x.qsa?r.querySelectorAll(n):void 0}:function(n,r){var e,t=[],i=0,a=r.getElementsByTagName(n);if("*"===n){for(;e=a[i++];)1===e.nodeType&&t.push(e);return t}return a},T.find.CLASS=x.getElementsByClassName&&function(n,r){return L?r.getElementsByClassName(n):void 0},O=[],F=[],(x.qsa=yn.test(t.querySelectorAll))&&(i(function(n){P.appendChild(n).innerHTML="<a id='"+z+"'></a><select id='"+z+"-\f]' msallowcapture=''><option selected=''></option></select>",n.querySelectorAll("[msallowcapture^='']").length&&F.push("[*^$]="+en+"*(?:''|\"\")"),n.querySelectorAll("[selected]").length||F.push("\\["+en+"*(?:value|"+rn+")"),n.querySelectorAll("[id~="+z+"-]").length||F.push("~="),n.querySelectorAll(":checked").length||F.push(":checked"),n.querySelectorAll("a#"+z+"+*").length||F.push(".#.+[+~]")}),i(function(n){var r=t.createElement("input");r.setAttribute("type","hidden"),n.appendChild(r).setAttribute("name","D"),n.querySelectorAll("[name=d]").length&&F.push("name"+en+"*[*^$|!~]?="),n.querySelectorAll(":enabled").length||F.push(":enabled",":disabled"),n.querySelectorAll("*,:x"),F.push(",.*:")})),(x.matchesSelector=yn.test(D=P.matches||P.webkitMatchesSelector||P.mozMatchesSelector||P.oMatchesSelector||P.msMatchesSelector))&&i(function(n){x.disconnectedMatch=D.call(n,"div"),D.call(n,"[s!='']:x"),O.push("!=",sn)}),F=F.length&&new RegExp(F.join("|")),O=O.length&&new RegExp(O.join("|")),r=yn.test(P.compareDocumentPosition),I=r||yn.test(P.contains)?function(n,r){var e=9===n.nodeType?n.documentElement:n,t=r&&r.parentNode;return n===t||!(!t||1!==t.nodeType||!(e.contains?e.contains(t):n.compareDocumentPosition&&16&n.compareDocumentPosition(t)))}:function(n,r){if(r)for(;r=r.parentNode;)if(r===n)return!0;return!1},q=r?function(n,r){if(n===r)return C=!0,0;var e=!n.compareDocumentPosition-!r.compareDocumentPosition;return e?e:(e=(n.ownerDocument||n)===(r.ownerDocument||r)?n.compareDocumentPosition(r):1,1&e||!x.sortDetached&&r.compareDocumentPosition(n)===e?n===t||n.ownerDocument===B&&I(B,n)?-1:r===t||r.ownerDocument===B&&I(B,r)?1:M?nn(M,n)-nn(M,r):0:4&e?-1:1)}:function(n,r){if(n===r)return C=!0,0;var e,i=0,a=n.parentNode,s=r.parentNode,l=[n],c=[r];if(!a||!s)return n===t?-1:r===t?1:a?-1:s?1:M?nn(M,n)-nn(M,r):0;if(a===s)return o(n,r);for(e=n;e=e.parentNode;)l.unshift(e);for(e=r;e=e.parentNode;)c.unshift(e);for(;l[i]===c[i];)i++;return i?o(l[i],c[i]):l[i]===B?-1:c[i]===B?1:0},t):j},r.matches=function(n,e){return r(n,null,null,e)},r.matchesSelector=function(n,e){if((n.ownerDocument||n)!==j&&k(n),e=e.replace(dn,"='$1']"),x.matchesSelector&&L&&(!O||!O.test(e))&&(!F||!F.test(e)))try{var t=D.call(n,e);if(t||x.disconnectedMatch||n.document&&11!==n.document.nodeType)return t}catch(i){}return r(e,j,null,[n]).length>0},r.contains=function(n,r){return(n.ownerDocument||n)!==j&&k(n),I(n,r)},r.attr=function(n,r){(n.ownerDocument||n)!==j&&k(n);var e=T.attrHandle[r.toLowerCase()],t=e&&Y.call(T.attrHandle,r.toLowerCase())?e(n,r,!L):void 0;return void 0!==t?t:x.attributes||!L?n.getAttribute(r):(t=n.getAttributeNode(r))&&t.specified?t.value:null},r.error=function(n){throw new Error("Syntax error, unrecognized expression: "+n)},r.uniqueSort=function(n){var r,e=[],t=0,i=0;if(C=!x.detectDuplicates,M=!x.sortStable&&n.slice(0),n.sort(q),C){for(;r=n[i++];)r===n[i]&&(t=e.push(i));for(;t--;)n.splice(e[t],1)}return M=null,n},_=r.getText=function(n){var r,e="",t=0,i=n.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof n.textContent)return n.textContent;for(n=n.firstChild;n;n=n.nextSibling)e+=_(n)}else if(3===i||4===i)return n.nodeValue}else for(;r=n[t++];)e+=_(r);return e},T=r.selectors={cacheLength:50,createPseudo:t,match:mn,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(n){return n[1]=n[1].replace(Tn,_n),n[3]=(n[3]||n[4]||n[5]||"").replace(Tn,_n),"~="===n[2]&&(n[3]=" "+n[3]+" "),n.slice(0,4)},CHILD:function(n){return n[1]=n[1].toLowerCase(),"nth"===n[1].slice(0,3)?(n[3]||r.error(n[0]),n[4]=+(n[4]?n[5]+(n[6]||1):2*("even"===n[3]||"odd"===n[3])),n[5]=+(n[7]+n[8]||"odd"===n[3])):n[3]&&r.error(n[0]),n},PSEUDO:function(n){var r,e=!n[6]&&n[2];return mn.CHILD.test(n[0])?null:(n[3]?n[2]=n[4]||n[5]||"":e&&pn.test(e)&&(r=R(e,!0))&&(r=e.indexOf(")",e.length-r)-e.length)&&(n[0]=n[0].slice(0,r),n[2]=e.slice(0,r)),n.slice(0,3))}},filter:{TAG:function(n){var r=n.replace(Tn,_n).toLowerCase();return"*"===n?function(){return!0}:function(n){return n.nodeName&&n.nodeName.toLowerCase()===r}},CLASS:function(n){var r=V[n+" "];return r||(r=new RegExp("(^|"+en+")"+n+"("+en+"|$)"))&&V(n,function(n){return r.test("string"==typeof n.className&&n.className||"undefined"!=typeof n.getAttribute&&n.getAttribute("class")||"")})},ATTR:function(n,e,t){return function(i){var a=r.attr(i,n);return null==a?"!="===e:e?(a+="","="===e?a===t:"!="===e?a!==t:"^="===e?t&&0===a.indexOf(t):"*="===e?t&&a.indexOf(t)>-1:"$="===e?t&&a.slice(-t.length)===t:"~="===e?(" "+a.replace(ln," ")+" ").indexOf(t)>-1:"|="===e?a===t||a.slice(0,t.length+1)===t+"-":!1):!0}},CHILD:function(n,r,e,t,i){var a="nth"!==n.slice(0,3),o="last"!==n.slice(-4),s="of-type"===r;return 1===t&&0===i?function(n){return!!n.parentNode}:function(r,e,l){var c,u,h,d,p,f,m=a!==o?"nextSibling":"previousSibling",g=r.parentNode,v=s&&r.nodeName.toLowerCase(),y=!l&&!s;if(g){if(a){for(;m;){for(h=r;h=h[m];)if(s?h.nodeName.toLowerCase()===v:1===h.nodeType)return!1;f=m="only"===n&&!f&&"nextSibling"}return!0}if(f=[o?g.firstChild:g.lastChild],o&&y){for(u=g[z]||(g[z]={}),c=u[n]||[],p=c[0]===N&&c[1],d=c[0]===N&&c[2],h=p&&g.childNodes[p];h=++p&&h&&h[m]||(d=p=0)||f.pop();)if(1===h.nodeType&&++d&&h===r){u[n]=[N,p,d];break}}else if(y&&(c=(r[z]||(r[z]={}))[n])&&c[0]===N)d=c[1];else for(;(h=++p&&h&&h[m]||(d=p=0)||f.pop())&&((s?h.nodeName.toLowerCase()!==v:1!==h.nodeType)||!++d||(y&&((h[z]||(h[z]={}))[n]=[N,d]),h!==r)););return d-=i,d===t||d%t===0&&d/t>=0}}},PSEUDO:function(n,e){var i,a=T.pseudos[n]||T.setFilters[n.toLowerCase()]||r.error("unsupported pseudo: "+n);return a[z]?a(e):a.length>1?(i=[n,n,"",e],T.setFilters.hasOwnProperty(n.toLowerCase())?t(function(n,r){for(var t,i=a(n,e),o=i.length;o--;)t=nn(n,i[o]),n[t]=!(r[t]=i[o])}):function(n){return a(n,0,i)}):a}},pseudos:{not:t(function(n){var r=[],e=[],i=H(n.replace(cn,"$1"));return i[z]?t(function(n,r,e,t){for(var a,o=i(n,null,t,[]),s=n.length;s--;)(a=o[s])&&(n[s]=!(r[s]=a))}):function(n,t,a){return r[0]=n,i(r,null,a,e),r[0]=null,!e.pop()}}),has:t(function(n){return function(e){return r(n,e).length>0}}),contains:t(function(n){return n=n.replace(Tn,_n),function(r){return(r.textContent||r.innerText||_(r)).indexOf(n)>-1}}),lang:t(function(n){return fn.test(n||"")||r.error("unsupported lang: "+n),n=n.replace(Tn,_n).toLowerCase(),function(r){var e;do if(e=L?r.lang:r.getAttribute("xml:lang")||r.getAttribute("lang"))return e=e.toLowerCase(),e===n||0===e.indexOf(n+"-");while((r=r.parentNode)&&1===r.nodeType);return!1}}),target:function(r){var e=n.location&&n.location.hash;return e&&e.slice(1)===r.id},root:function(n){return n===P},focus:function(n){return n===j.activeElement&&(!j.hasFocus||j.hasFocus())&&!!(n.type||n.href||~n.tabIndex)},enabled:function(n){return n.disabled===!1},disabled:function(n){return n.disabled===!0},checked:function(n){var r=n.nodeName.toLowerCase();return"input"===r&&!!n.checked||"option"===r&&!!n.selected},selected:function(n){return n.parentNode&&n.parentNode.selectedIndex,n.selected===!0},empty:function(n){for(n=n.firstChild;n;n=n.nextSibling)if(n.nodeType<6)return!1;return!0},parent:function(n){return!T.pseudos.empty(n)},header:function(n){return vn.test(n.nodeName)},input:function(n){return gn.test(n.nodeName)},button:function(n){var r=n.nodeName.toLowerCase();return"input"===r&&"button"===n.type||"button"===r},text:function(n){var r;return"input"===n.nodeName.toLowerCase()&&"text"===n.type&&(null==(r=n.getAttribute("type"))||"text"===r.toLowerCase())},first:c(function(){return[0]}),last:c(function(n,r){return[r-1]}),eq:c(function(n,r,e){return[0>e?e+r:e]}),even:c(function(n,r){for(var e=0;r>e;e+=2)n.push(e);return n}),odd:c(function(n,r){for(var e=1;r>e;e+=2)n.push(e);return n}),lt:c(function(n,r,e){for(var t=0>e?e+r:e;--t>=0;)n.push(t);return n}),gt:c(function(n,r,e){for(var t=0>e?e+r:e;++t<r;)n.push(t);return n})}},T.pseudos.nth=T.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})T.pseudos[b]=s(b);for(b in{submit:!0,reset:!0})T.pseudos[b]=l(b);return h.prototype=T.filters=T.pseudos,T.setFilters=new h,R=r.tokenize=function(n,e){var t,i,a,o,s,l,c,u=G[n+" "];if(u)return e?0:u.slice(0);for(s=n,l=[],c=T.preFilter;s;){(!t||(i=un.exec(s)))&&(i&&(s=s.slice(i[0].length)||s),l.push(a=[])),t=!1,(i=hn.exec(s))&&(t=i.shift(),a.push({value:t,type:i[0].replace(cn," ")}),s=s.slice(t.length));for(o in T.filter)!(i=mn[o].exec(s))||c[o]&&!(i=c[o](i))||(t=i.shift(),a.push({value:t,type:o,matches:i}),s=s.slice(t.length));if(!t)break}return e?s.length:s?r.error(n):G(n,l).slice(0)},H=r.compile=function(n,r){var e,t=[],i=[],a=W[n+" "];if(!a){for(r||(r=R(n)),e=r.length;e--;)a=y(r[e]),a[z]?t.push(a):i.push(a);a=W(n,E(i,t)),a.selector=n}return a},S=r.select=function(n,r,e,t){var i,a,o,s,l,c="function"==typeof n&&n,h=!t&&R(n=c.selector||n);if(e=e||[],1===h.length){if(a=h[0]=h[0].slice(0),a.length>2&&"ID"===(o=a[0]).type&&x.getById&&9===r.nodeType&&L&&T.relative[a[1].type]){if(r=(T.find.ID(o.matches[0].replace(Tn,_n),r)||[])[0],!r)return e;c&&(r=r.parentNode),n=n.slice(a.shift().value.length)}for(i=mn.needsContext.test(n)?0:a.length;i--&&(o=a[i],!T.relative[s=o.type]);)if((l=T.find[s])&&(t=l(o.matches[0].replace(Tn,_n),bn.test(a[0].type)&&u(r.parentNode)||r))){if(a.splice(i,1),n=t.length&&d(a),!n)return J.apply(e,t),e;break}}return(c||H(n,h))(t,r,!L,e,bn.test(n)&&u(r.parentNode)||r),e},x.sortStable=z.split("").sort(q).join("")===z,x.detectDuplicates=!!C,k(),x.sortDetached=i(function(n){return 1&n.compareDocumentPosition(j.createElement("div"))}),i(function(n){return n.innerHTML="<a href='#'></a>","#"===n.firstChild.getAttribute("href")})||a("type|href|height|width",function(n,r,e){return e?void 0:n.getAttribute(r,"type"===r.toLowerCase()?1:2)}),x.attributes&&i(function(n){return n.innerHTML="<input/>",n.firstChild.setAttribute("value",""),""===n.firstChild.getAttribute("value")})||a("value",function(n,r,e){return e||"input"!==n.nodeName.toLowerCase()?void 0:n.defaultValue}),i(function(n){return null==n.getAttribute("disabled")})||a(rn,function(n,r,e){var t;return e?void 0:n[r]===!0?r.toLowerCase():(t=n.getAttributeNode(r))&&t.specified?t.value:null}),r}(n);$.find=an,$.expr=an.selectors,$.expr[":"]=$.expr.pseudos,$.unique=an.uniqueSort,$.text=an.getText,$.isXMLDoc=an.isXML,$.contains=an.contains;var on=$.expr.match.needsContext,sn=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,ln=/^.[^:#\[\.,]*$/;$.filter=function(n,r,e){var t=r[0];return e&&(n=":not("+n+")"),1===r.length&&1===t.nodeType?$.find.matchesSelector(t,n)?[t]:[]:$.find.matches(n,$.grep(r,function(n){return 1===n.nodeType}))},$.fn.extend({find:function(n){var r,e=this.length,t=[],i=this;
if("string"!=typeof n)return this.pushStack($(n).filter(function(){for(r=0;e>r;r++)if($.contains(i[r],this))return!0}));for(r=0;e>r;r++)$.find(n,i[r],t);return t=this.pushStack(e>1?$.unique(t):t),t.selector=this.selector?this.selector+" "+n:n,t},filter:function(n){return this.pushStack(t(this,n||[],!1))},not:function(n){return this.pushStack(t(this,n||[],!0))},is:function(n){return!!t(this,"string"==typeof n&&on.test(n)?$(n):n||[],!1).length}});var cn,un=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,hn=$.fn.init=function(n,r){var e,t;if(!n)return this;if("string"==typeof n){if(e="<"===n[0]&&">"===n[n.length-1]&&n.length>=3?[null,n,null]:un.exec(n),!e||!e[1]&&r)return!r||r.jquery?(r||cn).find(n):this.constructor(r).find(n);if(e[1]){if(r=r instanceof $?r[0]:r,$.merge(this,$.parseHTML(e[1],r&&r.nodeType?r.ownerDocument||r:Q,!0)),sn.test(e[1])&&$.isPlainObject(r))for(e in r)$.isFunction(this[e])?this[e](r[e]):this.attr(e,r[e]);return this}return t=Q.getElementById(e[2]),t&&t.parentNode&&(this.length=1,this[0]=t),this.context=Q,this.selector=n,this}return n.nodeType?(this.context=this[0]=n,this.length=1,this):$.isFunction(n)?"undefined"!=typeof cn.ready?cn.ready(n):n($):(void 0!==n.selector&&(this.selector=n.selector,this.context=n.context),$.makeArray(n,this))};hn.prototype=$.fn,cn=$(Q);var dn=/^(?:parents|prev(?:Until|All))/,pn={children:!0,contents:!0,next:!0,prev:!0};$.extend({dir:function(n,r,e){for(var t=[],i=void 0!==e;(n=n[r])&&9!==n.nodeType;)if(1===n.nodeType){if(i&&$(n).is(e))break;t.push(n)}return t},sibling:function(n,r){for(var e=[];n;n=n.nextSibling)1===n.nodeType&&n!==r&&e.push(n);return e}}),$.fn.extend({has:function(n){var r=$(n,this),e=r.length;return this.filter(function(){for(var n=0;e>n;n++)if($.contains(this,r[n]))return!0})},closest:function(n,r){for(var e,t=0,i=this.length,a=[],o=on.test(n)||"string"!=typeof n?$(n,r||this.context):0;i>t;t++)for(e=this[t];e&&e!==r;e=e.parentNode)if(e.nodeType<11&&(o?o.index(e)>-1:1===e.nodeType&&$.find.matchesSelector(e,n))){a.push(e);break}return this.pushStack(a.length>1?$.unique(a):a)},index:function(n){return n?"string"==typeof n?q.call($(n),this[0]):q.call(this,n.jquery?n[0]:n):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(n,r){return this.pushStack($.unique($.merge(this.get(),$(n,r))))},addBack:function(n){return this.add(null==n?this.prevObject:this.prevObject.filter(n))}}),$.each({parent:function(n){var r=n.parentNode;return r&&11!==r.nodeType?r:null},parents:function(n){return $.dir(n,"parentNode")},parentsUntil:function(n,r,e){return $.dir(n,"parentNode",e)},next:function(n){return i(n,"nextSibling")},prev:function(n){return i(n,"previousSibling")},nextAll:function(n){return $.dir(n,"nextSibling")},prevAll:function(n){return $.dir(n,"previousSibling")},nextUntil:function(n,r,e){return $.dir(n,"nextSibling",e)},prevUntil:function(n,r,e){return $.dir(n,"previousSibling",e)},siblings:function(n){return $.sibling((n.parentNode||{}).firstChild,n)},children:function(n){return $.sibling(n.firstChild)},contents:function(n){return n.contentDocument||$.merge([],n.childNodes)}},function(n,r){$.fn[n]=function(e,t){var i=$.map(this,r,e);return"Until"!==n.slice(-5)&&(t=e),t&&"string"==typeof t&&(i=$.filter(t,i)),this.length>1&&(pn[n]||$.unique(i),dn.test(n)&&i.reverse()),this.pushStack(i)}});var fn=/\S+/g,mn={};$.Callbacks=function(n){n="string"==typeof n?mn[n]||a(n):$.extend({},n);var r,e,t,i,o,s,l=[],c=!n.once&&[],u=function(a){for(r=n.memory&&a,e=!0,s=i||0,i=0,o=l.length,t=!0;l&&o>s;s++)if(l[s].apply(a[0],a[1])===!1&&n.stopOnFalse){r=!1;break}t=!1,l&&(c?c.length&&u(c.shift()):r?l=[]:h.disable())},h={add:function(){if(l){var e=l.length;!function a(r){$.each(r,function(r,e){var t=$.type(e);"function"===t?n.unique&&h.has(e)||l.push(e):e&&e.length&&"string"!==t&&a(e)})}(arguments),t?o=l.length:r&&(i=e,u(r))}return this},remove:function(){return l&&$.each(arguments,function(n,r){for(var e;(e=$.inArray(r,l,e))>-1;)l.splice(e,1),t&&(o>=e&&o--,s>=e&&s--)}),this},has:function(n){return n?$.inArray(n,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=c=r=void 0,this},disabled:function(){return!l},lock:function(){return c=void 0,r||h.disable(),this},locked:function(){return!c},fireWith:function(n,r){return!l||e&&!c||(r=r||[],r=[n,r.slice?r.slice():r],t?c.push(r):u(r)),this},fire:function(){return h.fireWith(this,arguments),this},fired:function(){return!!e}};return h},$.extend({Deferred:function(n){var r=[["resolve","done",$.Callbacks("once memory"),"resolved"],["reject","fail",$.Callbacks("once memory"),"rejected"],["notify","progress",$.Callbacks("memory")]],e="pending",t={state:function(){return e},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var n=arguments;return $.Deferred(function(e){$.each(r,function(r,a){var o=$.isFunction(n[r])&&n[r];i[a[1]](function(){var n=o&&o.apply(this,arguments);n&&$.isFunction(n.promise)?n.promise().done(e.resolve).fail(e.reject).progress(e.notify):e[a[0]+"With"](this===t?e.promise():this,o?[n]:arguments)})}),n=null}).promise()},promise:function(n){return null!=n?$.extend(n,t):t}},i={};return t.pipe=t.then,$.each(r,function(n,a){var o=a[2],s=a[3];t[a[1]]=o.add,s&&o.add(function(){e=s},r[1^n][2].disable,r[2][2].lock),i[a[0]]=function(){return i[a[0]+"With"](this===i?t:this,arguments),this},i[a[0]+"With"]=o.fireWith}),t.promise(i),n&&n.call(i,i),i},when:function(n){var r,e,t,i=0,a=V.call(arguments),o=a.length,s=1!==o||n&&$.isFunction(n.promise)?o:0,l=1===s?n:$.Deferred(),c=function(n,e,t){return function(i){e[n]=this,t[n]=arguments.length>1?V.call(arguments):i,t===r?l.notifyWith(e,t):--s||l.resolveWith(e,t)}};if(o>1)for(r=new Array(o),e=new Array(o),t=new Array(o);o>i;i++)a[i]&&$.isFunction(a[i].promise)?a[i].promise().done(c(i,t,a)).fail(l.reject).progress(c(i,e,r)):--s;return s||l.resolveWith(t,a),l.promise()}});var gn;$.fn.ready=function(n){return $.ready.promise().done(n),this},$.extend({isReady:!1,readyWait:1,holdReady:function(n){n?$.readyWait++:$.ready(!0)},ready:function(n){(n===!0?--$.readyWait:$.isReady)||($.isReady=!0,n!==!0&&--$.readyWait>0||(gn.resolveWith(Q,[$]),$.fn.triggerHandler&&($(Q).triggerHandler("ready"),$(Q).off("ready"))))}}),$.ready.promise=function(r){return gn||(gn=$.Deferred(),"complete"===Q.readyState?setTimeout($.ready):(Q.addEventListener("DOMContentLoaded",o,!1),n.addEventListener("load",o,!1))),gn.promise(r)},$.ready.promise();var vn=$.access=function(n,r,e,t,i,a,o){var s=0,l=n.length,c=null==e;if("object"===$.type(e)){i=!0;for(s in e)$.access(n,r,s,e[s],!0,a,o)}else if(void 0!==t&&(i=!0,$.isFunction(t)||(o=!0),c&&(o?(r.call(n,t),r=null):(c=r,r=function(n,r,e){return c.call($(n),e)})),r))for(;l>s;s++)r(n[s],e,o?t:t.call(n[s],s,r(n[s],e)));return i?n:c?r.call(n):l?r(n[0],e):a};$.acceptData=function(n){return 1===n.nodeType||9===n.nodeType||!+n.nodeType},s.uid=1,s.accepts=$.acceptData,s.prototype={key:function(n){if(!s.accepts(n))return 0;var r={},e=n[this.expando];if(!e){e=s.uid++;try{r[this.expando]={value:e},Object.defineProperties(n,r)}catch(t){r[this.expando]=e,$.extend(n,r)}}return this.cache[e]||(this.cache[e]={}),e},set:function(n,r,e){var t,i=this.key(n),a=this.cache[i];if("string"==typeof r)a[r]=e;else if($.isEmptyObject(a))$.extend(this.cache[i],r);else for(t in r)a[t]=r[t];return a},get:function(n,r){var e=this.cache[this.key(n)];return void 0===r?e:e[r]},access:function(n,r,e){var t;return void 0===r||r&&"string"==typeof r&&void 0===e?(t=this.get(n,r),void 0!==t?t:this.get(n,$.camelCase(r))):(this.set(n,r,e),void 0!==e?e:r)},remove:function(n,r){var e,t,i,a=this.key(n),o=this.cache[a];if(void 0===r)this.cache[a]={};else{$.isArray(r)?t=r.concat(r.map($.camelCase)):(i=$.camelCase(r),r in o?t=[r,i]:(t=i,t=t in o?[t]:t.match(fn)||[])),e=t.length;for(;e--;)delete o[t[e]]}},hasData:function(n){return!$.isEmptyObject(this.cache[n[this.expando]]||{})},discard:function(n){n[this.expando]&&delete this.cache[n[this.expando]]}};var yn=new s,En=new s,bn=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,xn=/([A-Z])/g;$.extend({hasData:function(n){return En.hasData(n)||yn.hasData(n)},data:function(n,r,e){return En.access(n,r,e)},removeData:function(n,r){En.remove(n,r)},_data:function(n,r,e){return yn.access(n,r,e)},_removeData:function(n,r){yn.remove(n,r)}}),$.fn.extend({data:function(n,r){var e,t,i,a=this[0],o=a&&a.attributes;if(void 0===n){if(this.length&&(i=En.get(a),1===a.nodeType&&!yn.get(a,"hasDataAttrs"))){for(e=o.length;e--;)o[e]&&(t=o[e].name,0===t.indexOf("data-")&&(t=$.camelCase(t.slice(5)),l(a,t,i[t])));yn.set(a,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){En.set(this,n)}):vn(this,function(r){var e,t=$.camelCase(n);if(a&&void 0===r){if(e=En.get(a,n),void 0!==e)return e;if(e=En.get(a,t),void 0!==e)return e;if(e=l(a,t,void 0),void 0!==e)return e}else this.each(function(){var e=En.get(this,t);En.set(this,t,r),-1!==n.indexOf("-")&&void 0!==e&&En.set(this,n,r)})},null,r,arguments.length>1,null,!0)},removeData:function(n){return this.each(function(){En.remove(this,n)})}}),$.extend({queue:function(n,r,e){var t;return n?(r=(r||"fx")+"queue",t=yn.get(n,r),e&&(!t||$.isArray(e)?t=yn.access(n,r,$.makeArray(e)):t.push(e)),t||[]):void 0},dequeue:function(n,r){r=r||"fx";var e=$.queue(n,r),t=e.length,i=e.shift(),a=$._queueHooks(n,r),o=function(){$.dequeue(n,r)};"inprogress"===i&&(i=e.shift(),t--),i&&("fx"===r&&e.unshift("inprogress"),delete a.stop,i.call(n,o,a)),!t&&a&&a.empty.fire()},_queueHooks:function(n,r){var e=r+"queueHooks";return yn.get(n,e)||yn.access(n,e,{empty:$.Callbacks("once memory").add(function(){yn.remove(n,[r+"queue",e])})})}}),$.fn.extend({queue:function(n,r){var e=2;return"string"!=typeof n&&(r=n,n="fx",e--),arguments.length<e?$.queue(this[0],n):void 0===r?this:this.each(function(){var e=$.queue(this,n,r);$._queueHooks(this,n),"fx"===n&&"inprogress"!==e[0]&&$.dequeue(this,n)})},dequeue:function(n){return this.each(function(){$.dequeue(this,n)})},clearQueue:function(n){return this.queue(n||"fx",[])},promise:function(n,r){var e,t=1,i=$.Deferred(),a=this,o=this.length,s=function(){--t||i.resolveWith(a,[a])};for("string"!=typeof n&&(r=n,n=void 0),n=n||"fx";o--;)e=yn.get(a[o],n+"queueHooks"),e&&e.empty&&(t++,e.empty.add(s));return s(),i.promise(r)}});var Tn=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,_n=["Top","Right","Bottom","Left"],wn=function(n,r){return n=r||n,"none"===$.css(n,"display")||!$.contains(n.ownerDocument,n)},Rn=/^(?:checkbox|radio)$/i;!function(){var n=Q.createDocumentFragment(),r=n.appendChild(Q.createElement("div")),e=Q.createElement("input");e.setAttribute("type","radio"),e.setAttribute("checked","checked"),e.setAttribute("name","t"),r.appendChild(e),Z.checkClone=r.cloneNode(!0).cloneNode(!0).lastChild.checked,r.innerHTML="<textarea>x</textarea>",Z.noCloneChecked=!!r.cloneNode(!0).lastChild.defaultValue}();var Hn="undefined";Z.focusinBubbles="onfocusin"in n;var Sn=/^key/,An=/^(?:mouse|pointer|contextmenu)|click/,Mn=/^(?:focusinfocus|focusoutblur)$/,Cn=/^([^.]*)(?:\.(.+)|)$/;$.event={global:{},add:function(n,r,e,t,i){var a,o,s,l,c,u,h,d,p,f,m,g=yn.get(n);if(g)for(e.handler&&(a=e,e=a.handler,i=a.selector),e.guid||(e.guid=$.guid++),(l=g.events)||(l=g.events={}),(o=g.handle)||(o=g.handle=function(r){return typeof $!==Hn&&$.event.triggered!==r.type?$.event.dispatch.apply(n,arguments):void 0}),r=(r||"").match(fn)||[""],c=r.length;c--;)s=Cn.exec(r[c])||[],p=m=s[1],f=(s[2]||"").split(".").sort(),p&&(h=$.event.special[p]||{},p=(i?h.delegateType:h.bindType)||p,h=$.event.special[p]||{},u=$.extend({type:p,origType:m,data:t,handler:e,guid:e.guid,selector:i,needsContext:i&&$.expr.match.needsContext.test(i),namespace:f.join(".")},a),(d=l[p])||(d=l[p]=[],d.delegateCount=0,h.setup&&h.setup.call(n,t,f,o)!==!1||n.addEventListener&&n.addEventListener(p,o,!1)),h.add&&(h.add.call(n,u),u.handler.guid||(u.handler.guid=e.guid)),i?d.splice(d.delegateCount++,0,u):d.push(u),$.event.global[p]=!0)},remove:function(n,r,e,t,i){var a,o,s,l,c,u,h,d,p,f,m,g=yn.hasData(n)&&yn.get(n);if(g&&(l=g.events)){for(r=(r||"").match(fn)||[""],c=r.length;c--;)if(s=Cn.exec(r[c])||[],p=m=s[1],f=(s[2]||"").split(".").sort(),p){for(h=$.event.special[p]||{},p=(t?h.delegateType:h.bindType)||p,d=l[p]||[],s=s[2]&&new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"),o=a=d.length;a--;)u=d[a],!i&&m!==u.origType||e&&e.guid!==u.guid||s&&!s.test(u.namespace)||t&&t!==u.selector&&("**"!==t||!u.selector)||(d.splice(a,1),u.selector&&d.delegateCount--,h.remove&&h.remove.call(n,u));o&&!d.length&&(h.teardown&&h.teardown.call(n,f,g.handle)!==!1||$.removeEvent(n,p,g.handle),delete l[p])}else for(p in l)$.event.remove(n,p+r[c],e,t,!0);$.isEmptyObject(l)&&(delete g.handle,yn.remove(n,"events"))}},trigger:function(r,e,t,i){var a,o,s,l,c,u,h,d=[t||Q],p=K.call(r,"type")?r.type:r,f=K.call(r,"namespace")?r.namespace.split("."):[];if(o=s=t=t||Q,3!==t.nodeType&&8!==t.nodeType&&!Mn.test(p+$.event.triggered)&&(p.indexOf(".")>=0&&(f=p.split("."),p=f.shift(),f.sort()),c=p.indexOf(":")<0&&"on"+p,r=r[$.expando]?r:new $.Event(p,"object"==typeof r&&r),r.isTrigger=i?2:3,r.namespace=f.join("."),r.namespace_re=r.namespace?new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,r.result=void 0,r.target||(r.target=t),e=null==e?[r]:$.makeArray(e,[r]),h=$.event.special[p]||{},i||!h.trigger||h.trigger.apply(t,e)!==!1)){if(!i&&!h.noBubble&&!$.isWindow(t)){for(l=h.delegateType||p,Mn.test(l+p)||(o=o.parentNode);o;o=o.parentNode)d.push(o),s=o;s===(t.ownerDocument||Q)&&d.push(s.defaultView||s.parentWindow||n)}for(a=0;(o=d[a++])&&!r.isPropagationStopped();)r.type=a>1?l:h.bindType||p,u=(yn.get(o,"events")||{})[r.type]&&yn.get(o,"handle"),u&&u.apply(o,e),u=c&&o[c],u&&u.apply&&$.acceptData(o)&&(r.result=u.apply(o,e),r.result===!1&&r.preventDefault());return r.type=p,i||r.isDefaultPrevented()||h._default&&h._default.apply(d.pop(),e)!==!1||!$.acceptData(t)||c&&$.isFunction(t[p])&&!$.isWindow(t)&&(s=t[c],s&&(t[c]=null),$.event.triggered=p,t[p](),$.event.triggered=void 0,s&&(t[c]=s)),r.result}},dispatch:function(n){n=$.event.fix(n);var r,e,t,i,a,o=[],s=V.call(arguments),l=(yn.get(this,"events")||{})[n.type]||[],c=$.event.special[n.type]||{};if(s[0]=n,n.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,n)!==!1){for(o=$.event.handlers.call(this,n,l),r=0;(i=o[r++])&&!n.isPropagationStopped();)for(n.currentTarget=i.elem,e=0;(a=i.handlers[e++])&&!n.isImmediatePropagationStopped();)(!n.namespace_re||n.namespace_re.test(a.namespace))&&(n.handleObj=a,n.data=a.data,t=(($.event.special[a.origType]||{}).handle||a.handler).apply(i.elem,s),void 0!==t&&(n.result=t)===!1&&(n.preventDefault(),n.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,n),n.result}},handlers:function(n,r){var e,t,i,a,o=[],s=r.delegateCount,l=n.target;if(s&&l.nodeType&&(!n.button||"click"!==n.type))for(;l!==this;l=l.parentNode||this)if(l.disabled!==!0||"click"!==n.type){for(t=[],e=0;s>e;e++)a=r[e],i=a.selector+" ",void 0===t[i]&&(t[i]=a.needsContext?$(i,this).index(l)>=0:$.find(i,this,null,[l]).length),t[i]&&t.push(a);t.length&&o.push({elem:l,handlers:t})}return s<r.length&&o.push({elem:this,handlers:r.slice(s)}),o},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(n,r){return null==n.which&&(n.which=null!=r.charCode?r.charCode:r.keyCode),n}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(n,r){var e,t,i,a=r.button;return null==n.pageX&&null!=r.clientX&&(e=n.target.ownerDocument||Q,t=e.documentElement,i=e.body,n.pageX=r.clientX+(t&&t.scrollLeft||i&&i.scrollLeft||0)-(t&&t.clientLeft||i&&i.clientLeft||0),n.pageY=r.clientY+(t&&t.scrollTop||i&&i.scrollTop||0)-(t&&t.clientTop||i&&i.clientTop||0)),n.which||void 0===a||(n.which=1&a?1:2&a?3:4&a?2:0),n}},fix:function(n){if(n[$.expando])return n;var r,e,t,i=n.type,a=n,o=this.fixHooks[i];for(o||(this.fixHooks[i]=o=An.test(i)?this.mouseHooks:Sn.test(i)?this.keyHooks:{}),t=o.props?this.props.concat(o.props):this.props,n=new $.Event(a),r=t.length;r--;)e=t[r],n[e]=a[e];return n.target||(n.target=Q),3===n.target.nodeType&&(n.target=n.target.parentNode),o.filter?o.filter(n,a):n},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==h()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===h()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&$.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(n){return $.nodeName(n.target,"a")}},beforeunload:{postDispatch:function(n){void 0!==n.result&&n.originalEvent&&(n.originalEvent.returnValue=n.result)}}},simulate:function(n,r,e,t){var i=$.extend(new $.Event,e,{type:n,isSimulated:!0,originalEvent:{}});t?$.event.trigger(i,null,r):$.event.dispatch.call(r,i),i.isDefaultPrevented()&&e.preventDefault()}},$.removeEvent=function(n,r,e){n.removeEventListener&&n.removeEventListener(r,e,!1)},$.Event=function(n,r){return this instanceof $.Event?(n&&n.type?(this.originalEvent=n,this.type=n.type,this.isDefaultPrevented=n.defaultPrevented||void 0===n.defaultPrevented&&n.returnValue===!1?c:u):this.type=n,r&&$.extend(this,r),this.timeStamp=n&&n.timeStamp||$.now(),void(this[$.expando]=!0)):new $.Event(n,r)},$.Event.prototype={isDefaultPrevented:u,isPropagationStopped:u,isImmediatePropagationStopped:u,preventDefault:function(){var n=this.originalEvent;this.isDefaultPrevented=c,n&&n.preventDefault&&n.preventDefault()},stopPropagation:function(){var n=this.originalEvent;this.isPropagationStopped=c,n&&n.stopPropagation&&n.stopPropagation()},stopImmediatePropagation:function(){var n=this.originalEvent;this.isImmediatePropagationStopped=c,n&&n.stopImmediatePropagation&&n.stopImmediatePropagation(),this.stopPropagation()}},$.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(n,r){$.event.special[n]={delegateType:r,bindType:r,handle:function(n){var e,t=this,i=n.relatedTarget,a=n.handleObj;return(!i||i!==t&&!$.contains(t,i))&&(n.type=a.origType,e=a.handler.apply(this,arguments),n.type=r),e}}}),Z.focusinBubbles||$.each({focus:"focusin",blur:"focusout"},function(n,r){var e=function(n){$.event.simulate(r,n.target,$.event.fix(n),!0)};$.event.special[r]={setup:function(){var t=this.ownerDocument||this,i=yn.access(t,r);i||t.addEventListener(n,e,!0),yn.access(t,r,(i||0)+1)},teardown:function(){var t=this.ownerDocument||this,i=yn.access(t,r)-1;i?yn.access(t,r,i):(t.removeEventListener(n,e,!0),yn.remove(t,r))}}}),$.fn.extend({on:function(n,r,e,t,i){var a,o;if("object"==typeof n){"string"!=typeof r&&(e=e||r,r=void 0);for(o in n)this.on(o,r,e,n[o],i);return this}if(null==e&&null==t?(t=r,e=r=void 0):null==t&&("string"==typeof r?(t=e,e=void 0):(t=e,e=r,r=void 0)),t===!1)t=u;else if(!t)return this;return 1===i&&(a=t,t=function(n){return $().off(n),a.apply(this,arguments)},t.guid=a.guid||(a.guid=$.guid++)),this.each(function(){$.event.add(this,n,t,e,r)})},one:function(n,r,e,t){return this.on(n,r,e,t,1)},off:function(n,r,e){var t,i;if(n&&n.preventDefault&&n.handleObj)return t=n.handleObj,$(n.delegateTarget).off(t.namespace?t.origType+"."+t.namespace:t.origType,t.selector,t.handler),this;if("object"==typeof n){for(i in n)this.off(i,r,n[i]);return this}return(r===!1||"function"==typeof r)&&(e=r,r=void 0),e===!1&&(e=u),this.each(function(){$.event.remove(this,n,e,r)})},trigger:function(n,r){return this.each(function(){$.event.trigger(n,r,this)})},triggerHandler:function(n,r){var e=this[0];return e?$.event.trigger(n,r,e,!0):void 0}});var kn=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,jn=/<([\w:]+)/,Pn=/<|&#?\w+;/,Ln=/<(?:script|style|link)/i,Fn=/checked\s*(?:[^=]|=\s*.checked.)/i,On=/^$|\/(?:java|ecma)script/i,Dn=/^true\/(.*)/,In=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,zn={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};zn.optgroup=zn.option,zn.tbody=zn.tfoot=zn.colgroup=zn.caption=zn.thead,zn.th=zn.td,$.extend({clone:function(n,r,e){var t,i,a,o,s=n.cloneNode(!0),l=$.contains(n.ownerDocument,n);if(!(Z.noCloneChecked||1!==n.nodeType&&11!==n.nodeType||$.isXMLDoc(n)))for(o=v(s),a=v(n),t=0,i=a.length;i>t;t++)y(a[t],o[t]);if(r)if(e)for(a=a||v(n),o=o||v(s),t=0,i=a.length;i>t;t++)g(a[t],o[t]);else g(n,s);return o=v(s,"script"),o.length>0&&m(o,!l&&v(n,"script")),s},buildFragment:function(n,r,e,t){for(var i,a,o,s,l,c,u=r.createDocumentFragment(),h=[],d=0,p=n.length;p>d;d++)if(i=n[d],i||0===i)if("object"===$.type(i))$.merge(h,i.nodeType?[i]:i);else if(Pn.test(i)){for(a=a||u.appendChild(r.createElement("div")),o=(jn.exec(i)||["",""])[1].toLowerCase(),s=zn[o]||zn._default,a.innerHTML=s[1]+i.replace(kn,"<$1></$2>")+s[2],c=s[0];c--;)a=a.lastChild;$.merge(h,a.childNodes),a=u.firstChild,a.textContent=""}else h.push(r.createTextNode(i));for(u.textContent="",d=0;i=h[d++];)if((!t||-1===$.inArray(i,t))&&(l=$.contains(i.ownerDocument,i),a=v(u.appendChild(i),"script"),l&&m(a),e))for(c=0;i=a[c++];)On.test(i.type||"")&&e.push(i);return u},cleanData:function(n){for(var r,e,t,i,a=$.event.special,o=0;void 0!==(e=n[o]);o++){if($.acceptData(e)&&(i=e[yn.expando],i&&(r=yn.cache[i]))){if(r.events)for(t in r.events)a[t]?$.event.remove(e,t):$.removeEvent(e,t,r.handle);yn.cache[i]&&delete yn.cache[i]}delete En.cache[e[En.expando]]}}}),$.fn.extend({text:function(n){return vn(this,function(n){return void 0===n?$.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=n)})},null,n,arguments.length)},append:function(){return this.domManip(arguments,function(n){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var r=d(this,n);r.appendChild(n)}})},prepend:function(){return this.domManip(arguments,function(n){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var r=d(this,n);r.insertBefore(n,r.firstChild)}})},before:function(){return this.domManip(arguments,function(n){this.parentNode&&this.parentNode.insertBefore(n,this)})},after:function(){return this.domManip(arguments,function(n){this.parentNode&&this.parentNode.insertBefore(n,this.nextSibling)})},remove:function(n,r){for(var e,t=n?$.filter(n,this):this,i=0;null!=(e=t[i]);i++)r||1!==e.nodeType||$.cleanData(v(e)),e.parentNode&&(r&&$.contains(e.ownerDocument,e)&&m(v(e,"script")),e.parentNode.removeChild(e));return this},empty:function(){for(var n,r=0;null!=(n=this[r]);r++)1===n.nodeType&&($.cleanData(v(n,!1)),n.textContent="");return this},clone:function(n,r){return n=null==n?!1:n,r=null==r?n:r,this.map(function(){return $.clone(this,n,r)})},html:function(n){return vn(this,function(n){var r=this[0]||{},e=0,t=this.length;if(void 0===n&&1===r.nodeType)return r.innerHTML;if("string"==typeof n&&!Ln.test(n)&&!zn[(jn.exec(n)||["",""])[1].toLowerCase()]){n=n.replace(kn,"<$1></$2>");try{for(;t>e;e++)r=this[e]||{},1===r.nodeType&&($.cleanData(v(r,!1)),r.innerHTML=n);r=0}catch(i){}}r&&this.empty().append(n)},null,n,arguments.length)},replaceWith:function(){var n=arguments[0];return this.domManip(arguments,function(r){n=this.parentNode,$.cleanData(v(this)),n&&n.replaceChild(r,this)}),n&&(n.length||n.nodeType)?this:this.remove()},detach:function(n){return this.remove(n,!0)},domManip:function(n,r){n=G.apply([],n);var e,t,i,a,o,s,l=0,c=this.length,u=this,h=c-1,d=n[0],m=$.isFunction(d);if(m||c>1&&"string"==typeof d&&!Z.checkClone&&Fn.test(d))return this.each(function(e){var t=u.eq(e);m&&(n[0]=d.call(this,e,t.html())),t.domManip(n,r)});if(c&&(e=$.buildFragment(n,this[0].ownerDocument,!1,this),t=e.firstChild,1===e.childNodes.length&&(e=t),t)){for(i=$.map(v(e,"script"),p),a=i.length;c>l;l++)o=e,l!==h&&(o=$.clone(o,!0,!0),a&&$.merge(i,v(o,"script"))),r.call(this[l],o,l);if(a)for(s=i[i.length-1].ownerDocument,$.map(i,f),l=0;a>l;l++)o=i[l],On.test(o.type||"")&&!yn.access(o,"globalEval")&&$.contains(s,o)&&(o.src?$._evalUrl&&$._evalUrl(o.src):$.globalEval(o.textContent.replace(In,"")))}return this}}),$.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(n,r){$.fn[n]=function(n){for(var e,t=[],i=$(n),a=i.length-1,o=0;a>=o;o++)e=o===a?this:this.clone(!0),$(i[o])[r](e),W.apply(t,e.get());return this.pushStack(t)}});var Bn,Nn={},Un=/^margin/,Vn=new RegExp("^("+Tn+")(?!px)[a-z%]+$","i"),Gn=function(r){return r.ownerDocument.defaultView.opener?r.ownerDocument.defaultView.getComputedStyle(r,null):n.getComputedStyle(r,null)};!function(){function r(){o.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",o.innerHTML="",i.appendChild(a);var r=n.getComputedStyle(o,null);e="1%"!==r.top,t="4px"===r.width,i.removeChild(a)}var e,t,i=Q.documentElement,a=Q.createElement("div"),o=Q.createElement("div");o.style&&(o.style.backgroundClip="content-box",o.cloneNode(!0).style.backgroundClip="",Z.clearCloneStyle="content-box"===o.style.backgroundClip,a.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",a.appendChild(o),n.getComputedStyle&&$.extend(Z,{pixelPosition:function(){return r(),e},boxSizingReliable:function(){return null==t&&r(),t},reliableMarginRight:function(){var r,e=o.appendChild(Q.createElement("div"));return e.style.cssText=o.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",e.style.marginRight=e.style.width="0",o.style.width="1px",i.appendChild(a),r=!parseFloat(n.getComputedStyle(e,null).marginRight),i.removeChild(a),o.removeChild(e),r}}))}(),$.swap=function(n,r,e,t){var i,a,o={};for(a in r)o[a]=n.style[a],n.style[a]=r[a];i=e.apply(n,t||[]);for(a in r)n.style[a]=o[a];return i};var Wn=/^(none|table(?!-c[ea]).+)/,qn=new RegExp("^("+Tn+")(.*)$","i"),Xn=new RegExp("^([+-])=("+Tn+")","i"),Yn={position:"absolute",visibility:"hidden",display:"block"},Kn={letterSpacing:"0",fontWeight:"400"},Zn=["Webkit","O","Moz","ms"];$.extend({cssHooks:{opacity:{get:function(n,r){if(r){var e=x(n,"opacity");return""===e?"1":e}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(n,r,e,t){if(n&&3!==n.nodeType&&8!==n.nodeType&&n.style){var i,a,o,s=$.camelCase(r),l=n.style;return r=$.cssProps[s]||($.cssProps[s]=_(l,s)),o=$.cssHooks[r]||$.cssHooks[s],void 0===e?o&&"get"in o&&void 0!==(i=o.get(n,!1,t))?i:l[r]:(a=typeof e,"string"===a&&(i=Xn.exec(e))&&(e=(i[1]+1)*i[2]+parseFloat($.css(n,r)),a="number"),null!=e&&e===e&&("number"!==a||$.cssNumber[s]||(e+="px"),Z.clearCloneStyle||""!==e||0!==r.indexOf("background")||(l[r]="inherit"),o&&"set"in o&&void 0===(e=o.set(n,e,t))||(l[r]=e)),void 0)}},css:function(n,r,e,t){var i,a,o,s=$.camelCase(r);return r=$.cssProps[s]||($.cssProps[s]=_(n.style,s)),o=$.cssHooks[r]||$.cssHooks[s],o&&"get"in o&&(i=o.get(n,!0,e)),void 0===i&&(i=x(n,r,t)),"normal"===i&&r in Kn&&(i=Kn[r]),""===e||e?(a=parseFloat(i),e===!0||$.isNumeric(a)?a||0:i):i}}),$.each(["height","width"],function(n,r){$.cssHooks[r]={get:function(n,e,t){return e?Wn.test($.css(n,"display"))&&0===n.offsetWidth?$.swap(n,Yn,function(){return H(n,r,t)}):H(n,r,t):void 0},set:function(n,e,t){var i=t&&Gn(n);return w(n,e,t?R(n,r,t,"border-box"===$.css(n,"boxSizing",!1,i),i):0)}}}),$.cssHooks.marginRight=T(Z.reliableMarginRight,function(n,r){return r?$.swap(n,{display:"inline-block"},x,[n,"marginRight"]):void 0}),$.each({margin:"",padding:"",border:"Width"},function(n,r){$.cssHooks[n+r]={expand:function(e){for(var t=0,i={},a="string"==typeof e?e.split(" "):[e];4>t;t++)i[n+_n[t]+r]=a[t]||a[t-2]||a[0];return i}},Un.test(n)||($.cssHooks[n+r].set=w)}),$.fn.extend({css:function(n,r){return vn(this,function(n,r,e){var t,i,a={},o=0;if($.isArray(r)){for(t=Gn(n),i=r.length;i>o;o++)a[r[o]]=$.css(n,r[o],!1,t);return a}return void 0!==e?$.style(n,r,e):$.css(n,r)},n,r,arguments.length>1)},show:function(){return S(this,!0)},hide:function(){return S(this)},toggle:function(n){return"boolean"==typeof n?n?this.show():this.hide():this.each(function(){wn(this)?$(this).show():$(this).hide()})}}),$.Tween=A,A.prototype={constructor:A,init:function(n,r,e,t,i,a){this.elem=n,this.prop=e,this.easing=i||"swing",this.options=r,this.start=this.now=this.cur(),this.end=t,this.unit=a||($.cssNumber[e]?"":"px")},cur:function(){var n=A.propHooks[this.prop];return n&&n.get?n.get(this):A.propHooks._default.get(this)},run:function(n){var r,e=A.propHooks[this.prop];return this.options.duration?this.pos=r=$.easing[this.easing](n,this.options.duration*n,0,1,this.options.duration):this.pos=r=n,this.now=(this.end-this.start)*r+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),e&&e.set?e.set(this):A.propHooks._default.set(this),this}},A.prototype.init.prototype=A.prototype,A.propHooks={_default:{get:function(n){var r;return null==n.elem[n.prop]||n.elem.style&&null!=n.elem.style[n.prop]?(r=$.css(n.elem,n.prop,""),r&&"auto"!==r?r:0):n.elem[n.prop]},set:function(n){$.fx.step[n.prop]?$.fx.step[n.prop](n):n.elem.style&&(null!=n.elem.style[$.cssProps[n.prop]]||$.cssHooks[n.prop])?$.style(n.elem,n.prop,n.now+n.unit):n.elem[n.prop]=n.now}}},A.propHooks.scrollTop=A.propHooks.scrollLeft={set:function(n){n.elem.nodeType&&n.elem.parentNode&&(n.elem[n.prop]=n.now)}},$.easing={linear:function(n){return n},swing:function(n){return.5-Math.cos(n*Math.PI)/2}},$.fx=A.prototype.init,$.fx.step={};var Qn,Jn,$n=/^(?:toggle|show|hide)$/,nr=new RegExp("^(?:([+-])=|)("+Tn+")([a-z%]*)$","i"),rr=/queueHooks$/,er=[j],tr={"*":[function(n,r){var e=this.createTween(n,r),t=e.cur(),i=nr.exec(r),a=i&&i[3]||($.cssNumber[n]?"":"px"),o=($.cssNumber[n]||"px"!==a&&+t)&&nr.exec($.css(e.elem,n)),s=1,l=20;if(o&&o[3]!==a){a=a||o[3],i=i||[],o=+t||1;do s=s||".5",o/=s,$.style(e.elem,n,o+a);while(s!==(s=e.cur()/t)&&1!==s&&--l)}return i&&(o=e.start=+o||+t||0,e.unit=a,e.end=i[1]?o+(i[1]+1)*i[2]:+i[2]),e}]};$.Animation=$.extend(L,{tweener:function(n,r){$.isFunction(n)?(r=n,n=["*"]):n=n.split(" ");for(var e,t=0,i=n.length;i>t;t++)e=n[t],tr[e]=tr[e]||[],tr[e].unshift(r)},prefilter:function(n,r){r?er.unshift(n):er.push(n)}}),$.speed=function(n,r,e){var t=n&&"object"==typeof n?$.extend({},n):{complete:e||!e&&r||$.isFunction(n)&&n,duration:n,easing:e&&r||r&&!$.isFunction(r)&&r};return t.duration=$.fx.off?0:"number"==typeof t.duration?t.duration:t.duration in $.fx.speeds?$.fx.speeds[t.duration]:$.fx.speeds._default,(null==t.queue||t.queue===!0)&&(t.queue="fx"),t.old=t.complete,t.complete=function(){$.isFunction(t.old)&&t.old.call(this),t.queue&&$.dequeue(this,t.queue)},t},$.fn.extend({fadeTo:function(n,r,e,t){return this.filter(wn).css("opacity",0).show().end().animate({opacity:r},n,e,t)},animate:function(n,r,e,t){var i=$.isEmptyObject(n),a=$.speed(r,e,t),o=function(){var r=L(this,$.extend({},n),a);(i||yn.get(this,"finish"))&&r.stop(!0)};return o.finish=o,i||a.queue===!1?this.each(o):this.queue(a.queue,o)},stop:function(n,r,e){var t=function(n){var r=n.stop;delete n.stop,r(e)};return"string"!=typeof n&&(e=r,r=n,n=void 0),r&&n!==!1&&this.queue(n||"fx",[]),this.each(function(){var r=!0,i=null!=n&&n+"queueHooks",a=$.timers,o=yn.get(this);if(i)o[i]&&o[i].stop&&t(o[i]);else for(i in o)o[i]&&o[i].stop&&rr.test(i)&&t(o[i]);for(i=a.length;i--;)a[i].elem!==this||null!=n&&a[i].queue!==n||(a[i].anim.stop(e),r=!1,a.splice(i,1));(r||!e)&&$.dequeue(this,n)})},finish:function(n){return n!==!1&&(n=n||"fx"),this.each(function(){var r,e=yn.get(this),t=e[n+"queue"],i=e[n+"queueHooks"],a=$.timers,o=t?t.length:0;for(e.finish=!0,$.queue(this,n,[]),
i&&i.stop&&i.stop.call(this,!0),r=a.length;r--;)a[r].elem===this&&a[r].queue===n&&(a[r].anim.stop(!0),a.splice(r,1));for(r=0;o>r;r++)t[r]&&t[r].finish&&t[r].finish.call(this);delete e.finish})}}),$.each(["toggle","show","hide"],function(n,r){var e=$.fn[r];$.fn[r]=function(n,t,i){return null==n||"boolean"==typeof n?e.apply(this,arguments):this.animate(C(r,!0),n,t,i)}}),$.each({slideDown:C("show"),slideUp:C("hide"),slideToggle:C("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(n,r){$.fn[n]=function(n,e,t){return this.animate(r,n,e,t)}}),$.timers=[],$.fx.tick=function(){var n,r=0,e=$.timers;for(Qn=$.now();r<e.length;r++)n=e[r],n()||e[r]!==n||e.splice(r--,1);e.length||$.fx.stop(),Qn=void 0},$.fx.timer=function(n){$.timers.push(n),n()?$.fx.start():$.timers.pop()},$.fx.interval=13,$.fx.start=function(){Jn||(Jn=setInterval($.fx.tick,$.fx.interval))},$.fx.stop=function(){clearInterval(Jn),Jn=null},$.fx.speeds={slow:600,fast:200,_default:400},$.fn.delay=function(n,r){return n=$.fx?$.fx.speeds[n]||n:n,r=r||"fx",this.queue(r,function(r,e){var t=setTimeout(r,n);e.stop=function(){clearTimeout(t)}})},function(){var n=Q.createElement("input"),r=Q.createElement("select"),e=r.appendChild(Q.createElement("option"));n.type="checkbox",Z.checkOn=""!==n.value,Z.optSelected=e.selected,r.disabled=!0,Z.optDisabled=!e.disabled,n=Q.createElement("input"),n.value="t",n.type="radio",Z.radioValue="t"===n.value}();var ir,ar,or=$.expr.attrHandle;$.fn.extend({attr:function(n,r){return vn(this,$.attr,n,r,arguments.length>1)},removeAttr:function(n){return this.each(function(){$.removeAttr(this,n)})}}),$.extend({attr:function(n,r,e){var t,i,a=n.nodeType;if(n&&3!==a&&8!==a&&2!==a)return typeof n.getAttribute===Hn?$.prop(n,r,e):(1===a&&$.isXMLDoc(n)||(r=r.toLowerCase(),t=$.attrHooks[r]||($.expr.match.bool.test(r)?ar:ir)),void 0===e?t&&"get"in t&&null!==(i=t.get(n,r))?i:(i=$.find.attr(n,r),null==i?void 0:i):null!==e?t&&"set"in t&&void 0!==(i=t.set(n,e,r))?i:(n.setAttribute(r,e+""),e):void $.removeAttr(n,r))},removeAttr:function(n,r){var e,t,i=0,a=r&&r.match(fn);if(a&&1===n.nodeType)for(;e=a[i++];)t=$.propFix[e]||e,$.expr.match.bool.test(e)&&(n[t]=!1),n.removeAttribute(e)},attrHooks:{type:{set:function(n,r){if(!Z.radioValue&&"radio"===r&&$.nodeName(n,"input")){var e=n.value;return n.setAttribute("type",r),e&&(n.value=e),r}}}}}),ar={set:function(n,r,e){return r===!1?$.removeAttr(n,e):n.setAttribute(e,e),e}},$.each($.expr.match.bool.source.match(/\w+/g),function(n,r){var e=or[r]||$.find.attr;or[r]=function(n,r,t){var i,a;return t||(a=or[r],or[r]=i,i=null!=e(n,r,t)?r.toLowerCase():null,or[r]=a),i}});var sr=/^(?:input|select|textarea|button)$/i;$.fn.extend({prop:function(n,r){return vn(this,$.prop,n,r,arguments.length>1)},removeProp:function(n){return this.each(function(){delete this[$.propFix[n]||n]})}}),$.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(n,r,e){var t,i,a,o=n.nodeType;if(n&&3!==o&&8!==o&&2!==o)return a=1!==o||!$.isXMLDoc(n),a&&(r=$.propFix[r]||r,i=$.propHooks[r]),void 0!==e?i&&"set"in i&&void 0!==(t=i.set(n,e,r))?t:n[r]=e:i&&"get"in i&&null!==(t=i.get(n,r))?t:n[r]},propHooks:{tabIndex:{get:function(n){return n.hasAttribute("tabindex")||sr.test(n.nodeName)||n.href?n.tabIndex:-1}}}}),Z.optSelected||($.propHooks.selected={get:function(n){var r=n.parentNode;return r&&r.parentNode&&r.parentNode.selectedIndex,null}}),$.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){$.propFix[this.toLowerCase()]=this});var lr=/[\t\r\n\f]/g;$.fn.extend({addClass:function(n){var r,e,t,i,a,o,s="string"==typeof n&&n,l=0,c=this.length;if($.isFunction(n))return this.each(function(r){$(this).addClass(n.call(this,r,this.className))});if(s)for(r=(n||"").match(fn)||[];c>l;l++)if(e=this[l],t=1===e.nodeType&&(e.className?(" "+e.className+" ").replace(lr," "):" ")){for(a=0;i=r[a++];)t.indexOf(" "+i+" ")<0&&(t+=i+" ");o=$.trim(t),e.className!==o&&(e.className=o)}return this},removeClass:function(n){var r,e,t,i,a,o,s=0===arguments.length||"string"==typeof n&&n,l=0,c=this.length;if($.isFunction(n))return this.each(function(r){$(this).removeClass(n.call(this,r,this.className))});if(s)for(r=(n||"").match(fn)||[];c>l;l++)if(e=this[l],t=1===e.nodeType&&(e.className?(" "+e.className+" ").replace(lr," "):"")){for(a=0;i=r[a++];)for(;t.indexOf(" "+i+" ")>=0;)t=t.replace(" "+i+" "," ");o=n?$.trim(t):"",e.className!==o&&(e.className=o)}return this},toggleClass:function(n,r){var e=typeof n;return"boolean"==typeof r&&"string"===e?r?this.addClass(n):this.removeClass(n):$.isFunction(n)?this.each(function(e){$(this).toggleClass(n.call(this,e,this.className,r),r)}):this.each(function(){if("string"===e)for(var r,t=0,i=$(this),a=n.match(fn)||[];r=a[t++];)i.hasClass(r)?i.removeClass(r):i.addClass(r);else(e===Hn||"boolean"===e)&&(this.className&&yn.set(this,"__className__",this.className),this.className=this.className||n===!1?"":yn.get(this,"__className__")||"")})},hasClass:function(n){for(var r=" "+n+" ",e=0,t=this.length;t>e;e++)if(1===this[e].nodeType&&(" "+this[e].className+" ").replace(lr," ").indexOf(r)>=0)return!0;return!1}});var cr=/\r/g;$.fn.extend({val:function(n){var r,e,t,i=this[0];{if(arguments.length)return t=$.isFunction(n),this.each(function(e){var i;1===this.nodeType&&(i=t?n.call(this,e,$(this).val()):n,null==i?i="":"number"==typeof i?i+="":$.isArray(i)&&(i=$.map(i,function(n){return null==n?"":n+""})),r=$.valHooks[this.type]||$.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&void 0!==r.set(this,i,"value")||(this.value=i))});if(i)return r=$.valHooks[i.type]||$.valHooks[i.nodeName.toLowerCase()],r&&"get"in r&&void 0!==(e=r.get(i,"value"))?e:(e=i.value,"string"==typeof e?e.replace(cr,""):null==e?"":e)}}}),$.extend({valHooks:{option:{get:function(n){var r=$.find.attr(n,"value");return null!=r?r:$.trim($.text(n))}},select:{get:function(n){for(var r,e,t=n.options,i=n.selectedIndex,a="select-one"===n.type||0>i,o=a?null:[],s=a?i+1:t.length,l=0>i?s:a?i:0;s>l;l++)if(e=t[l],(e.selected||l===i)&&(Z.optDisabled?!e.disabled:null===e.getAttribute("disabled"))&&(!e.parentNode.disabled||!$.nodeName(e.parentNode,"optgroup"))){if(r=$(e).val(),a)return r;o.push(r)}return o},set:function(n,r){for(var e,t,i=n.options,a=$.makeArray(r),o=i.length;o--;)t=i[o],(t.selected=$.inArray(t.value,a)>=0)&&(e=!0);return e||(n.selectedIndex=-1),a}}}}),$.each(["radio","checkbox"],function(){$.valHooks[this]={set:function(n,r){return $.isArray(r)?n.checked=$.inArray($(n).val(),r)>=0:void 0}},Z.checkOn||($.valHooks[this].get=function(n){return null===n.getAttribute("value")?"on":n.value})}),$.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(n,r){$.fn[r]=function(n,e){return arguments.length>0?this.on(r,null,n,e):this.trigger(r)}}),$.fn.extend({hover:function(n,r){return this.mouseenter(n).mouseleave(r||n)},bind:function(n,r,e){return this.on(n,null,r,e)},unbind:function(n,r){return this.off(n,null,r)},delegate:function(n,r,e,t){return this.on(r,n,e,t)},undelegate:function(n,r,e){return 1===arguments.length?this.off(n,"**"):this.off(r,n||"**",e)}});var ur=$.now(),hr=/\?/;$.parseJSON=function(n){return JSON.parse(n+"")},$.parseXML=function(n){var r,e;if(!n||"string"!=typeof n)return null;try{e=new DOMParser,r=e.parseFromString(n,"text/xml")}catch(t){r=void 0}return(!r||r.getElementsByTagName("parsererror").length)&&$.error("Invalid XML: "+n),r};var dr=/#.*$/,pr=/([?&])_=[^&]*/,fr=/^(.*?):[ \t]*([^\r\n]*)$/gm,mr=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,gr=/^(?:GET|HEAD)$/,vr=/^\/\//,yr=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Er={},br={},xr="*/".concat("*"),Tr=n.location.href,_r=yr.exec(Tr.toLowerCase())||[];$.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tr,type:"GET",isLocal:mr.test(_r[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":xr,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":$.parseJSON,"text xml":$.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(n,r){return r?D(D(n,$.ajaxSettings),r):D($.ajaxSettings,n)},ajaxPrefilter:F(Er),ajaxTransport:F(br),ajax:function(n,r){function e(n,r,e,o){var l,u,v,y,b,T=r;2!==E&&(E=2,s&&clearTimeout(s),t=void 0,a=o||"",x.readyState=n>0?4:0,l=n>=200&&300>n||304===n,e&&(y=I(h,x,e)),y=z(h,y,x,l),l?(h.ifModified&&(b=x.getResponseHeader("Last-Modified"),b&&($.lastModified[i]=b),b=x.getResponseHeader("etag"),b&&($.etag[i]=b)),204===n||"HEAD"===h.type?T="nocontent":304===n?T="notmodified":(T=y.state,u=y.data,v=y.error,l=!v)):(v=T,(n||!T)&&(T="error",0>n&&(n=0))),x.status=n,x.statusText=(r||T)+"",l?f.resolveWith(d,[u,T,x]):f.rejectWith(d,[x,T,v]),x.statusCode(g),g=void 0,c&&p.trigger(l?"ajaxSuccess":"ajaxError",[x,h,l?u:v]),m.fireWith(d,[x,T]),c&&(p.trigger("ajaxComplete",[x,h]),--$.active||$.event.trigger("ajaxStop")))}"object"==typeof n&&(r=n,n=void 0),r=r||{};var t,i,a,o,s,l,c,u,h=$.ajaxSetup({},r),d=h.context||h,p=h.context&&(d.nodeType||d.jquery)?$(d):$.event,f=$.Deferred(),m=$.Callbacks("once memory"),g=h.statusCode||{},v={},y={},E=0,b="canceled",x={readyState:0,getResponseHeader:function(n){var r;if(2===E){if(!o)for(o={};r=fr.exec(a);)o[r[1].toLowerCase()]=r[2];r=o[n.toLowerCase()]}return null==r?null:r},getAllResponseHeaders:function(){return 2===E?a:null},setRequestHeader:function(n,r){var e=n.toLowerCase();return E||(n=y[e]=y[e]||n,v[n]=r),this},overrideMimeType:function(n){return E||(h.mimeType=n),this},statusCode:function(n){var r;if(n)if(2>E)for(r in n)g[r]=[g[r],n[r]];else x.always(n[x.status]);return this},abort:function(n){var r=n||b;return t&&t.abort(r),e(0,r),this}};if(f.promise(x).complete=m.add,x.success=x.done,x.error=x.fail,h.url=((n||h.url||Tr)+"").replace(dr,"").replace(vr,_r[1]+"//"),h.type=r.method||r.type||h.method||h.type,h.dataTypes=$.trim(h.dataType||"*").toLowerCase().match(fn)||[""],null==h.crossDomain&&(l=yr.exec(h.url.toLowerCase()),h.crossDomain=!(!l||l[1]===_r[1]&&l[2]===_r[2]&&(l[3]||("http:"===l[1]?"80":"443"))===(_r[3]||("http:"===_r[1]?"80":"443")))),h.data&&h.processData&&"string"!=typeof h.data&&(h.data=$.param(h.data,h.traditional)),O(Er,h,r,x),2===E)return x;c=$.event&&h.global,c&&0===$.active++&&$.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!gr.test(h.type),i=h.url,h.hasContent||(h.data&&(i=h.url+=(hr.test(i)?"&":"?")+h.data,delete h.data),h.cache===!1&&(h.url=pr.test(i)?i.replace(pr,"$1_="+ur++):i+(hr.test(i)?"&":"?")+"_="+ur++)),h.ifModified&&($.lastModified[i]&&x.setRequestHeader("If-Modified-Since",$.lastModified[i]),$.etag[i]&&x.setRequestHeader("If-None-Match",$.etag[i])),(h.data&&h.hasContent&&h.contentType!==!1||r.contentType)&&x.setRequestHeader("Content-Type",h.contentType),x.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+xr+"; q=0.01":""):h.accepts["*"]);for(u in h.headers)x.setRequestHeader(u,h.headers[u]);if(h.beforeSend&&(h.beforeSend.call(d,x,h)===!1||2===E))return x.abort();b="abort";for(u in{success:1,error:1,complete:1})x[u](h[u]);if(t=O(br,h,r,x)){x.readyState=1,c&&p.trigger("ajaxSend",[x,h]),h.async&&h.timeout>0&&(s=setTimeout(function(){x.abort("timeout")},h.timeout));try{E=1,t.send(v,e)}catch(T){if(!(2>E))throw T;e(-1,T)}}else e(-1,"No Transport");return x},getJSON:function(n,r,e){return $.get(n,r,e,"json")},getScript:function(n,r){return $.get(n,void 0,r,"script")}}),$.each(["get","post"],function(n,r){$[r]=function(n,e,t,i){return $.isFunction(e)&&(i=i||t,t=e,e=void 0),$.ajax({url:n,type:r,dataType:i,data:e,success:t})}}),$._evalUrl=function(n){return $.ajax({url:n,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},$.fn.extend({wrapAll:function(n){var r;return $.isFunction(n)?this.each(function(r){$(this).wrapAll(n.call(this,r))}):(this[0]&&(r=$(n,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&r.insertBefore(this[0]),r.map(function(){for(var n=this;n.firstElementChild;)n=n.firstElementChild;return n}).append(this)),this)},wrapInner:function(n){return $.isFunction(n)?this.each(function(r){$(this).wrapInner(n.call(this,r))}):this.each(function(){var r=$(this),e=r.contents();e.length?e.wrapAll(n):r.append(n)})},wrap:function(n){var r=$.isFunction(n);return this.each(function(e){$(this).wrapAll(r?n.call(this,e):n)})},unwrap:function(){return this.parent().each(function(){$.nodeName(this,"body")||$(this).replaceWith(this.childNodes)}).end()}}),$.expr.filters.hidden=function(n){return n.offsetWidth<=0&&n.offsetHeight<=0},$.expr.filters.visible=function(n){return!$.expr.filters.hidden(n)};var wr=/%20/g,Rr=/\[\]$/,Hr=/\r?\n/g,Sr=/^(?:submit|button|image|reset|file)$/i,Ar=/^(?:input|select|textarea|keygen)/i;$.param=function(n,r){var e,t=[],i=function(n,r){r=$.isFunction(r)?r():null==r?"":r,t[t.length]=encodeURIComponent(n)+"="+encodeURIComponent(r)};if(void 0===r&&(r=$.ajaxSettings&&$.ajaxSettings.traditional),$.isArray(n)||n.jquery&&!$.isPlainObject(n))$.each(n,function(){i(this.name,this.value)});else for(e in n)B(e,n[e],r,i);return t.join("&").replace(wr,"+")},$.fn.extend({serialize:function(){return $.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var n=$.prop(this,"elements");return n?$.makeArray(n):this}).filter(function(){var n=this.type;return this.name&&!$(this).is(":disabled")&&Ar.test(this.nodeName)&&!Sr.test(n)&&(this.checked||!Rn.test(n))}).map(function(n,r){var e=$(this).val();return null==e?null:$.isArray(e)?$.map(e,function(n){return{name:r.name,value:n.replace(Hr,"\r\n")}}):{name:r.name,value:e.replace(Hr,"\r\n")}}).get()}}),$.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(n){}};var Mr=0,Cr={},kr={0:200,1223:204},jr=$.ajaxSettings.xhr();n.attachEvent&&n.attachEvent("onunload",function(){for(var n in Cr)Cr[n]()}),Z.cors=!!jr&&"withCredentials"in jr,Z.ajax=jr=!!jr,$.ajaxTransport(function(n){var r;return Z.cors||jr&&!n.crossDomain?{send:function(e,t){var i,a=n.xhr(),o=++Mr;if(a.open(n.type,n.url,n.async,n.username,n.password),n.xhrFields)for(i in n.xhrFields)a[i]=n.xhrFields[i];n.mimeType&&a.overrideMimeType&&a.overrideMimeType(n.mimeType),n.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(i in e)a.setRequestHeader(i,e[i]);r=function(n){return function(){r&&(delete Cr[o],r=a.onload=a.onerror=null,"abort"===n?a.abort():"error"===n?t(a.status,a.statusText):t(kr[a.status]||a.status,a.statusText,"string"==typeof a.responseText?{text:a.responseText}:void 0,a.getAllResponseHeaders()))}},a.onload=r(),a.onerror=r("error"),r=Cr[o]=r("abort");try{a.send(n.hasContent&&n.data||null)}catch(s){if(r)throw s}},abort:function(){r&&r()}}:void 0}),$.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(n){return $.globalEval(n),n}}}),$.ajaxPrefilter("script",function(n){void 0===n.cache&&(n.cache=!1),n.crossDomain&&(n.type="GET")}),$.ajaxTransport("script",function(n){if(n.crossDomain){var r,e;return{send:function(t,i){r=$("<script>").prop({async:!0,charset:n.scriptCharset,src:n.url}).on("load error",e=function(n){r.remove(),e=null,n&&i("error"===n.type?404:200,n.type)}),Q.head.appendChild(r[0])},abort:function(){e&&e()}}}});var Pr=[],Lr=/(=)\?(?=&|$)|\?\?/;$.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var n=Pr.pop()||$.expando+"_"+ur++;return this[n]=!0,n}}),$.ajaxPrefilter("json jsonp",function(r,e,t){var i,a,o,s=r.jsonp!==!1&&(Lr.test(r.url)?"url":"string"==typeof r.data&&!(r.contentType||"").indexOf("application/x-www-form-urlencoded")&&Lr.test(r.data)&&"data");return s||"jsonp"===r.dataTypes[0]?(i=r.jsonpCallback=$.isFunction(r.jsonpCallback)?r.jsonpCallback():r.jsonpCallback,s?r[s]=r[s].replace(Lr,"$1"+i):r.jsonp!==!1&&(r.url+=(hr.test(r.url)?"&":"?")+r.jsonp+"="+i),r.converters["script json"]=function(){return o||$.error(i+" was not called"),o[0]},r.dataTypes[0]="json",a=n[i],n[i]=function(){o=arguments},t.always(function(){n[i]=a,r[i]&&(r.jsonpCallback=e.jsonpCallback,Pr.push(i)),o&&$.isFunction(a)&&a(o[0]),o=a=void 0}),"script"):void 0}),$.parseHTML=function(n,r,e){if(!n||"string"!=typeof n)return null;"boolean"==typeof r&&(e=r,r=!1),r=r||Q;var t=sn.exec(n),i=!e&&[];return t?[r.createElement(t[1])]:(t=$.buildFragment([n],r,i),i&&i.length&&$(i).remove(),$.merge([],t.childNodes))};var Fr=$.fn.load;$.fn.load=function(n,r,e){if("string"!=typeof n&&Fr)return Fr.apply(this,arguments);var t,i,a,o=this,s=n.indexOf(" ");return s>=0&&(t=$.trim(n.slice(s)),n=n.slice(0,s)),$.isFunction(r)?(e=r,r=void 0):r&&"object"==typeof r&&(i="POST"),o.length>0&&$.ajax({url:n,type:i,dataType:"html",data:r}).done(function(n){a=arguments,o.html(t?$("<div>").append($.parseHTML(n)).find(t):n)}).complete(e&&function(n,r){o.each(e,a||[n.responseText,r,n])}),this},$.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(n,r){$.fn[r]=function(n){return this.on(r,n)}}),$.expr.filters.animated=function(n){return $.grep($.timers,function(r){return n===r.elem}).length};var Or=n.document.documentElement;$.offset={setOffset:function(n,r,e){var t,i,a,o,s,l,c,u=$.css(n,"position"),h=$(n),d={};"static"===u&&(n.style.position="relative"),s=h.offset(),a=$.css(n,"top"),l=$.css(n,"left"),c=("absolute"===u||"fixed"===u)&&(a+l).indexOf("auto")>-1,c?(t=h.position(),o=t.top,i=t.left):(o=parseFloat(a)||0,i=parseFloat(l)||0),$.isFunction(r)&&(r=r.call(n,e,s)),null!=r.top&&(d.top=r.top-s.top+o),null!=r.left&&(d.left=r.left-s.left+i),"using"in r?r.using.call(n,d):h.css(d)}},$.fn.extend({offset:function(n){if(arguments.length)return void 0===n?this:this.each(function(r){$.offset.setOffset(this,n,r)});var r,e,t=this[0],i={top:0,left:0},a=t&&t.ownerDocument;if(a)return r=a.documentElement,$.contains(r,t)?(typeof t.getBoundingClientRect!==Hn&&(i=t.getBoundingClientRect()),e=N(a),{top:i.top+e.pageYOffset-r.clientTop,left:i.left+e.pageXOffset-r.clientLeft}):i},position:function(){if(this[0]){var n,r,e=this[0],t={top:0,left:0};return"fixed"===$.css(e,"position")?r=e.getBoundingClientRect():(n=this.offsetParent(),r=this.offset(),$.nodeName(n[0],"html")||(t=n.offset()),t.top+=$.css(n[0],"borderTopWidth",!0),t.left+=$.css(n[0],"borderLeftWidth",!0)),{top:r.top-t.top-$.css(e,"marginTop",!0),left:r.left-t.left-$.css(e,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var n=this.offsetParent||Or;n&&!$.nodeName(n,"html")&&"static"===$.css(n,"position");)n=n.offsetParent;return n||Or})}}),$.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(r,e){var t="pageYOffset"===e;$.fn[r]=function(i){return vn(this,function(r,i,a){var o=N(r);return void 0===a?o?o[e]:r[i]:void(o?o.scrollTo(t?n.pageXOffset:a,t?a:n.pageYOffset):r[i]=a)},r,i,arguments.length,null)}}),$.each(["top","left"],function(n,r){$.cssHooks[r]=T(Z.pixelPosition,function(n,e){return e?(e=x(n,r),Vn.test(e)?$(n).position()[r]+"px":e):void 0})}),$.each({Height:"height",Width:"width"},function(n,r){$.each({padding:"inner"+n,content:r,"":"outer"+n},function(e,t){$.fn[t]=function(t,i){var a=arguments.length&&(e||"boolean"!=typeof t),o=e||(t===!0||i===!0?"margin":"border");return vn(this,function(r,e,t){var i;return $.isWindow(r)?r.document.documentElement["client"+n]:9===r.nodeType?(i=r.documentElement,Math.max(r.body["scroll"+n],i["scroll"+n],r.body["offset"+n],i["offset"+n],i["client"+n])):void 0===t?$.css(r,e,o):$.style(r,e,t,o)},r,a?t:void 0,a,null)}})}),$.fn.size=function(){return this.length},$.fn.andSelf=$.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return $});var Dr=n.jQuery,Ir=n.$;return $.noConflict=function(r){return n.$===$&&(n.$=Ir),r&&n.jQuery===$&&(n.jQuery=Dr),$},typeof r===Hn&&(n.jQuery=n.$=$),$}),function(){function n(n,r){if(n!==r){var e=null===n,t=n===T,i=n===n,a=null===r,o=r===T,s=r===r;if(n>r&&!a||!i||e&&!o&&s||t&&s)return 1;if(r>n&&!e||!s||a&&!t&&i||o&&i)return-1}return 0}function r(n,r,e){for(var t=n.length,i=e?t:-1;e?i--:++i<t;)if(r(n[i],i,n))return i;return-1}function e(n,r,e){if(r!==r)return p(n,e);for(var t=e-1,i=n.length;++t<i;)if(n[t]===r)return t;return-1}function t(n){return"function"==typeof n||!1}function i(n){return null==n?"":n+""}function a(n,r){for(var e=-1,t=n.length;++e<t&&r.indexOf(n.charAt(e))>-1;);return e}function o(n,r){for(var e=n.length;e--&&r.indexOf(n.charAt(e))>-1;);return e}function s(r,e){return n(r.criteria,e.criteria)||r.index-e.index}function l(r,e,t){for(var i=-1,a=r.criteria,o=e.criteria,s=a.length,l=t.length;++i<s;){var c=n(a[i],o[i]);if(c){if(i>=l)return c;var u=t[i];return c*("asc"===u||u===!0?1:-1)}}return r.index-e.index}function c(n){return Un[n]}function u(n){return Vn[n]}function h(n,r,e){return r?n=qn[n]:e&&(n=Xn[n]),"\\"+n}function d(n){return"\\"+Xn[n]}function p(n,r,e){for(var t=n.length,i=r+(e?0:-1);e?i--:++i<t;){var a=n[i];if(a!==a)return i}return-1}function f(n){return!!n&&"object"==typeof n}function m(n){return 160>=n&&n>=9&&13>=n||32==n||160==n||5760==n||6158==n||n>=8192&&(8202>=n||8232==n||8233==n||8239==n||8287==n||12288==n||65279==n)}function g(n,r){for(var e=-1,t=n.length,i=-1,a=[];++e<t;)n[e]===r&&(n[e]=N,a[++i]=e);return a}function v(n,r){for(var e,t=-1,i=n.length,a=-1,o=[];++t<i;){var s=n[t],l=r?r(s,t,n):s;t&&e===l||(e=l,o[++a]=s)}return o}function y(n){for(var r=-1,e=n.length;++r<e&&m(n.charCodeAt(r)););return r}function E(n){for(var r=n.length;r--&&m(n.charCodeAt(r)););return r}function b(n){return Gn[n]}function x(m){function Y(n){if(f(n)&&!Ms(n)&&!(n instanceof Un)){if(n instanceof nn)return n;if(no.call(n,"__chain__")&&no.call(n,"__wrapped__"))return pt(n)}return new nn(n)}function J(){}function nn(n,r,e){this.__wrapped__=n,this.__actions__=e||[],this.__chain__=!!r}function Un(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Ao,this.__views__=[]}function Vn(){var n=new Un(this.__wrapped__);return n.__actions__=tr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=tr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=tr(this.__views__),n}function Gn(){if(this.__filtered__){var n=new Un(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Wn(){var n=this.__wrapped__.value(),r=this.__dir__,e=Ms(n),t=0>r,i=e?n.length:0,a=qe(0,i,this.__views__),o=a.start,s=a.end,l=s-o,c=t?s:o-1,u=this.__iteratees__,h=u.length,d=0,p=_o(l,this.__takeCount__);if(!e||D>i||i==l&&p==l)return te(n,this.__actions__);var f=[];n:for(;l--&&p>d;){c+=r;for(var m=-1,g=n[c];++m<h;){var v=u[m],y=v.iteratee,E=v.type,b=y(g);if(E==z)g=b;else if(!b){if(E==I)continue n;break n}}f[d++]=g}return f}function qn(){this.__data__={}}function Xn(n){return this.has(n)&&delete this.__data__[n]}function Yn(n){return"__proto__"==n?T:this.__data__[n]}function Kn(n){return"__proto__"!=n&&no.call(this.__data__,n)}function Zn(n,r){return"__proto__"!=n&&(this.__data__[n]=r),this}function Qn(n){var r=n?n.length:0;for(this.data={hash:vo(null),set:new uo};r--;)this.push(n[r])}function Jn(n,r){var e=n.data,t="string"==typeof r||Li(r)?e.set.has(r):e.hash[r];return t?0:-1}function $n(n){var r=this.data;"string"==typeof n||Li(n)?r.set.add(n):r.hash[n]=!0}function er(n,r){for(var e=-1,t=n.length,i=-1,a=r.length,o=Ba(t+a);++e<t;)o[e]=n[e];for(;++i<a;)o[e++]=r[i];return o}function tr(n,r){var e=-1,t=n.length;for(r||(r=Ba(t));++e<t;)r[e]=n[e];return r}function ir(n,r){for(var e=-1,t=n.length;++e<t&&r(n[e],e,n)!==!1;);return n}function ar(n,r){for(var e=n.length;e--&&r(n[e],e,n)!==!1;);return n}function or(n,r){for(var e=-1,t=n.length;++e<t;)if(!r(n[e],e,n))return!1;return!0}function sr(n,r,e,t){for(var i=-1,a=n.length,o=t,s=o;++i<a;){var l=n[i],c=+r(l);e(c,o)&&(o=c,s=l)}return s}function lr(n,r){for(var e=-1,t=n.length,i=-1,a=[];++e<t;){var o=n[e];r(o,e,n)&&(a[++i]=o)}return a}function cr(n,r){for(var e=-1,t=n.length,i=Ba(t);++e<t;)i[e]=r(n[e],e,n);return i}function ur(n,r){for(var e=-1,t=r.length,i=n.length;++e<t;)n[i+e]=r[e];return n}function hr(n,r,e,t){var i=-1,a=n.length;for(t&&a&&(e=n[++i]);++i<a;)e=r(e,n[i],i,n);return e}function dr(n,r,e,t){var i=n.length;for(t&&i&&(e=n[--i]);i--;)e=r(e,n[i],i,n);return e}function pr(n,r){for(var e=-1,t=n.length;++e<t;)if(r(n[e],e,n))return!0;return!1}function fr(n,r){for(var e=n.length,t=0;e--;)t+=+r(n[e])||0;return t}function mr(n,r){return n===T?r:n}function gr(n,r,e,t){return n!==T&&no.call(t,e)?n:r}function vr(n,r,e){for(var t=-1,i=Bs(r),a=i.length;++t<a;){var o=i[t],s=n[o],l=e(s,r[o],o,n,r);(l===l?l===s:s!==s)&&(s!==T||o in n)||(n[o]=l)}return n}function yr(n,r){return null==r?n:br(r,Bs(r),n)}function Er(n,r){for(var e=-1,t=null==n,i=!t&&Qe(n),a=i?n.length:0,o=r.length,s=Ba(o);++e<o;){var l=r[e];i?s[e]=Je(l,a)?n[l]:T:s[e]=t?T:n[l]}return s}function br(n,r,e){e||(e={});for(var t=-1,i=r.length;++t<i;){var a=r[t];e[a]=n[a]}return e}function xr(n,r,e){var t=typeof n;return"function"==t?r===T?n:oe(n,r,e):null==n?Sa:"object"==t?Br(n):r===T?Pa(n):Nr(n,r)}function Tr(n,r,e,t,i,a,o){var s;if(e&&(s=i?e(n,t,i):e(n)),s!==T)return s;if(!Li(n))return n;var l=Ms(n);if(l){if(s=Xe(n),!r)return tr(n,s)}else{var c=eo.call(n),u=c==X;if(c!=Z&&c!=U&&(!u||i))return Nn[c]?Ke(n,c,r):i?n:{};if(s=Ye(u?{}:n),!r)return yr(s,n)}a||(a=[]),o||(o=[]);for(var h=a.length;h--;)if(a[h]==n)return o[h];return a.push(n),o.push(s),(l?ir:jr)(n,function(t,i){s[i]=Tr(t,r,e,i,n,a,o)}),s}function _r(n,r,e){if("function"!=typeof n)throw new Ka(B);return ho(function(){n.apply(T,e)},r)}function wr(n,r){var t=n?n.length:0,i=[];if(!t)return i;var a=-1,o=Ve(),s=o===e,l=s&&r.length>=D?me(r):null,c=r.length;l&&(o=Jn,s=!1,r=l);n:for(;++a<t;){var u=n[a];if(s&&u===u){for(var h=c;h--;)if(r[h]===u)continue n;i.push(u)}else o(r,u,0)<0&&i.push(u)}return i}function Rr(n,r){var e=!0;return Oo(n,function(n,t,i){return e=!!r(n,t,i)}),e}function Hr(n,r,e,t){var i=t,a=i;return Oo(n,function(n,o,s){var l=+r(n,o,s);(e(l,i)||l===t&&l===a)&&(i=l,a=n)}),a}function Sr(n,r,e,t){var i=n.length;for(e=null==e?0:+e||0,0>e&&(e=-e>i?0:i+e),t=t===T||t>i?i:+t||0,0>t&&(t+=i),i=e>t?0:t>>>0,e>>>=0;i>e;)n[e++]=r;return n}function Ar(n,r){var e=[];return Oo(n,function(n,t,i){r(n,t,i)&&e.push(n)}),e}function Mr(n,r,e,t){var i;return e(n,function(n,e,a){return r(n,e,a)?(i=t?e:n,!1):void 0}),i}function Cr(n,r,e,t){t||(t=[]);for(var i=-1,a=n.length;++i<a;){var o=n[i];f(o)&&Qe(o)&&(e||Ms(o)||Ri(o))?r?Cr(o,r,e,t):ur(t,o):e||(t[t.length]=o)}return t}function kr(n,r){return Io(n,r,na)}function jr(n,r){return Io(n,r,Bs)}function Pr(n,r){return zo(n,r,Bs)}function Lr(n,r){for(var e=-1,t=r.length,i=-1,a=[];++e<t;){var o=r[e];Pi(n[o])&&(a[++i]=o)}return a}function Fr(n,r,e){if(null!=n){e!==T&&e in ht(n)&&(r=[e]);for(var t=0,i=r.length;null!=n&&i>t;)n=n[r[t++]];return t&&t==i?n:T}}function Or(n,r,e,t,i,a){return n===r?!0:null==n||null==r||!Li(n)&&!f(r)?n!==n&&r!==r:Dr(n,r,Or,e,t,i,a)}function Dr(n,r,e,t,i,a,o){var s=Ms(n),l=Ms(r),c=V,u=V;s||(c=eo.call(n),c==U?c=Z:c!=Z&&(s=Vi(n))),l||(u=eo.call(r),u==U?u=Z:u!=Z&&(l=Vi(r)));var h=c==Z,d=u==Z,p=c==u;if(p&&!s&&!h)return ze(n,r,c);if(!i){var f=h&&no.call(n,"__wrapped__"),m=d&&no.call(r,"__wrapped__");if(f||m)return e(f?n.value():n,m?r.value():r,t,i,a,o)}if(!p)return!1;a||(a=[]),o||(o=[]);for(var g=a.length;g--;)if(a[g]==n)return o[g]==r;a.push(n),o.push(r);var v=(s?Ie:Be)(n,r,e,t,i,a,o);return a.pop(),o.pop(),v}function Ir(n,r,e){var t=r.length,i=t,a=!e;if(null==n)return!i;for(n=ht(n);t--;){var o=r[t];if(a&&o[2]?o[1]!==n[o[0]]:!(o[0]in n))return!1}for(;++t<i;){o=r[t];var s=o[0],l=n[s],c=o[1];if(a&&o[2]){if(l===T&&!(s in n))return!1}else{var u=e?e(l,c,s):T;if(!(u===T?Or(c,l,e,!0):u))return!1}}return!0}function zr(n,r){var e=-1,t=Qe(n)?Ba(n.length):[];return Oo(n,function(n,i,a){t[++e]=r(n,i,a)}),t}function Br(n){var r=Ge(n);if(1==r.length&&r[0][2]){var e=r[0][0],t=r[0][1];return function(n){return null==n?!1:n[e]===t&&(t!==T||e in ht(n))}}return function(n){return Ir(n,r)}}function Nr(n,r){var e=Ms(n),t=nt(n)&&tt(r),i=n+"";return n=dt(n),function(a){if(null==a)return!1;var o=i;if(a=ht(a),(e||!t)&&!(o in a)){if(a=1==n.length?a:Fr(a,Kr(n,0,-1)),null==a)return!1;o=Ht(n),a=ht(a)}return a[o]===r?r!==T||o in a:Or(r,a[o],T,!0)}}function Ur(n,r,e,t,i){if(!Li(n))return n;var a=Qe(r)&&(Ms(r)||Vi(r)),o=a?T:Bs(r);return ir(o||r,function(s,l){if(o&&(l=s,s=r[l]),f(s))t||(t=[]),i||(i=[]),Vr(n,r,l,Ur,e,t,i);else{var c=n[l],u=e?e(c,s,l,n,r):T,h=u===T;h&&(u=s),u===T&&(!a||l in n)||!h&&(u===u?u===c:c!==c)||(n[l]=u)}}),n}function Vr(n,r,e,t,i,a,o){for(var s=a.length,l=r[e];s--;)if(a[s]==l)return void(n[e]=o[s]);var c=n[e],u=i?i(c,l,e,n,r):T,h=u===T;h&&(u=l,Qe(l)&&(Ms(l)||Vi(l))?u=Ms(c)?c:Qe(c)?tr(c):[]:Bi(l)||Ri(l)?u=Ri(c)?Yi(c):Bi(c)?c:{}:h=!1),a.push(l),o.push(u),h?n[e]=t(u,l,i,a,o):(u===u?u!==c:c===c)&&(n[e]=u)}function Gr(n){return function(r){return null==r?T:r[n]}}function Wr(n){var r=n+"";return n=dt(n),function(e){return Fr(e,n,r)}}function qr(n,r){for(var e=n?r.length:0;e--;){var t=r[e];if(t!=i&&Je(t)){var i=t;po.call(n,t,1)}}return n}function Xr(n,r){return n+yo(Ho()*(r-n+1))}function Yr(n,r,e,t,i){return i(n,function(n,i,a){e=t?(t=!1,n):r(e,n,i,a)}),e}function Kr(n,r,e){var t=-1,i=n.length;r=null==r?0:+r||0,0>r&&(r=-r>i?0:i+r),e=e===T||e>i?i:+e||0,0>e&&(e+=i),i=r>e?0:e-r>>>0,r>>>=0;for(var a=Ba(i);++t<i;)a[t]=n[t+r];return a}function Zr(n,r){var e;return Oo(n,function(n,t,i){return e=r(n,t,i),!e}),!!e}function Qr(n,r){var e=n.length;for(n.sort(r);e--;)n[e]=n[e].value;return n}function Jr(n,r,e){var t=Ne(),i=-1;r=cr(r,function(n){return t(n)});var a=zr(n,function(n){var e=cr(r,function(r){return r(n)});return{criteria:e,index:++i,value:n}});return Qr(a,function(n,r){return l(n,r,e)})}function $r(n,r){var e=0;return Oo(n,function(n,t,i){e+=+r(n,t,i)||0}),e}function ne(n,r){var t=-1,i=Ve(),a=n.length,o=i===e,s=o&&a>=D,l=s?me():null,c=[];l?(i=Jn,o=!1):(s=!1,l=r?[]:c);n:for(;++t<a;){var u=n[t],h=r?r(u,t,n):u;if(o&&u===u){for(var d=l.length;d--;)if(l[d]===h)continue n;r&&l.push(h),c.push(u)}else i(l,h,0)<0&&((r||s)&&l.push(h),c.push(u))}return c}function re(n,r){for(var e=-1,t=r.length,i=Ba(t);++e<t;)i[e]=n[r[e]];return i}function ee(n,r,e,t){for(var i=n.length,a=t?i:-1;(t?a--:++a<i)&&r(n[a],a,n););return e?Kr(n,t?0:a,t?a+1:i):Kr(n,t?a+1:0,t?i:a)}function te(n,r){var e=n;e instanceof Un&&(e=e.value());for(var t=-1,i=r.length;++t<i;){var a=r[t];e=a.func.apply(a.thisArg,ur([e],a.args))}return e}function ie(n,r,e){var t=0,i=n?n.length:t;if("number"==typeof r&&r===r&&ko>=i){for(;i>t;){var a=t+i>>>1,o=n[a];(e?r>=o:r>o)&&null!==o?t=a+1:i=a}return i}return ae(n,r,Sa,e)}function ae(n,r,e,t){r=e(r);for(var i=0,a=n?n.length:0,o=r!==r,s=null===r,l=r===T;a>i;){var c=yo((i+a)/2),u=e(n[c]),h=u!==T,d=u===u;if(o)var p=d||t;else p=s?d&&h&&(t||null!=u):l?d&&(t||h):null==u?!1:t?r>=u:r>u;p?i=c+1:a=c}return _o(a,Co)}function oe(n,r,e){if("function"!=typeof n)return Sa;if(r===T)return n;switch(e){case 1:return function(e){return n.call(r,e)};case 3:return function(e,t,i){return n.call(r,e,t,i)};case 4:return function(e,t,i,a){return n.call(r,e,t,i,a)};case 5:return function(e,t,i,a,o){return n.call(r,e,t,i,a,o)}}return function(){return n.apply(r,arguments)}}function se(n){var r=new ao(n.byteLength),e=new fo(r);return e.set(new fo(n)),r}function le(n,r,e){for(var t=e.length,i=-1,a=To(n.length-t,0),o=-1,s=r.length,l=Ba(s+a);++o<s;)l[o]=r[o];for(;++i<t;)l[e[i]]=n[i];for(;a--;)l[o++]=n[i++];return l}function ce(n,r,e){for(var t=-1,i=e.length,a=-1,o=To(n.length-i,0),s=-1,l=r.length,c=Ba(o+l);++a<o;)c[a]=n[a];for(var u=a;++s<l;)c[u+s]=r[s];
for(;++t<i;)c[u+e[t]]=n[a++];return c}function ue(n,r){return function(e,t,i){var a=r?r():{};if(t=Ne(t,i,3),Ms(e))for(var o=-1,s=e.length;++o<s;){var l=e[o];n(a,l,t(l,o,e),e)}else Oo(e,function(r,e,i){n(a,r,t(r,e,i),i)});return a}}function he(n){return vi(function(r,e){var t=-1,i=null==r?0:e.length,a=i>2?e[i-2]:T,o=i>2?e[2]:T,s=i>1?e[i-1]:T;for("function"==typeof a?(a=oe(a,s,5),i-=2):(a="function"==typeof s?s:T,i-=a?1:0),o&&$e(e[0],e[1],o)&&(a=3>i?T:a,i=1);++t<i;){var l=e[t];l&&n(r,l,a)}return r})}function de(n,r){return function(e,t){var i=e?Uo(e):0;if(!et(i))return n(e,t);for(var a=r?i:-1,o=ht(e);(r?a--:++a<i)&&t(o[a],a,o)!==!1;);return e}}function pe(n){return function(r,e,t){for(var i=ht(r),a=t(r),o=a.length,s=n?o:-1;n?s--:++s<o;){var l=a[s];if(e(i[l],l,i)===!1)break}return r}}function fe(n,r){function e(){var i=this&&this!==nr&&this instanceof e?t:n;return i.apply(r,arguments)}var t=ve(n);return e}function me(n){return vo&&uo?new Qn(n):null}function ge(n){return function(r){for(var e=-1,t=wa(ua(r)),i=t.length,a="";++e<i;)a=n(a,t[e],e);return a}}function ve(n){return function(){var r=arguments;switch(r.length){case 0:return new n;case 1:return new n(r[0]);case 2:return new n(r[0],r[1]);case 3:return new n(r[0],r[1],r[2]);case 4:return new n(r[0],r[1],r[2],r[3]);case 5:return new n(r[0],r[1],r[2],r[3],r[4]);case 6:return new n(r[0],r[1],r[2],r[3],r[4],r[5]);case 7:return new n(r[0],r[1],r[2],r[3],r[4],r[5],r[6])}var e=Fo(n.prototype),t=n.apply(e,r);return Li(t)?t:e}}function ye(n){function r(e,t,i){i&&$e(e,t,i)&&(t=T);var a=De(e,n,T,T,T,T,T,t);return a.placeholder=r.placeholder,a}return r}function Ee(n,r){return vi(function(e){var t=e[0];return null==t?t:(e.push(r),n.apply(T,e))})}function be(n,r){return function(e,t,i){if(i&&$e(e,t,i)&&(t=T),t=Ne(t,i,3),1==t.length){e=Ms(e)?e:ut(e);var a=sr(e,t,n,r);if(!e.length||a!==r)return a}return Hr(e,t,n,r)}}function xe(n,e){return function(t,i,a){if(i=Ne(i,a,3),Ms(t)){var o=r(t,i,e);return o>-1?t[o]:T}return Mr(t,i,n)}}function Te(n){return function(e,t,i){return e&&e.length?(t=Ne(t,i,3),r(e,t,n)):-1}}function _e(n){return function(r,e,t){return e=Ne(e,t,3),Mr(r,e,n,!0)}}function we(n){return function(){for(var r,e=arguments.length,t=n?e:-1,i=0,a=Ba(e);n?t--:++t<e;){var o=a[i++]=arguments[t];if("function"!=typeof o)throw new Ka(B);!r&&nn.prototype.thru&&"wrapper"==Ue(o)&&(r=new nn([],!0))}for(t=r?-1:e;++t<e;){o=a[t];var s=Ue(o),l="wrapper"==s?No(o):T;r=l&&rt(l[0])&&l[1]==(k|S|M|j)&&!l[4].length&&1==l[9]?r[Ue(l[0])].apply(r,l[3]):1==o.length&&rt(o)?r[s]():r.thru(o)}return function(){var n=arguments,t=n[0];if(r&&1==n.length&&Ms(t)&&t.length>=D)return r.plant(t).value();for(var i=0,o=e?a[i].apply(this,n):t;++i<e;)o=a[i].call(this,o);return o}}}function Re(n,r){return function(e,t,i){return"function"==typeof t&&i===T&&Ms(e)?n(e,t):r(e,oe(t,i,3))}}function He(n){return function(r,e,t){return("function"!=typeof e||t!==T)&&(e=oe(e,t,3)),n(r,e,na)}}function Se(n){return function(r,e,t){return("function"!=typeof e||t!==T)&&(e=oe(e,t,3)),n(r,e)}}function Ae(n){return function(r,e,t){var i={};return e=Ne(e,t,3),jr(r,function(r,t,a){var o=e(r,t,a);t=n?o:t,r=n?r:o,i[t]=r}),i}}function Me(n){return function(r,e,t){return r=i(r),(n?r:"")+Pe(r,e,t)+(n?"":r)}}function Ce(n){var r=vi(function(e,t){var i=g(t,r.placeholder);return De(e,n,T,t,i)});return r}function ke(n,r){return function(e,t,i,a){var o=arguments.length<3;return"function"==typeof t&&a===T&&Ms(e)?n(e,t,i,o):Yr(e,Ne(t,a,4),i,o,r)}}function je(n,r,e,t,i,a,o,s,l,c){function u(){for(var E=arguments.length,b=E,x=Ba(E);b--;)x[b]=arguments[b];if(t&&(x=le(x,t,i)),a&&(x=ce(x,a,o)),f||v){var _=u.placeholder,H=g(x,_);if(E-=H.length,c>E){var S=s?tr(s):T,A=To(c-E,0),k=f?H:T,j=f?T:H,P=f?x:T,L=f?T:x;r|=f?M:C,r&=~(f?C:M),m||(r&=~(w|R));var F=[n,r,e,P,k,L,j,S,l,A],O=je.apply(T,F);return rt(n)&&Vo(O,F),O.placeholder=_,O}}var D=d?e:this,I=p?D[n]:n;return s&&(x=lt(x,s)),h&&l<x.length&&(x.length=l),this&&this!==nr&&this instanceof u&&(I=y||ve(n)),I.apply(D,x)}var h=r&k,d=r&w,p=r&R,f=r&S,m=r&H,v=r&A,y=p?T:ve(n);return u}function Pe(n,r,e){var t=n.length;if(r=+r,t>=r||!bo(r))return"";var i=r-t;return e=null==e?" ":e+"",ga(e,go(i/e.length)).slice(0,i)}function Le(n,r,e,t){function i(){for(var r=-1,s=arguments.length,l=-1,c=t.length,u=Ba(c+s);++l<c;)u[l]=t[l];for(;s--;)u[l++]=arguments[++r];var h=this&&this!==nr&&this instanceof i?o:n;return h.apply(a?e:this,u)}var a=r&w,o=ve(n);return i}function Fe(n){var r=Ga[n];return function(n,e){return e=e===T?0:+e||0,e?(e=lo(10,e),r(n*e)/e):r(n)}}function Oe(n){return function(r,e,t,i){var a=Ne(t);return null==t&&a===xr?ie(r,e,n):ae(r,e,a(t,i,1),n)}}function De(n,r,e,t,i,a,o,s){var l=r&R;if(!l&&"function"!=typeof n)throw new Ka(B);var c=t?t.length:0;if(c||(r&=~(M|C),t=i=T),c-=i?i.length:0,r&C){var u=t,h=i;t=i=T}var d=l?T:No(n),p=[n,r,e,t,i,u,h,a,o,s];if(d&&(it(p,d),r=p[1],s=p[9]),p[9]=null==s?l?0:n.length:To(s-c,0)||0,r==w)var f=fe(p[0],p[2]);else f=r!=M&&r!=(w|M)||p[4].length?je.apply(T,p):Le.apply(T,p);var m=d?Bo:Vo;return m(f,p)}function Ie(n,r,e,t,i,a,o){var s=-1,l=n.length,c=r.length;if(l!=c&&!(i&&c>l))return!1;for(;++s<l;){var u=n[s],h=r[s],d=t?t(i?h:u,i?u:h,s):T;if(d!==T){if(d)continue;return!1}if(i){if(!pr(r,function(n){return u===n||e(u,n,t,i,a,o)}))return!1}else if(u!==h&&!e(u,h,t,i,a,o))return!1}return!0}function ze(n,r,e){switch(e){case G:case W:return+n==+r;case q:return n.name==r.name&&n.message==r.message;case K:return n!=+n?r!=+r:n==+r;case Q:case $:return n==r+""}return!1}function Be(n,r,e,t,i,a,o){var s=Bs(n),l=s.length,c=Bs(r),u=c.length;if(l!=u&&!i)return!1;for(var h=l;h--;){var d=s[h];if(!(i?d in r:no.call(r,d)))return!1}for(var p=i;++h<l;){d=s[h];var f=n[d],m=r[d],g=t?t(i?m:f,i?f:m,d):T;if(!(g===T?e(f,m,t,i,a,o):g))return!1;p||(p="constructor"==d)}if(!p){var v=n.constructor,y=r.constructor;if(v!=y&&"constructor"in n&&"constructor"in r&&!("function"==typeof v&&v instanceof v&&"function"==typeof y&&y instanceof y))return!1}return!0}function Ne(n,r,e){var t=Y.callback||Ra;return t=t===Ra?xr:t,e?t(n,r,e):t}function Ue(n){for(var r=n.name+"",e=Lo[r],t=e?e.length:0;t--;){var i=e[t],a=i.func;if(null==a||a==n)return i.name}return r}function Ve(n,r,t){var i=Y.indexOf||wt;return i=i===wt?e:i,n?i(n,r,t):i}function Ge(n){for(var r=ra(n),e=r.length;e--;)r[e][2]=tt(r[e][1]);return r}function We(n,r){var e=null==n?T:n[r];return Di(e)?e:T}function qe(n,r,e){for(var t=-1,i=e.length;++t<i;){var a=e[t],o=a.size;switch(a.type){case"drop":n+=o;break;case"dropRight":r-=o;break;case"take":r=_o(r,n+o);break;case"takeRight":n=To(n,r-o)}}return{start:n,end:r}}function Xe(n){var r=n.length,e=new n.constructor(r);return r&&"string"==typeof n[0]&&no.call(n,"index")&&(e.index=n.index,e.input=n.input),e}function Ye(n){var r=n.constructor;return"function"==typeof r&&r instanceof r||(r=qa),new r}function Ke(n,r,e){var t=n.constructor;switch(r){case rn:return se(n);case G:case W:return new t(+n);case en:case tn:case an:case on:case sn:case ln:case cn:case un:case hn:var i=n.buffer;return new t(e?se(i):i,n.byteOffset,n.length);case K:case $:return new t(n);case Q:var a=new t(n.source,Cn.exec(n));a.lastIndex=n.lastIndex}return a}function Ze(n,r,e){null==n||nt(r,n)||(r=dt(r),n=1==r.length?n:Fr(n,Kr(r,0,-1)),r=Ht(r));var t=null==n?n:n[r];return null==t?T:t.apply(n,e)}function Qe(n){return null!=n&&et(Uo(n))}function Je(n,r){return n="number"==typeof n||Pn.test(n)?+n:-1,r=null==r?jo:r,n>-1&&n%1==0&&r>n}function $e(n,r,e){if(!Li(e))return!1;var t=typeof r;if("number"==t?Qe(e)&&Je(r,e.length):"string"==t&&r in e){var i=e[r];return n===n?n===i:i!==i}return!1}function nt(n,r){var e=typeof n;if("string"==e&&_n.test(n)||"number"==e)return!0;if(Ms(n))return!1;var t=!Tn.test(n);return t||null!=r&&n in ht(r)}function rt(n){var r=Ue(n),e=Y[r];if("function"!=typeof e||!(r in Un.prototype))return!1;if(n===e)return!0;var t=No(e);return!!t&&n===t[0]}function et(n){return"number"==typeof n&&n>-1&&n%1==0&&jo>=n}function tt(n){return n===n&&!Li(n)}function it(n,r){var e=n[1],t=r[1],i=e|t,a=k>i,o=t==k&&e==S||t==k&&e==j&&n[7].length<=r[8]||t==(k|j)&&e==S;if(!a&&!o)return n;t&w&&(n[2]=r[2],i|=e&w?0:H);var s=r[3];if(s){var l=n[3];n[3]=l?le(l,s,r[4]):tr(s),n[4]=l?g(n[3],N):tr(r[4])}return s=r[5],s&&(l=n[5],n[5]=l?ce(l,s,r[6]):tr(s),n[6]=l?g(n[5],N):tr(r[6])),s=r[7],s&&(n[7]=tr(s)),t&k&&(n[8]=null==n[8]?r[8]:_o(n[8],r[8])),null==n[9]&&(n[9]=r[9]),n[0]=r[0],n[1]=i,n}function at(n,r){return n===T?r:Cs(n,r,at)}function ot(n,r){n=ht(n);for(var e=-1,t=r.length,i={};++e<t;){var a=r[e];a in n&&(i[a]=n[a])}return i}function st(n,r){var e={};return kr(n,function(n,t,i){r(n,t,i)&&(e[t]=n)}),e}function lt(n,r){for(var e=n.length,t=_o(r.length,e),i=tr(n);t--;){var a=r[t];n[t]=Je(a,e)?i[a]:T}return n}function ct(n){for(var r=na(n),e=r.length,t=e&&n.length,i=!!t&&et(t)&&(Ms(n)||Ri(n)),a=-1,o=[];++a<e;){var s=r[a];(i&&Je(s,t)||no.call(n,s))&&o.push(s)}return o}function ut(n){return null==n?[]:Qe(n)?Li(n)?n:qa(n):aa(n)}function ht(n){return Li(n)?n:qa(n)}function dt(n){if(Ms(n))return n;var r=[];return i(n).replace(wn,function(n,e,t,i){r.push(t?i.replace(An,"$1"):e||n)}),r}function pt(n){return n instanceof Un?n.clone():new nn(n.__wrapped__,n.__chain__,tr(n.__actions__))}function ft(n,r,e){r=(e?$e(n,r,e):null==r)?1:To(yo(r)||1,1);for(var t=0,i=n?n.length:0,a=-1,o=Ba(go(i/r));i>t;)o[++a]=Kr(n,t,t+=r);return o}function mt(n){for(var r=-1,e=n?n.length:0,t=-1,i=[];++r<e;){var a=n[r];a&&(i[++t]=a)}return i}function gt(n,r,e){var t=n?n.length:0;return t?((e?$e(n,r,e):null==r)&&(r=1),Kr(n,0>r?0:r)):[]}function vt(n,r,e){var t=n?n.length:0;return t?((e?$e(n,r,e):null==r)&&(r=1),r=t-(+r||0),Kr(n,0,0>r?0:r)):[]}function yt(n,r,e){return n&&n.length?ee(n,Ne(r,e,3),!0,!0):[]}function Et(n,r,e){return n&&n.length?ee(n,Ne(r,e,3),!0):[]}function bt(n,r,e,t){var i=n?n.length:0;return i?(e&&"number"!=typeof e&&$e(n,r,e)&&(e=0,t=i),Sr(n,r,e,t)):[]}function xt(n){return n?n[0]:T}function Tt(n,r,e){var t=n?n.length:0;return e&&$e(n,r,e)&&(r=!1),t?Cr(n,r):[]}function _t(n){var r=n?n.length:0;return r?Cr(n,!0):[]}function wt(n,r,t){var i=n?n.length:0;if(!i)return-1;if("number"==typeof t)t=0>t?To(i+t,0):t;else if(t){var a=ie(n,r);return i>a&&(r===r?r===n[a]:n[a]!==n[a])?a:-1}return e(n,r,t||0)}function Rt(n){return vt(n,1)}function Ht(n){var r=n?n.length:0;return r?n[r-1]:T}function St(n,r,e){var t=n?n.length:0;if(!t)return-1;var i=t;if("number"==typeof e)i=(0>e?To(t+e,0):_o(e||0,t-1))+1;else if(e){i=ie(n,r,!0)-1;var a=n[i];return(r===r?r===a:a!==a)?i:-1}if(r!==r)return p(n,i,!0);for(;i--;)if(n[i]===r)return i;return-1}function At(){var n=arguments,r=n[0];if(!r||!r.length)return r;for(var e=0,t=Ve(),i=n.length;++e<i;)for(var a=0,o=n[e];(a=t(r,o,a))>-1;)po.call(r,a,1);return r}function Mt(n,r,e){var t=[];if(!n||!n.length)return t;var i=-1,a=[],o=n.length;for(r=Ne(r,e,3);++i<o;){var s=n[i];r(s,i,n)&&(t.push(s),a.push(i))}return qr(n,a),t}function Ct(n){return gt(n,1)}function kt(n,r,e){var t=n?n.length:0;return t?(e&&"number"!=typeof e&&$e(n,r,e)&&(r=0,e=t),Kr(n,r,e)):[]}function jt(n,r,e){var t=n?n.length:0;return t?((e?$e(n,r,e):null==r)&&(r=1),Kr(n,0,0>r?0:r)):[]}function Pt(n,r,e){var t=n?n.length:0;return t?((e?$e(n,r,e):null==r)&&(r=1),r=t-(+r||0),Kr(n,0>r?0:r)):[]}function Lt(n,r,e){return n&&n.length?ee(n,Ne(r,e,3),!1,!0):[]}function Ft(n,r,e){return n&&n.length?ee(n,Ne(r,e,3)):[]}function Ot(n,r,t,i){var a=n?n.length:0;if(!a)return[];null!=r&&"boolean"!=typeof r&&(i=t,t=$e(n,r,i)?T:r,r=!1);var o=Ne();return(null!=t||o!==xr)&&(t=o(t,i,3)),r&&Ve()===e?v(n,t):ne(n,t)}function Dt(n){if(!n||!n.length)return[];var r=-1,e=0;n=lr(n,function(n){return Qe(n)?(e=To(n.length,e),!0):void 0});for(var t=Ba(e);++r<e;)t[r]=cr(n,Gr(r));return t}function It(n,r,e){var t=n?n.length:0;if(!t)return[];var i=Dt(n);return null==r?i:(r=oe(r,e,4),cr(i,function(n){return hr(n,r,T,!0)}))}function zt(){for(var n=-1,r=arguments.length;++n<r;){var e=arguments[n];if(Qe(e))var t=t?ur(wr(t,e),wr(e,t)):e}return t?ne(t):[]}function Bt(n,r){var e=-1,t=n?n.length:0,i={};for(!t||r||Ms(n[0])||(r=[]);++e<t;){var a=n[e];r?i[a]=r[e]:a&&(i[a[0]]=a[1])}return i}function Nt(n){var r=Y(n);return r.__chain__=!0,r}function Ut(n,r,e){return r.call(e,n),n}function Vt(n,r,e){return r.call(e,n)}function Gt(){return Nt(this)}function Wt(){return new nn(this.value(),this.__chain__)}function qt(n){for(var r,e=this;e instanceof J;){var t=pt(e);r?i.__wrapped__=t:r=t;var i=t;e=e.__wrapped__}return i.__wrapped__=n,r}function Xt(){var n=this.__wrapped__,r=function(n){return n.reverse()};if(n instanceof Un){var e=n;return this.__actions__.length&&(e=new Un(this)),e=e.reverse(),e.__actions__.push({func:Vt,args:[r],thisArg:T}),new nn(e,this.__chain__)}return this.thru(r)}function Yt(){return this.value()+""}function Kt(){return te(this.__wrapped__,this.__actions__)}function Zt(n,r,e){var t=Ms(n)?or:Rr;return e&&$e(n,r,e)&&(r=T),("function"!=typeof r||e!==T)&&(r=Ne(r,e,3)),t(n,r)}function Qt(n,r,e){var t=Ms(n)?lr:Ar;return r=Ne(r,e,3),t(n,r)}function Jt(n,r){return is(n,Br(r))}function $t(n,r,e,t){var i=n?Uo(n):0;return et(i)||(n=aa(n),i=n.length),e="number"!=typeof e||t&&$e(r,e,t)?0:0>e?To(i+e,0):e||0,"string"==typeof n||!Ms(n)&&Ui(n)?i>=e&&n.indexOf(r,e)>-1:!!i&&Ve(n,r,e)>-1}function ni(n,r,e){var t=Ms(n)?cr:zr;return r=Ne(r,e,3),t(n,r)}function ri(n,r){return ni(n,Pa(r))}function ei(n,r,e){var t=Ms(n)?lr:Ar;return r=Ne(r,e,3),t(n,function(n,e,t){return!r(n,e,t)})}function ti(n,r,e){if(e?$e(n,r,e):null==r){n=ut(n);var t=n.length;return t>0?n[Xr(0,t-1)]:T}var i=-1,a=Xi(n),t=a.length,o=t-1;for(r=_o(0>r?0:+r||0,t);++i<r;){var s=Xr(i,o),l=a[s];a[s]=a[i],a[i]=l}return a.length=r,a}function ii(n){return ti(n,Ao)}function ai(n){var r=n?Uo(n):0;return et(r)?r:Bs(n).length}function oi(n,r,e){var t=Ms(n)?pr:Zr;return e&&$e(n,r,e)&&(r=T),("function"!=typeof r||e!==T)&&(r=Ne(r,e,3)),t(n,r)}function si(n,r,e){if(null==n)return[];e&&$e(n,r,e)&&(r=T);var t=-1;r=Ne(r,e,3);var i=zr(n,function(n,e,i){return{criteria:r(n,e,i),index:++t,value:n}});return Qr(i,s)}function li(n,r,e,t){return null==n?[]:(t&&$e(r,e,t)&&(e=T),Ms(r)||(r=null==r?[]:[r]),Ms(e)||(e=null==e?[]:[e]),Jr(n,r,e))}function ci(n,r){return Qt(n,Br(r))}function ui(n,r){if("function"!=typeof r){if("function"!=typeof n)throw new Ka(B);var e=n;n=r,r=e}return n=bo(n=+n)?n:0,function(){return--n<1?r.apply(this,arguments):void 0}}function hi(n,r,e){return e&&$e(n,r,e)&&(r=T),r=n&&null==r?n.length:To(+r||0,0),De(n,k,T,T,T,T,r)}function di(n,r){var e;if("function"!=typeof r){if("function"!=typeof n)throw new Ka(B);var t=n;n=r,r=t}return function(){return--n>0&&(e=r.apply(this,arguments)),1>=n&&(r=T),e}}function pi(n,r,e){function t(){p&&oo(p),c&&oo(c),m=0,c=p=f=T}function i(r,e){e&&oo(e),c=p=f=T,r&&(m=ms(),u=n.apply(d,l),p||c||(l=d=T))}function a(){var n=r-(ms()-h);0>=n||n>r?i(f,c):p=ho(a,n)}function o(){i(v,p)}function s(){if(l=arguments,h=ms(),d=this,f=v&&(p||!y),g===!1)var e=y&&!p;else{c||y||(m=h);var t=g-(h-m),i=0>=t||t>g;i?(c&&(c=oo(c)),m=h,u=n.apply(d,l)):c||(c=ho(o,t))}return i&&p?p=oo(p):p||r===g||(p=ho(a,r)),e&&(i=!0,u=n.apply(d,l)),!i||p||c||(l=d=T),u}var l,c,u,h,d,p,f,m=0,g=!1,v=!0;if("function"!=typeof n)throw new Ka(B);if(r=0>r?0:+r||0,e===!0){var y=!0;v=!1}else Li(e)&&(y=!!e.leading,g="maxWait"in e&&To(+e.maxWait||0,r),v="trailing"in e?!!e.trailing:v);return s.cancel=t,s}function fi(n,r){if("function"!=typeof n||r&&"function"!=typeof r)throw new Ka(B);var e=function(){var t=arguments,i=r?r.apply(this,t):t[0],a=e.cache;if(a.has(i))return a.get(i);var o=n.apply(this,t);return e.cache=a.set(i,o),o};return e.cache=new fi.Cache,e}function mi(n){if("function"!=typeof n)throw new Ka(B);return function(){return!n.apply(this,arguments)}}function gi(n){return di(2,n)}function vi(n,r){if("function"!=typeof n)throw new Ka(B);return r=To(r===T?n.length-1:+r||0,0),function(){for(var e=arguments,t=-1,i=To(e.length-r,0),a=Ba(i);++t<i;)a[t]=e[r+t];switch(r){case 0:return n.call(this,a);case 1:return n.call(this,e[0],a);case 2:return n.call(this,e[0],e[1],a)}var o=Ba(r+1);for(t=-1;++t<r;)o[t]=e[t];return o[r]=a,n.apply(this,o)}}function yi(n){if("function"!=typeof n)throw new Ka(B);return function(r){return n.apply(this,r)}}function Ei(n,r,e){var t=!0,i=!0;if("function"!=typeof n)throw new Ka(B);return e===!1?t=!1:Li(e)&&(t="leading"in e?!!e.leading:t,i="trailing"in e?!!e.trailing:i),pi(n,r,{leading:t,maxWait:+r,trailing:i})}function bi(n,r){return r=null==r?Sa:r,De(r,M,T,[n],[])}function xi(n,r,e,t){return r&&"boolean"!=typeof r&&$e(n,r,e)?r=!1:"function"==typeof r&&(t=e,e=r,r=!1),"function"==typeof e?Tr(n,r,oe(e,t,3)):Tr(n,r)}function Ti(n,r,e){return"function"==typeof r?Tr(n,!0,oe(r,e,3)):Tr(n,!0)}function _i(n,r){return n>r}function wi(n,r){return n>=r}function Ri(n){return f(n)&&Qe(n)&&no.call(n,"callee")&&!co.call(n,"callee")}function Hi(n){return n===!0||n===!1||f(n)&&eo.call(n)==G}function Si(n){return f(n)&&eo.call(n)==W}function Ai(n){return!!n&&1===n.nodeType&&f(n)&&!Bi(n)}function Mi(n){return null==n?!0:Qe(n)&&(Ms(n)||Ui(n)||Ri(n)||f(n)&&Pi(n.splice))?!n.length:!Bs(n).length}function Ci(n,r,e,t){e="function"==typeof e?oe(e,t,3):T;var i=e?e(n,r):T;return i===T?Or(n,r,e):!!i}function ki(n){return f(n)&&"string"==typeof n.message&&eo.call(n)==q}function ji(n){return"number"==typeof n&&bo(n)}function Pi(n){return Li(n)&&eo.call(n)==X}function Li(n){var r=typeof n;return!!n&&("object"==r||"function"==r)}function Fi(n,r,e,t){return e="function"==typeof e?oe(e,t,3):T,Ir(n,Ge(r),e)}function Oi(n){return zi(n)&&n!=+n}function Di(n){return null==n?!1:Pi(n)?io.test($a.call(n)):f(n)&&jn.test(n)}function Ii(n){return null===n}function zi(n){return"number"==typeof n||f(n)&&eo.call(n)==K}function Bi(n){var r;if(!f(n)||eo.call(n)!=Z||Ri(n)||!no.call(n,"constructor")&&(r=n.constructor,"function"==typeof r&&!(r instanceof r)))return!1;var e;return kr(n,function(n,r){e=r}),e===T||no.call(n,e)}function Ni(n){return Li(n)&&eo.call(n)==Q}function Ui(n){return"string"==typeof n||f(n)&&eo.call(n)==$}function Vi(n){return f(n)&&et(n.length)&&!!Bn[eo.call(n)]}function Gi(n){return n===T}function Wi(n,r){return r>n}function qi(n,r){return r>=n}function Xi(n){var r=n?Uo(n):0;return et(r)?r?tr(n):[]:aa(n)}function Yi(n){return br(n,na(n))}function Ki(n,r,e){var t=Fo(n);return e&&$e(n,r,e)&&(r=T),r?yr(t,r):t}function Zi(n){return Lr(n,na(n))}function Qi(n,r,e){var t=null==n?T:Fr(n,dt(r),r+"");return t===T?e:t}function Ji(n,r){if(null==n)return!1;var e=no.call(n,r);if(!e&&!nt(r)){if(r=dt(r),n=1==r.length?n:Fr(n,Kr(r,0,-1)),null==n)return!1;r=Ht(r),e=no.call(n,r)}return e||et(n.length)&&Je(r,n.length)&&(Ms(n)||Ri(n))}function $i(n,r,e){e&&$e(n,r,e)&&(r=T);for(var t=-1,i=Bs(n),a=i.length,o={};++t<a;){var s=i[t],l=n[s];r?no.call(o,l)?o[l].push(s):o[l]=[s]:o[l]=s}return o}function na(n){if(null==n)return[];Li(n)||(n=qa(n));var r=n.length;r=r&&et(r)&&(Ms(n)||Ri(n))&&r||0;for(var e=n.constructor,t=-1,i="function"==typeof e&&e.prototype===n,a=Ba(r),o=r>0;++t<r;)a[t]=t+"";for(var s in n)o&&Je(s,r)||"constructor"==s&&(i||!no.call(n,s))||a.push(s);return a}function ra(n){n=ht(n);for(var r=-1,e=Bs(n),t=e.length,i=Ba(t);++r<t;){var a=e[r];i[r]=[a,n[a]]}return i}function ea(n,r,e){var t=null==n?T:n[r];return t===T&&(null==n||nt(r,n)||(r=dt(r),n=1==r.length?n:Fr(n,Kr(r,0,-1)),t=null==n?T:n[Ht(r)]),t=t===T?e:t),Pi(t)?t.call(n):t}function ta(n,r,e){if(null==n)return n;var t=r+"";r=null!=n[t]||nt(r,n)?[t]:dt(r);for(var i=-1,a=r.length,o=a-1,s=n;null!=s&&++i<a;){var l=r[i];Li(s)&&(i==o?s[l]=e:null==s[l]&&(s[l]=Je(r[i+1])?[]:{})),s=s[l]}return n}function ia(n,r,e,t){var i=Ms(n)||Vi(n);if(r=Ne(r,t,4),null==e)if(i||Li(n)){var a=n.constructor;e=i?Ms(n)?new a:[]:Fo(Pi(a)?a.prototype:T)}else e={};return(i?ir:jr)(n,function(n,t,i){return r(e,n,t,i)}),e}function aa(n){return re(n,Bs(n))}function oa(n){return re(n,na(n))}function sa(n,r,e){return r=+r||0,e===T?(e=r,r=0):e=+e||0,n>=_o(r,e)&&n<To(r,e)}function la(n,r,e){e&&$e(n,r,e)&&(r=e=T);var t=null==n,i=null==r;if(null==e&&(i&&"boolean"==typeof n?(e=n,n=1):"boolean"==typeof r&&(e=r,i=!0)),t&&i&&(r=1,i=!1),n=+n||0,i?(r=n,n=0):r=+r||0,e||n%1||r%1){var a=Ho();return _o(n+a*(r-n+so("1e-"+((a+"").length-1))),r)}return Xr(n,r)}function ca(n){return n=i(n),n&&n.charAt(0).toUpperCase()+n.slice(1)}function ua(n){return n=i(n),n&&n.replace(Ln,c).replace(Sn,"")}function ha(n,r,e){n=i(n),r+="";var t=n.length;return e=e===T?t:_o(0>e?0:+e||0,t),e-=r.length,e>=0&&n.indexOf(r,e)==e}function da(n){return n=i(n),n&&yn.test(n)?n.replace(gn,u):n}function pa(n){return n=i(n),n&&Hn.test(n)?n.replace(Rn,h):n||"(?:)"}function fa(n,r,e){n=i(n),r=+r;var t=n.length;if(t>=r||!bo(r))return n;var a=(r-t)/2,o=yo(a),s=go(a);return e=Pe("",s,e),e.slice(0,o)+n+e}function ma(n,r,e){return(e?$e(n,r,e):null==r)?r=0:r&&(r=+r),n=Ea(n),Ro(n,r||(kn.test(n)?16:10))}function ga(n,r){var e="";if(n=i(n),r=+r,1>r||!n||!bo(r))return e;do r%2&&(e+=n),r=yo(r/2),n+=n;while(r);return e}function va(n,r,e){return n=i(n),e=null==e?0:_o(0>e?0:+e||0,n.length),n.lastIndexOf(r,e)==e}function ya(n,r,e){var t=Y.templateSettings;e&&$e(n,r,e)&&(r=e=T),n=i(n),r=vr(yr({},e||r),t,gr);var a,o,s=vr(yr({},r.imports),t.imports,gr),l=Bs(s),c=re(s,l),u=0,h=r.interpolate||Fn,p="__p += '",f=Xa((r.escape||Fn).source+"|"+h.source+"|"+(h===xn?Mn:Fn).source+"|"+(r.evaluate||Fn).source+"|$","g"),m="//# sourceURL="+("sourceURL"in r?r.sourceURL:"lodash.templateSources["+ ++zn+"]")+"\n";n.replace(f,function(r,e,t,i,s,l){return t||(t=i),p+=n.slice(u,l).replace(On,d),e&&(a=!0,p+="' +\n__e("+e+") +\n'"),s&&(o=!0,p+="';\n"+s+";\n__p += '"),t&&(p+="' +\n((__t = ("+t+")) == null ? '' : __t) +\n'"),u=l+r.length,r}),p+="';\n";var g=r.variable;g||(p="with (obj) {\n"+p+"\n}\n"),p=(o?p.replace(dn,""):p).replace(pn,"$1").replace(fn,"$1;"),p="function("+(g||"obj")+") {\n"+(g?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(a?", __e = _.escape":"")+(o?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+p+"return __p\n}";var v=Qs(function(){return Va(l,m+"return "+p).apply(T,c)});if(v.source=p,ki(v))throw v;return v}function Ea(n,r,e){var t=n;return(n=i(n))?(e?$e(t,r,e):null==r)?n.slice(y(n),E(n)+1):(r+="",n.slice(a(n,r),o(n,r)+1)):n}function ba(n,r,e){var t=n;return n=i(n),n?(e?$e(t,r,e):null==r)?n.slice(y(n)):n.slice(a(n,r+"")):n}function xa(n,r,e){var t=n;return n=i(n),n?(e?$e(t,r,e):null==r)?n.slice(0,E(n)+1):n.slice(0,o(n,r+"")+1):n}function Ta(n,r,e){e&&$e(n,r,e)&&(r=T);var t=P,a=L;if(null!=r)if(Li(r)){var o="separator"in r?r.separator:o;t="length"in r?+r.length||0:t,a="omission"in r?i(r.omission):a}else t=+r||0;if(n=i(n),t>=n.length)return n;var s=t-a.length;if(1>s)return a;var l=n.slice(0,s);if(null==o)return l+a;if(Ni(o)){if(n.slice(s).search(o)){var c,u,h=n.slice(0,s);for(o.global||(o=Xa(o.source,(Cn.exec(o)||"")+"g")),o.lastIndex=0;c=o.exec(h);)u=c.index;l=l.slice(0,null==u?s:u)}}else if(n.indexOf(o,s)!=s){var d=l.lastIndexOf(o);d>-1&&(l=l.slice(0,d))}return l+a}function _a(n){return n=i(n),n&&vn.test(n)?n.replace(mn,b):n}function wa(n,r,e){return e&&$e(n,r,e)&&(r=T),n=i(n),n.match(r||Dn)||[]}function Ra(n,r,e){return e&&$e(n,r,e)&&(r=T),f(n)?Aa(n):xr(n,r)}function Ha(n){return function(){return n}}function Sa(n){return n}function Aa(n){return Br(Tr(n,!0))}function Ma(n,r){return Nr(n,Tr(r,!0))}function Ca(n,r,e){if(null==e){var t=Li(r),i=t?Bs(r):T,a=i&&i.length?Lr(r,i):T;(a?a.length:t)||(a=!1,e=r,r=n,n=this)}a||(a=Lr(r,Bs(r)));var o=!0,s=-1,l=Pi(n),c=a.length;e===!1?o=!1:Li(e)&&"chain"in e&&(o=e.chain);for(;++s<c;){var u=a[s],h=r[u];n[u]=h,l&&(n.prototype[u]=function(r){return function(){var e=this.__chain__;if(o||e){var t=n(this.__wrapped__),i=t.__actions__=tr(this.__actions__);return i.push({func:r,args:arguments,thisArg:n}),t.__chain__=e,t}return r.apply(n,ur([this.value()],arguments))}}(h))}return n}function ka(){return nr._=to,this}function ja(){}function Pa(n){return nt(n)?Gr(n):Wr(n)}function La(n){return function(r){return Fr(n,dt(r),r+"")}}function Fa(n,r,e){e&&$e(n,r,e)&&(r=e=T),n=+n||0,e=null==e?1:+e||0,null==r?(r=n,n=0):r=+r||0;for(var t=-1,i=To(go((r-n)/(e||1)),0),a=Ba(i);++t<i;)a[t]=n,n+=e;return a}function Oa(n,r,e){if(n=yo(n),1>n||!bo(n))return[];var t=-1,i=Ba(_o(n,Mo));for(r=oe(r,e,1);++t<n;)Mo>t?i[t]=r(t):r(t);return i}function Da(n){var r=++ro;return i(n)+r}function Ia(n,r){return(+n||0)+(+r||0)}function za(n,r,e){return e&&$e(n,r,e)&&(r=T),r=Ne(r,e,3),1==r.length?fr(Ms(n)?n:ut(n),r):$r(n,r)}m=m?rr.defaults(nr.Object(),m,rr.pick(nr,In)):nr;var Ba=m.Array,Na=m.Date,Ua=m.Error,Va=m.Function,Ga=m.Math,Wa=m.Number,qa=m.Object,Xa=m.RegExp,Ya=m.String,Ka=m.TypeError,Za=Ba.prototype,Qa=qa.prototype,Ja=Ya.prototype,$a=Va.prototype.toString,no=Qa.hasOwnProperty,ro=0,eo=Qa.toString,to=nr._,io=Xa("^"+$a.call(no).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ao=m.ArrayBuffer,oo=m.clearTimeout,so=m.parseFloat,lo=Ga.pow,co=Qa.propertyIsEnumerable,uo=We(m,"Set"),ho=m.setTimeout,po=Za.splice,fo=m.Uint8Array,mo=We(m,"WeakMap"),go=Ga.ceil,vo=We(qa,"create"),yo=Ga.floor,Eo=We(Ba,"isArray"),bo=m.isFinite,xo=We(qa,"keys"),To=Ga.max,_o=Ga.min,wo=We(Na,"now"),Ro=m.parseInt,Ho=Ga.random,So=Wa.NEGATIVE_INFINITY,Ao=Wa.POSITIVE_INFINITY,Mo=4294967295,Co=Mo-1,ko=Mo>>>1,jo=9007199254740991,Po=mo&&new mo,Lo={};Y.support={};Y.templateSettings={escape:En,evaluate:bn,interpolate:xn,variable:"",imports:{_:Y}};var Fo=function(){function n(){}return function(r){if(Li(r)){n.prototype=r;var e=new n;n.prototype=T}return e||{}}}(),Oo=de(jr),Do=de(Pr,!0),Io=pe(),zo=pe(!0),Bo=Po?function(n,r){return Po.set(n,r),n}:Sa,No=Po?function(n){return Po.get(n)}:ja,Uo=Gr("length"),Vo=function(){var n=0,r=0;return function(e,t){var i=ms(),a=O-(i-r);if(r=i,a>0){if(++n>=F)return e}else n=0;return Bo(e,t)}}(),Go=vi(function(n,r){return f(n)&&Qe(n)?wr(n,Cr(r,!1,!0)):[]}),Wo=Te(),qo=Te(!0),Xo=vi(function(n){for(var r=n.length,t=r,i=Ba(h),a=Ve(),o=a===e,s=[];t--;){var l=n[t]=Qe(l=n[t])?l:[];i[t]=o&&l.length>=120?me(t&&l):null}var c=n[0],u=-1,h=c?c.length:0,d=i[0];n:for(;++u<h;)if(l=c[u],(d?Jn(d,l):a(s,l,0))<0){for(var t=r;--t;){var p=i[t];if((p?Jn(p,l):a(n[t],l,0))<0)continue n}d&&d.push(l),s.push(l)}return s}),Yo=vi(function(r,e){e=Cr(e);var t=Er(r,e);return qr(r,e.sort(n)),t}),Ko=Oe(),Zo=Oe(!0),Qo=vi(function(n){return ne(Cr(n,!1,!0))}),Jo=vi(function(n,r){return Qe(n)?wr(n,r):[]}),$o=vi(Dt),ns=vi(function(n){var r=n.length,e=r>2?n[r-2]:T,t=r>1?n[r-1]:T;return r>2&&"function"==typeof e?r-=2:(e=r>1&&"function"==typeof t?(--r,t):T,t=T),n.length=r,It(n,e,t)}),rs=vi(function(n){return n=Cr(n),this.thru(function(r){return er(Ms(r)?r:[ht(r)],n)})}),es=vi(function(n,r){return Er(n,Cr(r))}),ts=ue(function(n,r,e){no.call(n,e)?++n[e]:n[e]=1}),is=xe(Oo),as=xe(Do,!0),os=Re(ir,Oo),ss=Re(ar,Do),ls=ue(function(n,r,e){no.call(n,e)?n[e].push(r):n[e]=[r]}),cs=ue(function(n,r,e){n[e]=r}),us=vi(function(n,r,e){var t=-1,i="function"==typeof r,a=nt(r),o=Qe(n)?Ba(n.length):[];return Oo(n,function(n){var s=i?r:a&&null!=n?n[r]:T;o[++t]=s?s.apply(n,e):Ze(n,r,e)}),o}),hs=ue(function(n,r,e){n[e?0:1].push(r)},function(){return[[],[]]}),ds=ke(hr,Oo),ps=ke(dr,Do),fs=vi(function(n,r){if(null==n)return[];var e=r[2];return e&&$e(r[0],r[1],e)&&(r.length=1),Jr(n,Cr(r),[])}),ms=wo||function(){return(new Na).getTime()},gs=vi(function(n,r,e){var t=w;if(e.length){var i=g(e,gs.placeholder);t|=M}return De(n,t,r,e,i)}),vs=vi(function(n,r){r=r.length?Cr(r):Zi(n);for(var e=-1,t=r.length;++e<t;){var i=r[e];n[i]=De(n[i],w,n)}return n}),ys=vi(function(n,r,e){var t=w|R;if(e.length){var i=g(e,ys.placeholder);t|=M}return De(r,t,n,e,i)}),Es=ye(S),bs=ye(A),xs=vi(function(n,r){return _r(n,1,r)}),Ts=vi(function(n,r,e){return _r(n,r,e)}),_s=we(),ws=we(!0),Rs=vi(function(n,r){if(r=Cr(r),"function"!=typeof n||!or(r,t))throw new Ka(B);var e=r.length;return vi(function(t){for(var i=_o(t.length,e);i--;)t[i]=r[i](t[i]);return n.apply(this,t)})}),Hs=Ce(M),Ss=Ce(C),As=vi(function(n,r){return De(n,j,T,T,T,Cr(r))}),Ms=Eo||function(n){return f(n)&&et(n.length)&&eo.call(n)==V},Cs=he(Ur),ks=he(function(n,r,e){return e?vr(n,r,e):yr(n,r)}),js=Ee(ks,mr),Ps=Ee(Cs,at),Ls=_e(jr),Fs=_e(Pr),Os=He(Io),Ds=He(zo),Is=Se(jr),zs=Se(Pr),Bs=xo?function(n){var r=null==n?T:n.constructor;return"function"==typeof r&&r.prototype===n||"function"!=typeof n&&Qe(n)?ct(n):Li(n)?xo(n):[]}:ct,Ns=Ae(!0),Us=Ae(),Vs=vi(function(n,r){if(null==n)return{};if("function"!=typeof r[0]){var r=cr(Cr(r),Ya);return ot(n,wr(na(n),r))}var e=oe(r[0],r[1],3);return st(n,function(n,r,t){return!e(n,r,t)})}),Gs=vi(function(n,r){return null==n?{}:"function"==typeof r[0]?st(n,oe(r[0],r[1],3)):ot(n,Cr(r))}),Ws=ge(function(n,r,e){return r=r.toLowerCase(),n+(e?r.charAt(0).toUpperCase()+r.slice(1):r)}),qs=ge(function(n,r,e){return n+(e?"-":"")+r.toLowerCase()}),Xs=Me(),Ys=Me(!0),Ks=ge(function(n,r,e){return n+(e?"_":"")+r.toLowerCase()}),Zs=ge(function(n,r,e){return n+(e?" ":"")+(r.charAt(0).toUpperCase()+r.slice(1))}),Qs=vi(function(n,r){try{return n.apply(T,r)}catch(e){return ki(e)?e:new Ua(e)}}),Js=vi(function(n,r){return function(e){return Ze(e,n,r)}}),$s=vi(function(n,r){return function(e){return Ze(n,e,r)}}),nl=Fe("ceil"),rl=Fe("floor"),el=be(_i,So),tl=be(Wi,Ao),il=Fe("round");return Y.prototype=J.prototype,nn.prototype=Fo(J.prototype),nn.prototype.constructor=nn,Un.prototype=Fo(J.prototype),Un.prototype.constructor=Un,qn.prototype["delete"]=Xn,qn.prototype.get=Yn,qn.prototype.has=Kn,qn.prototype.set=Zn,Qn.prototype.push=$n,fi.Cache=qn,Y.after=ui,Y.ary=hi,Y.assign=ks,Y.at=es,Y.before=di,Y.bind=gs,Y.bindAll=vs,Y.bindKey=ys,Y.callback=Ra,Y.chain=Nt,Y.chunk=ft,Y.compact=mt,Y.constant=Ha,Y.countBy=ts,Y.create=Ki,Y.curry=Es,Y.curryRight=bs,Y.debounce=pi,Y.defaults=js,Y.defaultsDeep=Ps,Y.defer=xs,Y.delay=Ts,Y.difference=Go,Y.drop=gt,Y.dropRight=vt,Y.dropRightWhile=yt,Y.dropWhile=Et,Y.fill=bt,Y.filter=Qt,Y.flatten=Tt,Y.flattenDeep=_t,Y.flow=_s,Y.flowRight=ws,Y.forEach=os,Y.forEachRight=ss,Y.forIn=Os,Y.forInRight=Ds,Y.forOwn=Is,Y.forOwnRight=zs,Y.functions=Zi,Y.groupBy=ls,Y.indexBy=cs,Y.initial=Rt,Y.intersection=Xo,Y.invert=$i,Y.invoke=us,Y.keys=Bs,Y.keysIn=na,Y.map=ni,Y.mapKeys=Ns,Y.mapValues=Us,Y.matches=Aa,Y.matchesProperty=Ma,Y.memoize=fi,Y.merge=Cs,Y.method=Js,Y.methodOf=$s,Y.mixin=Ca,Y.modArgs=Rs,Y.negate=mi,Y.omit=Vs,Y.once=gi,Y.pairs=ra,Y.partial=Hs,Y.partialRight=Ss,Y.partition=hs,Y.pick=Gs,Y.pluck=ri,Y.property=Pa,Y.propertyOf=La,Y.pull=At,Y.pullAt=Yo,Y.range=Fa,Y.rearg=As,Y.reject=ei,Y.remove=Mt,Y.rest=Ct,Y.restParam=vi,Y.set=ta,Y.shuffle=ii,Y.slice=kt,Y.sortBy=si,Y.sortByAll=fs,Y.sortByOrder=li,Y.spread=yi,Y.take=jt,Y.takeRight=Pt,Y.takeRightWhile=Lt,Y.takeWhile=Ft,Y.tap=Ut,Y.throttle=Ei,Y.thru=Vt,Y.times=Oa,Y.toArray=Xi,Y.toPlainObject=Yi,Y.transform=ia,Y.union=Qo,Y.uniq=Ot,Y.unzip=Dt,Y.unzipWith=It,Y.values=aa,Y.valuesIn=oa,Y.where=ci,Y.without=Jo,Y.wrap=bi,Y.xor=zt,Y.zip=$o,Y.zipObject=Bt,Y.zipWith=ns,Y.backflow=ws,Y.collect=ni,Y.compose=ws,Y.each=os,Y.eachRight=ss,Y.extend=ks,Y.iteratee=Ra,Y.methods=Zi,Y.object=Bt,Y.select=Qt,Y.tail=Ct,Y.unique=Ot,Ca(Y,Y),Y.add=Ia,Y.attempt=Qs,Y.camelCase=Ws,Y.capitalize=ca,Y.ceil=nl,Y.clone=xi,Y.cloneDeep=Ti,Y.deburr=ua,Y.endsWith=ha,Y.escape=da,Y.escapeRegExp=pa,Y.every=Zt,Y.find=is,Y.findIndex=Wo,Y.findKey=Ls,Y.findLast=as,Y.findLastIndex=qo,Y.findLastKey=Fs,Y.findWhere=Jt,Y.first=xt,Y.floor=rl,Y.get=Qi,Y.gt=_i,Y.gte=wi,Y.has=Ji,Y.identity=Sa,Y.includes=$t,Y.indexOf=wt,Y.inRange=sa,Y.isArguments=Ri,Y.isArray=Ms,Y.isBoolean=Hi,Y.isDate=Si,Y.isElement=Ai,Y.isEmpty=Mi,Y.isEqual=Ci,Y.isError=ki,Y.isFinite=ji,Y.isFunction=Pi,Y.isMatch=Fi,Y.isNaN=Oi,Y.isNative=Di,Y.isNull=Ii,Y.isNumber=zi,Y.isObject=Li,Y.isPlainObject=Bi,Y.isRegExp=Ni,Y.isString=Ui,Y.isTypedArray=Vi,Y.isUndefined=Gi,Y.kebabCase=qs,Y.last=Ht,Y.lastIndexOf=St,Y.lt=Wi,Y.lte=qi,Y.max=el,Y.min=tl,Y.noConflict=ka,Y.noop=ja,Y.now=ms,Y.pad=fa,Y.padLeft=Xs,Y.padRight=Ys,Y.parseInt=ma,Y.random=la,Y.reduce=ds,Y.reduceRight=ps,Y.repeat=ga,Y.result=ea,Y.round=il,Y.runInContext=x,Y.size=ai,Y.snakeCase=Ks,Y.some=oi,Y.sortedIndex=Ko,Y.sortedLastIndex=Zo,Y.startCase=Zs,Y.startsWith=va,Y.sum=za,Y.template=ya,
Y.trim=Ea,Y.trimLeft=ba,Y.trimRight=xa,Y.trunc=Ta,Y.unescape=_a,Y.uniqueId=Da,Y.words=wa,Y.all=Zt,Y.any=oi,Y.contains=$t,Y.eq=Ci,Y.detect=is,Y.foldl=ds,Y.foldr=ps,Y.head=xt,Y.include=$t,Y.inject=ds,Ca(Y,function(){var n={};return jr(Y,function(r,e){Y.prototype[e]||(n[e]=r)}),n}(),!1),Y.sample=ti,Y.prototype.sample=function(n){return this.__chain__||null!=n?this.thru(function(r){return ti(r,n)}):ti(this.value())},Y.VERSION=_,ir(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){Y[n].placeholder=Y}),ir(["drop","take"],function(n,r){Un.prototype[n]=function(e){var t=this.__filtered__;if(t&&!r)return new Un(this);e=null==e?1:To(yo(e)||0,0);var i=this.clone();return t?i.__takeCount__=_o(i.__takeCount__,e):i.__views__.push({size:e,type:n+(i.__dir__<0?"Right":"")}),i},Un.prototype[n+"Right"]=function(r){return this.reverse()[n](r).reverse()}}),ir(["filter","map","takeWhile"],function(n,r){var e=r+1,t=e!=z;Un.prototype[n]=function(n,r){var i=this.clone();return i.__iteratees__.push({iteratee:Ne(n,r,1),type:e}),i.__filtered__=i.__filtered__||t,i}}),ir(["first","last"],function(n,r){var e="take"+(r?"Right":"");Un.prototype[n]=function(){return this[e](1).value()[0]}}),ir(["initial","rest"],function(n,r){var e="drop"+(r?"":"Right");Un.prototype[n]=function(){return this.__filtered__?new Un(this):this[e](1)}}),ir(["pluck","where"],function(n,r){var e=r?"filter":"map",t=r?Br:Pa;Un.prototype[n]=function(n){return this[e](t(n))}}),Un.prototype.compact=function(){return this.filter(Sa)},Un.prototype.reject=function(n,r){return n=Ne(n,r,1),this.filter(function(r){return!n(r)})},Un.prototype.slice=function(n,r){n=null==n?0:+n||0;var e=this;return e.__filtered__&&(n>0||0>r)?new Un(e):(0>n?e=e.takeRight(-n):n&&(e=e.drop(n)),r!==T&&(r=+r||0,e=0>r?e.dropRight(-r):e.take(r-n)),e)},Un.prototype.takeRightWhile=function(n,r){return this.reverse().takeWhile(n,r).reverse()},Un.prototype.toArray=function(){return this.take(Ao)},jr(Un.prototype,function(n,r){var e=/^(?:filter|map|reject)|While$/.test(r),t=/^(?:first|last)$/.test(r),i=Y[t?"take"+("last"==r?"Right":""):r];i&&(Y.prototype[r]=function(){var r=t?[1]:arguments,a=this.__chain__,o=this.__wrapped__,s=!!this.__actions__.length,l=o instanceof Un,c=r[0],u=l||Ms(o);u&&e&&"function"==typeof c&&1!=c.length&&(l=u=!1);var h=function(n){return t&&a?i(n,1)[0]:i.apply(T,ur([n],r))},d={func:Vt,args:[h],thisArg:T},p=l&&!s;if(t&&!a)return p?(o=o.clone(),o.__actions__.push(d),n.call(o)):i.call(T,this.value())[0];if(!t&&u){o=p?o:new Un(this);var f=n.apply(o,r);return f.__actions__.push(d),new nn(f,a)}return this.thru(h)})}),ir(["join","pop","push","replace","shift","sort","splice","split","unshift"],function(n){var r=(/^(?:replace|split)$/.test(n)?Ja:Za)[n],e=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",t=/^(?:join|pop|replace|shift)$/.test(n);Y.prototype[n]=function(){var n=arguments;return t&&!this.__chain__?r.apply(this.value(),n):this[e](function(e){return r.apply(e,n)})}}),jr(Un.prototype,function(n,r){var e=Y[r];if(e){var t=e.name+"",i=Lo[t]||(Lo[t]=[]);i.push({name:r,func:e})}}),Lo[je(T,R).name]=[{name:"wrapper",func:T}],Un.prototype.clone=Vn,Un.prototype.reverse=Gn,Un.prototype.value=Wn,Y.prototype.chain=Gt,Y.prototype.commit=Wt,Y.prototype.concat=rs,Y.prototype.plant=qt,Y.prototype.reverse=Xt,Y.prototype.toString=Yt,Y.prototype.run=Y.prototype.toJSON=Y.prototype.valueOf=Y.prototype.value=Kt,Y.prototype.collect=Y.prototype.map,Y.prototype.head=Y.prototype.first,Y.prototype.select=Y.prototype.filter,Y.prototype.tail=Y.prototype.rest,Y}var T,_="3.10.1",w=1,R=2,H=4,S=8,A=16,M=32,C=64,k=128,j=256,P=30,L="...",F=150,O=16,D=200,I=1,z=2,B="Expected a function",N="__lodash_placeholder__",U="[object Arguments]",V="[object Array]",G="[object Boolean]",W="[object Date]",q="[object Error]",X="[object Function]",Y="[object Map]",K="[object Number]",Z="[object Object]",Q="[object RegExp]",J="[object Set]",$="[object String]",nn="[object WeakMap]",rn="[object ArrayBuffer]",en="[object Float32Array]",tn="[object Float64Array]",an="[object Int8Array]",on="[object Int16Array]",sn="[object Int32Array]",ln="[object Uint8Array]",cn="[object Uint8ClampedArray]",un="[object Uint16Array]",hn="[object Uint32Array]",dn=/\b__p \+= '';/g,pn=/\b(__p \+=) '' \+/g,fn=/(__e\(.*?\)|\b__t\)) \+\n'';/g,mn=/&(?:amp|lt|gt|quot|#39|#96);/g,gn=/[&<>"'`]/g,vn=RegExp(mn.source),yn=RegExp(gn.source),En=/<%-([\s\S]+?)%>/g,bn=/<%([\s\S]+?)%>/g,xn=/<%=([\s\S]+?)%>/g,Tn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,_n=/^\w*$/,wn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g,Rn=/^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,Hn=RegExp(Rn.source),Sn=/[\u0300-\u036f\ufe20-\ufe23]/g,An=/\\(\\)?/g,Mn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Cn=/\w*$/,kn=/^0[xX]/,jn=/^\[object .+?Constructor\]$/,Pn=/^\d+$/,Ln=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,Fn=/($^)/,On=/['\n\r\u2028\u2029\\]/g,Dn=function(){var n="[A-Z\\xc0-\\xd6\\xd8-\\xde]",r="[a-z\\xdf-\\xf6\\xf8-\\xff]+";return RegExp(n+"+(?="+n+r+")|"+n+"?"+r+"|"+n+"+|[0-9]+","g")}(),In=["Array","ArrayBuffer","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Math","Number","Object","RegExp","Set","String","_","clearTimeout","isFinite","parseFloat","parseInt","setTimeout","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap"],zn=-1,Bn={};Bn[en]=Bn[tn]=Bn[an]=Bn[on]=Bn[sn]=Bn[ln]=Bn[cn]=Bn[un]=Bn[hn]=!0,Bn[U]=Bn[V]=Bn[rn]=Bn[G]=Bn[W]=Bn[q]=Bn[X]=Bn[Y]=Bn[K]=Bn[Z]=Bn[Q]=Bn[J]=Bn[$]=Bn[nn]=!1;var Nn={};Nn[U]=Nn[V]=Nn[rn]=Nn[G]=Nn[W]=Nn[en]=Nn[tn]=Nn[an]=Nn[on]=Nn[sn]=Nn[K]=Nn[Z]=Nn[Q]=Nn[$]=Nn[ln]=Nn[cn]=Nn[un]=Nn[hn]=!0,Nn[q]=Nn[X]=Nn[Y]=Nn[J]=Nn[nn]=!1;var Un={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss"},Vn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},Gn={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},Wn={"function":!0,object:!0},qn={0:"x30",1:"x31",2:"x32",3:"x33",4:"x34",5:"x35",6:"x36",7:"x37",8:"x38",9:"x39",A:"x41",B:"x42",C:"x43",D:"x44",E:"x45",F:"x46",a:"x61",b:"x62",c:"x63",d:"x64",e:"x65",f:"x66",n:"x6e",r:"x72",t:"x74",u:"x75",v:"x76",x:"x78"},Xn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Yn=Wn[typeof exports]&&exports&&!exports.nodeType&&exports,Kn=Wn[typeof module]&&module&&!module.nodeType&&module,Zn=Yn&&Kn&&"object"==typeof global&&global&&global.Object&&global,Qn=Wn[typeof self]&&self&&self.Object&&self,Jn=Wn[typeof window]&&window&&window.Object&&window,$n=Kn&&Kn.exports===Yn&&Yn,nr=Zn||Jn!==(this&&this.window)&&Jn||Qn||this,rr=x();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(nr._=rr,define(function(){return rr})):Yn&&Kn?$n?(Kn.exports=rr)._=rr:Yn._=rr:nr._=rr}.call(this),!function(n){function r(){this._events={},this._conf&&e.call(this,this._conf)}function e(n){n&&(this._conf=n,n.delimiter&&(this.delimiter=n.delimiter),n.maxListeners&&(this._events.maxListeners=n.maxListeners),n.wildcard&&(this.wildcard=n.wildcard),n.newListener&&(this.newListener=n.newListener),this.wildcard&&(this.listenerTree={}))}function t(n){this._events={},this.newListener=!1,e.call(this,n)}function i(n,r,e,t){if(!e)return[];var a,o,s,l,c,u,h,d=[],p=r.length,f=r[t],m=r[t+1];if(t===p&&e._listeners){if("function"==typeof e._listeners)return n&&n.push(e._listeners),[e];for(a=0,o=e._listeners.length;o>a;a++)n&&n.push(e._listeners[a]);return[e]}if("*"===f||"**"===f||e[f]){if("*"===f){for(s in e)"_listeners"!==s&&e.hasOwnProperty(s)&&(d=d.concat(i(n,r,e[s],t+1)));return d}if("**"===f){h=t+1===p||t+2===p&&"*"===m,h&&e._listeners&&(d=d.concat(i(n,r,e,p)));for(s in e)"_listeners"!==s&&e.hasOwnProperty(s)&&("*"===s||"**"===s?(e[s]._listeners&&!h&&(d=d.concat(i(n,r,e[s],p))),d=d.concat(i(n,r,e[s],t))):d=s===m?d.concat(i(n,r,e[s],t+2)):d.concat(i(n,r,e[s],t)));return d}d=d.concat(i(n,r,e[f],t+1))}if(l=e["*"],l&&i(n,r,l,t+1),c=e["**"])if(p>t){c._listeners&&i(n,r,c,p);for(s in c)"_listeners"!==s&&c.hasOwnProperty(s)&&(s===m?i(n,r,c[s],t+2):s===f?i(n,r,c[s],t+1):(u={},u[s]=c[s],i(n,r,{"**":u},t+1)))}else c._listeners?i(n,r,c,p):c["*"]&&c["*"]._listeners&&i(n,r,c["*"],p);return d}function a(n,r){n="string"==typeof n?n.split(this.delimiter):n.slice();for(var e=0,t=n.length;t>e+1;e++)if("**"===n[e]&&"**"===n[e+1])return;for(var i=this.listenerTree,a=n.shift();a;){if(i[a]||(i[a]={}),i=i[a],0===n.length){if(i._listeners){if("function"==typeof i._listeners)i._listeners=[i._listeners,r];else if(o(i._listeners)&&(i._listeners.push(r),!i._listeners.warned)){var l=s;"undefined"!=typeof this._events.maxListeners&&(l=this._events.maxListeners),l>0&&i._listeners.length>l&&(i._listeners.warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",i._listeners.length),console.trace())}}else i._listeners=r;return!0}a=n.shift()}return!0}var o=Array.isArray?Array.isArray:function(n){return"[object Array]"===Object.prototype.toString.call(n)},s=10;t.prototype.delimiter=".",t.prototype.setMaxListeners=function(n){this._events||r.call(this),this._events.maxListeners=n,this._conf||(this._conf={}),this._conf.maxListeners=n},t.prototype.event="",t.prototype.once=function(n,r){return this.many(n,1,r),this},t.prototype.many=function(n,r,e){function t(){0===--r&&i.off(n,t),e.apply(this,arguments)}var i=this;if("function"!=typeof e)throw new Error("many only accepts instances of Function");return t._origin=e,this.on(n,t),i},t.prototype.emit=function(){this._events||r.call(this);var n=arguments[0];if("newListener"===n&&!this.newListener&&!this._events.newListener)return!1;if(this._all){for(var e=arguments.length,t=new Array(e-1),a=1;e>a;a++)t[a-1]=arguments[a];for(a=0,e=this._all.length;e>a;a++)this.event=n,this._all[a].apply(this,t)}if("error"===n&&!(this._all||this._events.error||this.wildcard&&this.listenerTree.error))throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");var o;if(this.wildcard){o=[];var s="string"==typeof n?n.split(this.delimiter):n.slice();i.call(this,o,s,this.listenerTree,0)}else o=this._events[n];if("function"==typeof o){if(this.event=n,1===arguments.length)o.call(this);else if(arguments.length>1)switch(arguments.length){case 2:o.call(this,arguments[1]);break;case 3:o.call(this,arguments[1],arguments[2]);break;default:for(var e=arguments.length,t=new Array(e-1),a=1;e>a;a++)t[a-1]=arguments[a];o.apply(this,t)}return!0}if(o){for(var e=arguments.length,t=new Array(e-1),a=1;e>a;a++)t[a-1]=arguments[a];for(var l=o.slice(),a=0,e=l.length;e>a;a++)this.event=n,l[a].apply(this,t);return l.length>0||!!this._all}return!!this._all},t.prototype.on=function(n,e){if("function"==typeof n)return this.onAny(n),this;if("function"!=typeof e)throw new Error("on only accepts instances of Function");if(this._events||r.call(this),this.emit("newListener",n,e),this.wildcard)return a.call(this,n,e),this;if(this._events[n]){if("function"==typeof this._events[n])this._events[n]=[this._events[n],e];else if(o(this._events[n])&&(this._events[n].push(e),!this._events[n].warned)){var t=s;"undefined"!=typeof this._events.maxListeners&&(t=this._events.maxListeners),t>0&&this._events[n].length>t&&(this._events[n].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[n].length),console.trace())}}else this._events[n]=e;return this},t.prototype.onAny=function(n){if("function"!=typeof n)throw new Error("onAny only accepts instances of Function");return this._all||(this._all=[]),this._all.push(n),this},t.prototype.addListener=t.prototype.on,t.prototype.off=function(n,r){if("function"!=typeof r)throw new Error("removeListener only takes instances of Function");var e,t=[];if(this.wildcard){var a="string"==typeof n?n.split(this.delimiter):n.slice();t=i.call(this,null,a,this.listenerTree,0)}else{if(!this._events[n])return this;e=this._events[n],t.push({_listeners:e})}for(var s=0;s<t.length;s++){var l=t[s];if(e=l._listeners,o(e)){for(var c=-1,u=0,h=e.length;h>u;u++)if(e[u]===r||e[u].listener&&e[u].listener===r||e[u]._origin&&e[u]._origin===r){c=u;break}if(0>c)continue;return this.wildcard?l._listeners.splice(c,1):this._events[n].splice(c,1),0===e.length&&(this.wildcard?delete l._listeners:delete this._events[n]),this}(e===r||e.listener&&e.listener===r||e._origin&&e._origin===r)&&(this.wildcard?delete l._listeners:delete this._events[n])}return this},t.prototype.offAny=function(n){var r,e=0,t=0;if(n&&this._all&&this._all.length>0){for(r=this._all,e=0,t=r.length;t>e;e++)if(n===r[e])return r.splice(e,1),this}else this._all=[];return this},t.prototype.removeListener=t.prototype.off,t.prototype.removeAllListeners=function(n){if(0===arguments.length)return!this._events||r.call(this),this;if(this.wildcard)for(var e="string"==typeof n?n.split(this.delimiter):n.slice(),t=i.call(this,null,e,this.listenerTree,0),a=0;a<t.length;a++){var o=t[a];o._listeners=null}else{if(!this._events[n])return this;this._events[n]=null}return this},t.prototype.listeners=function(n){if(this.wildcard){var e=[],t="string"==typeof n?n.split(this.delimiter):n.slice();return i.call(this,e,t,this.listenerTree,0),e}return this._events||r.call(this),this._events[n]||(this._events[n]=[]),o(this._events[n])||(this._events[n]=[this._events[n]]),this._events[n]},t.prototype.listenersAny=function(){return this._all?this._all:[]},"function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof exports?exports.EventEmitter2=t:window.EventEmitter2=t}(),function n(r,e,t){function i(o,s){if(!e[o]){if(!r[o]){var l="function"==typeof require&&require;if(!s&&l)return l(o,!0);if(a)return a(o,!0);var c=new Error("Cannot find module '"+o+"'");throw c.code="MODULE_NOT_FOUND",c}var u=e[o]={exports:{}};r[o][0].call(u.exports,function(n){var e=r[o][1][n];return i(e?e:n)},u,u.exports,n,r,e,t)}return e[o].exports}for(var a="function"==typeof require&&require,o=0;o<t.length;o++)i(t[o]);return i}({1:[function(n,r,e){r.exports.RTCSessionDescription=window.RTCSessionDescription||window.mozRTCSessionDescription,r.exports.RTCPeerConnection=window.RTCPeerConnection||window.mozRTCPeerConnection||window.webkitRTCPeerConnection,r.exports.RTCIceCandidate=window.RTCIceCandidate||window.mozRTCIceCandidate},{}],2:[function(n,r,e){function t(n,r,e){return this instanceof t?(a.call(this),this.options=i.extend({serialization:"binary",reliable:!1},e),this.open=!1,this.type="data",this.peer=n,this.provider=r,this.id=this.options.connectionId||t._idPrefix+i.randomToken(),this.label=this.options.label||this.id,this.metadata=this.options.metadata,this.serialization=this.options.serialization,this.reliable=this.options.reliable,this._buffer=[],this._buffering=!1,this.bufferSize=0,this._chunkedData={},this.options._payload&&(this._peerBrowser=this.options._payload.browser),void o.startConnection(this,this.options._payload||{originator:!0})):new t(n,r,e)}var i=n("./util"),a=n("eventemitter3"),o=n("./negotiator"),s=n("reliable");i.inherits(t,a),t._idPrefix="dc_",t.prototype.initialize=function(n){this._dc=this.dataChannel=n,this._configureDataChannel()},t.prototype._configureDataChannel=function(){var n=this;i.supports.sctp&&(this._dc.binaryType="arraybuffer"),this._dc.onopen=function(){i.log("Data channel connection success"),n.open=!0,n.emit("open")},!i.supports.sctp&&this.reliable&&(this._reliable=new s(this._dc,i.debug)),this._reliable?this._reliable.onmessage=function(r){n.emit("data",r)}:this._dc.onmessage=function(r){n._handleDataMessage(r)},this._dc.onclose=function(r){i.log("DataChannel closed for:",n.peer),n.close()}},t.prototype._handleDataMessage=function(n){var r=this,e=n.data,t=e.constructor;if("binary"===this.serialization||"binary-utf8"===this.serialization){if(t===Blob)return void i.blobToArrayBuffer(e,function(n){e=i.unpack(n),r.emit("data",e)});if(t===ArrayBuffer)e=i.unpack(e);else if(t===String){var a=i.binaryStringToArrayBuffer(e);e=i.unpack(a)}}else"json"===this.serialization&&(e=JSON.parse(e));if(e.__peerData){var o=e.__peerData,s=this._chunkedData[o]||{data:[],count:0,total:e.total};return s.data[e.n]=e.data,s.count+=1,s.total===s.count&&(delete this._chunkedData[o],e=new Blob(s.data),this._handleDataMessage({data:e})),void(this._chunkedData[o]=s)}this.emit("data",e)},t.prototype.close=function(){this.open&&(this.open=!1,o.cleanup(this),this.emit("close"))},t.prototype.send=function(n,r){if(!this.open)return void this.emit("error",new Error("Connection is not open. You should listen for the `open` event before sending messages."));if(this._reliable)return void this._reliable.send(n);var e=this;if("json"===this.serialization)this._bufferedSend(JSON.stringify(n));else if("binary"===this.serialization||"binary-utf8"===this.serialization){var t=i.pack(n),a=i.chunkedBrowsers[this._peerBrowser]||i.chunkedBrowsers[i.browser];if(a&&!r&&t.size>i.chunkedMTU)return void this._sendChunks(t);i.supports.sctp?i.supports.binaryBlob?this._bufferedSend(t):i.blobToArrayBuffer(t,function(n){e._bufferedSend(n)}):i.blobToBinaryString(t,function(n){e._bufferedSend(n)})}else this._bufferedSend(n)},t.prototype._bufferedSend=function(n){(this._buffering||!this._trySend(n))&&(this._buffer.push(n),this.bufferSize=this._buffer.length)},t.prototype._trySend=function(n){try{this._dc.send(n)}catch(r){this._buffering=!0;var e=this;return setTimeout(function(){e._buffering=!1,e._tryBuffer()},100),!1}return!0},t.prototype._tryBuffer=function(){if(0!==this._buffer.length){var n=this._buffer[0];this._trySend(n)&&(this._buffer.shift(),this.bufferSize=this._buffer.length,this._tryBuffer())}},t.prototype._sendChunks=function(n){for(var r=i.chunk(n),e=0,t=r.length;t>e;e+=1){var n=r[e];this.send(n,!0)}},t.prototype.handleMessage=function(n){var r=n.payload;switch(n.type){case"ANSWER":this._peerBrowser=r.browser,o.handleSDP(n.type,this,r.sdp);break;case"CANDIDATE":o.handleCandidate(this,r.candidate);break;default:i.warn("Unrecognized message type:",n.type,"from peer:",this.peer)}},r.exports=t},{"./negotiator":5,"./util":8,eventemitter3:9,reliable:12}],3:[function(n,r,e){window.Socket=n("./socket"),window.MediaConnection=n("./mediaconnection"),window.DataConnection=n("./dataconnection"),window.Peer=n("./peer"),window.RTCPeerConnection=n("./adapter").RTCPeerConnection,window.RTCSessionDescription=n("./adapter").RTCSessionDescription,window.RTCIceCandidate=n("./adapter").RTCIceCandidate,window.Negotiator=n("./negotiator"),window.util=n("./util"),window.BinaryPack=n("js-binarypack")},{"./adapter":1,"./dataconnection":2,"./mediaconnection":4,"./negotiator":5,"./peer":6,"./socket":7,"./util":8,"js-binarypack":10}],4:[function(n,r,e){function t(n,r,e){return this instanceof t?(a.call(this),this.options=i.extend({},e),this.open=!1,this.type="media",this.peer=n,this.provider=r,this.metadata=this.options.metadata,this.localStream=this.options._stream,this.id=this.options.connectionId||t._idPrefix+i.randomToken(),void(this.localStream&&o.startConnection(this,{_stream:this.localStream,originator:!0}))):new t(n,r,e)}var i=n("./util"),a=n("eventemitter3"),o=n("./negotiator");i.inherits(t,a),t._idPrefix="mc_",t.prototype.addStream=function(n){i.log("Receiving stream",n),this.remoteStream=n,this.emit("stream",n)},t.prototype.handleMessage=function(n){var r=n.payload;switch(n.type){case"ANSWER":o.handleSDP(n.type,this,r.sdp),this.open=!0;break;case"CANDIDATE":o.handleCandidate(this,r.candidate);break;default:i.warn("Unrecognized message type:",n.type,"from peer:",this.peer)}},t.prototype.answer=function(n){if(this.localStream)return void i.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");this.options._payload._stream=n,this.localStream=n,o.startConnection(this,this.options._payload);for(var r=this.provider._getMessages(this.id),e=0,t=r.length;t>e;e+=1)this.handleMessage(r[e]);this.open=!0},t.prototype.close=function(){this.open&&(this.open=!1,o.cleanup(this),this.emit("close"))},r.exports=t},{"./negotiator":5,"./util":8,eventemitter3:9}],5:[function(n,r,e){var t=n("./util"),i=n("./adapter").RTCPeerConnection,a=n("./adapter").RTCSessionDescription,o=n("./adapter").RTCIceCandidate,s={pcs:{data:{},media:{}},queue:[]};s._idPrefix="pc_",s.startConnection=function(n,r){var e=s._getPeerConnection(n,r);if("media"===n.type&&r._stream&&e.addStream(r._stream),n.pc=n.peerConnection=e,r.originator){if("data"===n.type){var i={};t.supports.sctp||(i={reliable:r.reliable});var a=e.createDataChannel(n.label,i);n.initialize(a)}t.supports.onnegotiationneeded||s._makeOffer(n)}else s.handleSDP("OFFER",n,r.sdp)},s._getPeerConnection=function(n,r){s.pcs[n.type]||t.error(n.type+" is not a valid connection type. Maybe you overrode the `type` property somewhere."),s.pcs[n.type][n.peer]||(s.pcs[n.type][n.peer]={});var e;s.pcs[n.type][n.peer];return r.pc&&(e=s.pcs[n.type][n.peer][r.pc]),e&&"stable"===e.signalingState||(e=s._startPeerConnection(n)),e},s._startPeerConnection=function(n){t.log("Creating RTCPeerConnection.");var r=s._idPrefix+t.randomToken(),e={};"data"!==n.type||t.supports.sctp?"media"===n.type&&(e={optional:[{DtlsSrtpKeyAgreement:!0}]}):e={optional:[{RtpDataChannels:!0}]};var a=new i(n.provider.options.config,e);return s.pcs[n.type][n.peer][r]=a,s._setupListeners(n,a,r),a},s._setupListeners=function(n,r,e){var i=n.peer,a=n.id,o=n.provider;t.log("Listening for ICE candidates."),r.onicecandidate=function(r){r.candidate&&(t.log("Received ICE candidates for:",n.peer),o.socket.send({type:"CANDIDATE",payload:{candidate:r.candidate,type:n.type,connectionId:n.id},dst:i}))},r.oniceconnectionstatechange=function(){switch(r.iceConnectionState){case"disconnected":case"failed":t.log("iceConnectionState is disconnected, closing connections to "+i),n.close();break;case"completed":r.onicecandidate=t.noop}},r.onicechange=r.oniceconnectionstatechange,t.log("Listening for `negotiationneeded`"),r.onnegotiationneeded=function(){t.log("`negotiationneeded` triggered"),"stable"==r.signalingState?s._makeOffer(n):t.log("onnegotiationneeded triggered when not stable. Is another connection being established?")},t.log("Listening for data channel"),r.ondatachannel=function(n){t.log("Received data channel");var r=n.channel,e=o.getConnection(i,a);e.initialize(r)},t.log("Listening for remote stream"),r.onaddstream=function(n){t.log("Received remote stream");var r=n.stream,e=o.getConnection(i,a);"media"===e.type&&e.addStream(r)}},s.cleanup=function(n){t.log("Cleaning up PeerConnection to "+n.peer);var r=n.pc;!r||"closed"===r.readyState&&"closed"===r.signalingState||(r.close(),n.pc=null)},s._makeOffer=function(n){var r=n.pc;r.createOffer(function(e){t.log("Created offer."),!t.supports.sctp&&"data"===n.type&&n.reliable&&(e.sdp=Reliable.higherBandwidthSDP(e.sdp)),r.setLocalDescription(e,function(){t.log("Set localDescription: offer","for:",n.peer),n.provider.socket.send({type:"OFFER",payload:{sdp:e,type:n.type,label:n.label,connectionId:n.id,reliable:n.reliable,serialization:n.serialization,metadata:n.metadata,browser:t.browser},dst:n.peer})},function(r){n.provider.emitError("webrtc",r),t.log("Failed to setLocalDescription, ",r)})},function(r){n.provider.emitError("webrtc",r),t.log("Failed to createOffer, ",r)},n.options.constraints)},s._makeAnswer=function(n){var r=n.pc;r.createAnswer(function(e){t.log("Created answer."),!t.supports.sctp&&"data"===n.type&&n.reliable&&(e.sdp=Reliable.higherBandwidthSDP(e.sdp)),r.setLocalDescription(e,function(){t.log("Set localDescription: answer","for:",n.peer),n.provider.socket.send({type:"ANSWER",payload:{sdp:e,type:n.type,connectionId:n.id,browser:t.browser},dst:n.peer})},function(r){n.provider.emitError("webrtc",r),t.log("Failed to setLocalDescription, ",r)})},function(r){n.provider.emitError("webrtc",r),t.log("Failed to create answer, ",r)})},s.handleSDP=function(n,r,e){e=new a(e);var i=r.pc;t.log("Setting remote description",e),i.setRemoteDescription(e,function(){t.log("Set remoteDescription:",n,"for:",r.peer),"OFFER"===n&&s._makeAnswer(r)},function(n){r.provider.emitError("webrtc",n),t.log("Failed to setRemoteDescription, ",n)})},s.handleCandidate=function(n,r){var e=r.candidate,i=r.sdpMLineIndex;n.pc.addIceCandidate(new o({sdpMLineIndex:i,candidate:e})),t.log("Added ICE candidate for:",n.peer)},r.exports=s},{"./adapter":1,"./util":8}],6:[function(n,r,e){function t(n,r){return this instanceof t?(a.call(this),n&&n.constructor==Object?(r=n,n=void 0):n&&(n=n.toString()),r=i.extend({debug:0,host:i.CLOUD_HOST,port:i.CLOUD_PORT,key:"peerjs",path:"/",token:i.randomToken(),config:i.defaultConfig},r),this.options=r,"/"===r.host&&(r.host=window.location.hostname),"/"!==r.path[0]&&(r.path="/"+r.path),"/"!==r.path[r.path.length-1]&&(r.path+="/"),void 0===r.secure&&r.host!==i.CLOUD_HOST&&(r.secure=i.isSecure()),r.logFunction&&i.setLogFunction(r.logFunction),i.setLogLevel(r.debug),i.supports.audioVideo||i.supports.data?i.validateId(n)?i.validateKey(r.key)?r.secure&&"0.peerjs.com"===r.host?void this._delayedAbort("ssl-unavailable","The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS."):(this.destroyed=!1,this.disconnected=!1,this.open=!1,this.connections={},this._lostMessages={},this._initializeServerConnection(),void(n?this._initialize(n):this._retrieveId())):void this._delayedAbort("invalid-key",'API KEY "'+r.key+'" is invalid'):void this._delayedAbort("invalid-id",'ID "'+n+'" is invalid'):void this._delayedAbort("browser-incompatible","The current browser does not support WebRTC")):new t(n,r)}var i=n("./util"),a=n("eventemitter3"),o=n("./socket"),s=n("./mediaconnection"),l=n("./dataconnection");i.inherits(t,a),t.prototype._initializeServerConnection=function(){var n=this;this.socket=new o(this.options.secure,this.options.host,this.options.port,this.options.path,this.options.key),this.socket.on("message",function(r){n._handleMessage(r)}),this.socket.on("error",function(r){n._abort("socket-error",r)}),this.socket.on("disconnected",function(){n.disconnected||(n.emitError("network","Lost connection to server."),n.disconnect())}),this.socket.on("close",function(){n.disconnected||n._abort("socket-closed","Underlying socket is already closed.")})},t.prototype._retrieveId=function(n){var r=this,e=new XMLHttpRequest,t=this.options.secure?"https://":"http://",a=t+this.options.host+":"+this.options.port+this.options.path+this.options.key+"/id",o="?ts="+(new Date).getTime()+Math.random();a+=o,e.open("get",a,!0),e.onerror=function(n){i.error("Error retrieving ID",n);var e="";"/"===r.options.path&&r.options.host!==i.CLOUD_HOST&&(e=" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."),r._abort("server-error","Could not get an ID from the server."+e)},e.onreadystatechange=function(){return 4===e.readyState?200!==e.status?void e.onerror():void r._initialize(e.responseText):void 0},e.send(null)},t.prototype._initialize=function(n){this.id=n,this.socket.start(this.id,this.options.token)},t.prototype._handleMessage=function(n){var r,e=n.type,t=n.payload,a=n.src;switch(e){case"OPEN":this.emit("open",this.id),this.open=!0;break;case"ERROR":this._abort("server-error",t.msg);break;case"ID-TAKEN":this._abort("unavailable-id","ID `"+this.id+"` is taken");break;case"INVALID-KEY":this._abort("invalid-key",'API KEY "'+this.options.key+'" is invalid');break;case"LEAVE":i.log("Received leave message from",a),this._cleanupPeer(a);break;case"EXPIRE":this.emitError("peer-unavailable","Could not connect to peer "+a);break;case"OFFER":var o=t.connectionId;if(r=this.getConnection(a,o))i.warn("Offer received for existing Connection ID:",o);else{if("media"===t.type)r=new s(a,this,{connectionId:o,_payload:t,metadata:t.metadata}),this._addConnection(a,r),this.emit("call",r);else{if("data"!==t.type)return void i.warn("Received malformed connection type:",t.type);r=new l(a,this,{connectionId:o,_payload:t,metadata:t.metadata,label:t.label,serialization:t.serialization,reliable:t.reliable}),this._addConnection(a,r),this.emit("connection",r)}for(var c=this._getMessages(o),u=0,h=c.length;h>u;u+=1)r.handleMessage(c[u])}break;default:if(!t)return void i.warn("You received a malformed message from "+a+" of type "+e);var d=t.connectionId;r=this.getConnection(a,d),r&&r.pc?r.handleMessage(n):d?this._storeMessage(d,n):i.warn("You received an unrecognized message:",n)}},t.prototype._storeMessage=function(n,r){this._lostMessages[n]||(this._lostMessages[n]=[]),this._lostMessages[n].push(r)},t.prototype._getMessages=function(n){var r=this._lostMessages[n];return r?(delete this._lostMessages[n],r):[]},t.prototype.connect=function(n,r){if(this.disconnected)return i.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."),void this.emitError("disconnected","Cannot connect to new Peer after disconnecting from server.");var e=new l(n,this,r);return this._addConnection(n,e),e},t.prototype.call=function(n,r,e){if(this.disconnected)return i.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."),void this.emitError("disconnected","Cannot connect to new Peer after disconnecting from server.");if(!r)return void i.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");e=e||{},e._stream=r;var t=new s(n,this,e);return this._addConnection(n,t),t},t.prototype._addConnection=function(n,r){this.connections[n]||(this.connections[n]=[]),this.connections[n].push(r)},t.prototype.getConnection=function(n,r){var e=this.connections[n];if(!e)return null;for(var t=0,i=e.length;i>t;t++)if(e[t].id===r)return e[t];return null},t.prototype._delayedAbort=function(n,r){var e=this;i.setZeroTimeout(function(){e._abort(n,r)})},t.prototype._abort=function(n,r){i.error("Aborting!"),this._lastServerId?this.disconnect():this.destroy(),this.emitError(n,r)},t.prototype.emitError=function(n,r){i.error("Error:",r),"string"==typeof r&&(r=new Error(r)),r.type=n,this.emit("error",r)},t.prototype.destroy=function(){this.destroyed||(this._cleanup(),this.disconnect(),this.destroyed=!0)},t.prototype._cleanup=function(){if(this.connections)for(var n=Object.keys(this.connections),r=0,e=n.length;e>r;r++)this._cleanupPeer(n[r]);this.emit("close")},t.prototype._cleanupPeer=function(n){for(var r=this.connections[n],e=0,t=r.length;t>e;e+=1)r[e].close()},t.prototype.disconnect=function(){var n=this;i.setZeroTimeout(function(){n.disconnected||(n.disconnected=!0,n.open=!1,n.socket&&n.socket.close(),n.emit("disconnected",n.id),n._lastServerId=n.id,n.id=null)})},t.prototype.reconnect=function(){if(this.disconnected&&!this.destroyed)i.log("Attempting reconnection to server with ID "+this._lastServerId),this.disconnected=!1,this._initializeServerConnection(),this._initialize(this._lastServerId);else{if(this.destroyed)throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");if(this.disconnected||this.open)throw new Error("Peer "+this.id+" cannot reconnect because it is not disconnected from the server!");i.error("In a hurry? We're still trying to make the initial connection!")}},t.prototype.listAllPeers=function(n){n=n||function(){};var r=this,e=new XMLHttpRequest,t=this.options.secure?"https://":"http://",a=t+this.options.host+":"+this.options.port+this.options.path+this.options.key+"/peers",o="?ts="+(new Date).getTime()+Math.random();
a+=o,e.open("get",a,!0),e.onerror=function(e){r._abort("server-error","Could not get peers from the server."),n([])},e.onreadystatechange=function(){if(4===e.readyState){if(401===e.status){var t="";throw t=r.options.host!==i.CLOUD_HOST?"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.":"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.",n([]),new Error("It doesn't look like you have permission to list peers IDs. "+t)}n(200!==e.status?[]:JSON.parse(e.responseText))}},e.send(null)},r.exports=t},{"./dataconnection":2,"./mediaconnection":4,"./socket":7,"./util":8,eventemitter3:9}],7:[function(n,r,e){function t(n,r,e,i,o){if(!(this instanceof t))return new t(n,r,e,i,o);a.call(this),this.disconnected=!1,this._queue=[];var s=n?"https://":"http://",l=n?"wss://":"ws://";this._httpUrl=s+r+":"+e+i+o,this._wsUrl=l+r+":"+e+i+"peerjs?key="+o}var i=n("./util"),a=n("eventemitter3");i.inherits(t,a),t.prototype.start=function(n,r){this.id=n,this._httpUrl+="/"+n+"/"+r,this._wsUrl+="&id="+n+"&token="+r,this._startXhrStream(),this._startWebSocket()},t.prototype._startWebSocket=function(n){var r=this;this._socket||(this._socket=new WebSocket(this._wsUrl),this._socket.onmessage=function(n){try{var e=JSON.parse(n.data)}catch(t){return void i.log("Invalid server message",n.data)}r.emit("message",e)},this._socket.onclose=function(n){i.log("Socket closed."),r.disconnected=!0,r.emit("disconnected")},this._socket.onopen=function(){r._timeout&&(clearTimeout(r._timeout),setTimeout(function(){r._http.abort(),r._http=null},5e3)),r._sendQueuedMessages(),i.log("Socket open")})},t.prototype._startXhrStream=function(n){try{var r=this;this._http=new XMLHttpRequest,this._http._index=1,this._http._streamIndex=n||0,this._http.open("post",this._httpUrl+"/id?i="+this._http._streamIndex,!0),this._http.onerror=function(){clearTimeout(r._timeout),r.emit("disconnected")},this._http.onreadystatechange=function(){2==this.readyState&&this.old?(this.old.abort(),delete this.old):this.readyState>2&&200===this.status&&this.responseText&&r._handleStream(this)},this._http.send(null),this._setHTTPTimeout()}catch(e){i.log("XMLHttpRequest not available; defaulting to WebSockets")}},t.prototype._handleStream=function(n){var r=n.responseText.split("\n");if(n._buffer)for(;n._buffer.length>0;){var e=n._buffer.shift(),t=r[e];try{t=JSON.parse(t)}catch(a){n._buffer.shift(e);break}this.emit("message",t)}var o=r[n._index];if(o)if(n._index+=1,n._index===r.length)n._buffer||(n._buffer=[]),n._buffer.push(n._index-1);else{try{o=JSON.parse(o)}catch(a){return void i.log("Invalid server message",o)}this.emit("message",o)}},t.prototype._setHTTPTimeout=function(){var n=this;this._timeout=setTimeout(function(){var r=n._http;n._wsOpen()?r.abort():(n._startXhrStream(r._streamIndex+1),n._http.old=r)},25e3)},t.prototype._wsOpen=function(){return this._socket&&1==this._socket.readyState},t.prototype._sendQueuedMessages=function(){for(var n=0,r=this._queue.length;r>n;n+=1)this.send(this._queue[n])},t.prototype.send=function(n){if(!this.disconnected){if(!this.id)return void this._queue.push(n);if(!n.type)return void this.emit("error","Invalid message");var r=JSON.stringify(n);if(this._wsOpen())this._socket.send(r);else{var e=new XMLHttpRequest,t=this._httpUrl+"/"+n.type.toLowerCase();e.open("post",t,!0),e.setRequestHeader("Content-Type","application/json"),e.send(r)}}},t.prototype.close=function(){!this.disconnected&&this._wsOpen()&&(this._socket.close(),this.disconnected=!0)},r.exports=t},{"./util":8,eventemitter3:9}],8:[function(n,r,e){var t={iceServers:[{url:"stun:stun.l.google.com:19302"}]},i=1,a=n("js-binarypack"),o=n("./adapter").RTCPeerConnection,s={noop:function(){},CLOUD_HOST:"0.peerjs.com",CLOUD_PORT:9e3,chunkedBrowsers:{Chrome:1},chunkedMTU:16300,logLevel:0,setLogLevel:function(n){var r=parseInt(n,10);isNaN(parseInt(n,10))?s.logLevel=n?3:0:s.logLevel=r,s.log=s.warn=s.error=s.noop,s.logLevel>0&&(s.error=s._printWith("ERROR")),s.logLevel>1&&(s.warn=s._printWith("WARNING")),s.logLevel>2&&(s.log=s._print)},setLogFunction:function(n){n.constructor!==Function?s.warn("The log function you passed in is not a function. Defaulting to regular logs."):s._print=n},_printWith:function(n){return function(){var r=Array.prototype.slice.call(arguments);r.unshift(n),s._print.apply(s,r)}},_print:function(){var n=!1,r=Array.prototype.slice.call(arguments);r.unshift("PeerJS: ");for(var e=0,t=r.length;t>e;e++)r[e]instanceof Error&&(r[e]="("+r[e].name+") "+r[e].message,n=!0);n?console.error.apply(console,r):console.log.apply(console,r)},defaultConfig:t,browser:function(){return window.mozRTCPeerConnection?"Firefox":window.webkitRTCPeerConnection?"Chrome":window.RTCPeerConnection?"Supported":"Unsupported"}(),supports:function(){if("undefined"==typeof o)return{};var n,r,e=!0,i=!0,a=!1,l=!1,c=!!window.webkitRTCPeerConnection;try{n=new o(t,{optional:[{RtpDataChannels:!0}]})}catch(u){e=!1,i=!1}if(e)try{r=n.createDataChannel("_PEERJSTEST")}catch(u){e=!1}if(e){try{r.binaryType="blob",a=!0}catch(u){}var h=new o(t,{});try{var d=h.createDataChannel("_PEERJSRELIABLETEST",{});l=d.reliable}catch(u){}h.close()}if(i&&(i=!!n.addStream),!c&&e){var p=new o(t,{optional:[{RtpDataChannels:!0}]});p.onnegotiationneeded=function(){c=!0,s&&s.supports&&(s.supports.onnegotiationneeded=!0)},p.createDataChannel("_PEERJSNEGOTIATIONTEST"),setTimeout(function(){p.close()},1e3)}return n&&n.close(),{audioVideo:i,data:e,binaryBlob:a,binary:l,reliable:l,sctp:l,onnegotiationneeded:c}}(),validateId:function(n){return!n||/^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(n)},validateKey:function(n){return!n||/^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(n)},debug:!1,inherits:function(n,r){n.super_=r,n.prototype=Object.create(r.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}})},extend:function(n,r){for(var e in r)r.hasOwnProperty(e)&&(n[e]=r[e]);return n},pack:a.pack,unpack:a.unpack,log:function(){if(s.debug){var n=!1,r=Array.prototype.slice.call(arguments);r.unshift("PeerJS: ");for(var e=0,t=r.length;t>e;e++)r[e]instanceof Error&&(r[e]="("+r[e].name+") "+r[e].message,n=!0);n?console.error.apply(console,r):console.log.apply(console,r)}},setZeroTimeout:function(n){function r(r){t.push(r),n.postMessage(i,"*")}function e(r){r.source==n&&r.data==i&&(r.stopPropagation&&r.stopPropagation(),t.length&&t.shift()())}var t=[],i="zero-timeout-message";return n.addEventListener?n.addEventListener("message",e,!0):n.attachEvent&&n.attachEvent("onmessage",e),r}(window),chunk:function(n){for(var r=[],e=n.size,t=index=0,a=Math.ceil(e/s.chunkedMTU);e>t;){var o=Math.min(e,t+s.chunkedMTU),l=n.slice(t,o),c={__peerData:i,n:index,data:l,total:a};r.push(c),t=o,index+=1}return i+=1,r},blobToArrayBuffer:function(n,r){var e=new FileReader;e.onload=function(n){r(n.target.result)},e.readAsArrayBuffer(n)},blobToBinaryString:function(n,r){var e=new FileReader;e.onload=function(n){r(n.target.result)},e.readAsBinaryString(n)},binaryStringToArrayBuffer:function(n){for(var r=new Uint8Array(n.length),e=0;e<n.length;e++)r[e]=255&n.charCodeAt(e);return r.buffer},randomToken:function(){return Math.random().toString(36).substr(2)},isSecure:function(){return"https:"===location.protocol}};r.exports=s},{"./adapter":1,"js-binarypack":10}],9:[function(n,r,e){"use strict";function t(n,r,e){this.fn=n,this.context=r,this.once=e||!1}function i(){}i.prototype._events=void 0,i.prototype.listeners=function(n){if(!this._events||!this._events[n])return[];for(var r=0,e=this._events[n].length,t=[];e>r;r++)t.push(this._events[n][r].fn);return t},i.prototype.emit=function(n,r,e,t,i,a){if(!this._events||!this._events[n])return!1;var o,s,l,c=this._events[n],u=c.length,h=arguments.length,d=c[0];if(1===u){switch(d.once&&this.removeListener(n,d.fn,!0),h){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,r),!0;case 3:return d.fn.call(d.context,r,e),!0;case 4:return d.fn.call(d.context,r,e,t),!0;case 5:return d.fn.call(d.context,r,e,t,i),!0;case 6:return d.fn.call(d.context,r,e,t,i,a),!0}for(s=1,o=new Array(h-1);h>s;s++)o[s-1]=arguments[s];d.fn.apply(d.context,o)}else for(s=0;u>s;s++)switch(c[s].once&&this.removeListener(n,c[s].fn,!0),h){case 1:c[s].fn.call(c[s].context);break;case 2:c[s].fn.call(c[s].context,r);break;case 3:c[s].fn.call(c[s].context,r,e);break;default:if(!o)for(l=1,o=new Array(h-1);h>l;l++)o[l-1]=arguments[l];c[s].fn.apply(c[s].context,o)}return!0},i.prototype.on=function(n,r,e){return this._events||(this._events={}),this._events[n]||(this._events[n]=[]),this._events[n].push(new t(r,e||this)),this},i.prototype.once=function(n,r,e){return this._events||(this._events={}),this._events[n]||(this._events[n]=[]),this._events[n].push(new t(r,e||this,!0)),this},i.prototype.removeListener=function(n,r,e){if(!this._events||!this._events[n])return this;var t=this._events[n],i=[];if(r)for(var a=0,o=t.length;o>a;a++)t[a].fn!==r&&t[a].once!==e&&i.push(t[a]);return i.length?this._events[n]=i:this._events[n]=null,this},i.prototype.removeAllListeners=function(n){return this._events?(n?this._events[n]=null:this._events={},this):this},i.prototype.off=i.prototype.removeListener,i.prototype.addListener=i.prototype.on,i.prototype.setMaxListeners=function(){return this},i.EventEmitter=i,i.EventEmitter2=i,i.EventEmitter3=i,"object"==typeof r&&r.exports&&(r.exports=i)},{}],10:[function(n,r,e){function t(n){this.index=0,this.dataBuffer=n,this.dataView=new Uint8Array(this.dataBuffer),this.length=this.dataBuffer.byteLength}function i(){this.bufferBuilder=new s}function a(n){var r=n.charCodeAt(0);return 2047>=r?"00":65535>=r?"000":2097151>=r?"0000":67108863>=r?"00000":"000000"}function o(n){return n.length>600?new Blob([n]).size:n.replace(/[^\u0000-\u007F]/g,a).length}var s=n("./bufferbuilder").BufferBuilder,l=n("./bufferbuilder").binaryFeatures,c={unpack:function(n){var r=new t(n);return r.unpack()},pack:function(n){var r=new i;r.pack(n);var e=r.getBuffer();return e}};r.exports=c,t.prototype.unpack=function(){var n=this.unpack_uint8();if(128>n){var r=n;return r}if(32>(224^n)){var e=(224^n)-32;return e}var t;if((t=160^n)<=15)return this.unpack_raw(t);if((t=176^n)<=15)return this.unpack_string(t);if((t=144^n)<=15)return this.unpack_array(t);if((t=128^n)<=15)return this.unpack_map(t);switch(n){case 192:return null;case 193:return;case 194:return!1;case 195:return!0;case 202:return this.unpack_float();case 203:return this.unpack_double();case 204:return this.unpack_uint8();case 205:return this.unpack_uint16();case 206:return this.unpack_uint32();case 207:return this.unpack_uint64();case 208:return this.unpack_int8();case 209:return this.unpack_int16();case 210:return this.unpack_int32();case 211:return this.unpack_int64();case 212:return;case 213:return;case 214:return;case 215:return;case 216:return t=this.unpack_uint16(),this.unpack_string(t);case 217:return t=this.unpack_uint32(),this.unpack_string(t);case 218:return t=this.unpack_uint16(),this.unpack_raw(t);case 219:return t=this.unpack_uint32(),this.unpack_raw(t);case 220:return t=this.unpack_uint16(),this.unpack_array(t);case 221:return t=this.unpack_uint32(),this.unpack_array(t);case 222:return t=this.unpack_uint16(),this.unpack_map(t);case 223:return t=this.unpack_uint32(),this.unpack_map(t)}},t.prototype.unpack_uint8=function(){var n=255&this.dataView[this.index];return this.index++,n},t.prototype.unpack_uint16=function(){var n=this.read(2),r=256*(255&n[0])+(255&n[1]);return this.index+=2,r},t.prototype.unpack_uint32=function(){var n=this.read(4),r=256*(256*(256*n[0]+n[1])+n[2])+n[3];return this.index+=4,r},t.prototype.unpack_uint64=function(){var n=this.read(8),r=256*(256*(256*(256*(256*(256*(256*n[0]+n[1])+n[2])+n[3])+n[4])+n[5])+n[6])+n[7];return this.index+=8,r},t.prototype.unpack_int8=function(){var n=this.unpack_uint8();return 128>n?n:n-256},t.prototype.unpack_int16=function(){var n=this.unpack_uint16();return 32768>n?n:n-65536},t.prototype.unpack_int32=function(){var n=this.unpack_uint32();return n<Math.pow(2,31)?n:n-Math.pow(2,32)},t.prototype.unpack_int64=function(){var n=this.unpack_uint64();return n<Math.pow(2,63)?n:n-Math.pow(2,64)},t.prototype.unpack_raw=function(n){if(this.length<this.index+n)throw new Error("BinaryPackFailure: index is out of range "+this.index+" "+n+" "+this.length);var r=this.dataBuffer.slice(this.index,this.index+n);return this.index+=n,r},t.prototype.unpack_string=function(n){for(var r,e,t=this.read(n),i=0,a="";n>i;)r=t[i],128>r?(a+=String.fromCharCode(r),i++):32>(192^r)?(e=(192^r)<<6|63&t[i+1],a+=String.fromCharCode(e),i+=2):(e=(15&r)<<12|(63&t[i+1])<<6|63&t[i+2],a+=String.fromCharCode(e),i+=3);return this.index+=n,a},t.prototype.unpack_array=function(n){for(var r=new Array(n),e=0;n>e;e++)r[e]=this.unpack();return r},t.prototype.unpack_map=function(n){for(var r={},e=0;n>e;e++){var t=this.unpack(),i=this.unpack();r[t]=i}return r},t.prototype.unpack_float=function(){var n=this.unpack_uint32(),r=n>>31,e=(n>>23&255)-127,t=8388607&n|8388608;return(0==r?1:-1)*t*Math.pow(2,e-23)},t.prototype.unpack_double=function(){var n=this.unpack_uint32(),r=this.unpack_uint32(),e=n>>31,t=(n>>20&2047)-1023,i=1048575&n|1048576,a=i*Math.pow(2,t-20)+r*Math.pow(2,t-52);return(0==e?1:-1)*a},t.prototype.read=function(n){var r=this.index;if(r+n<=this.length)return this.dataView.subarray(r,r+n);throw new Error("BinaryPackFailure: read index out of range")},i.prototype.getBuffer=function(){return this.bufferBuilder.getBuffer()},i.prototype.pack=function(n){var r=typeof n;if("string"==r)this.pack_string(n);else if("number"==r)Math.floor(n)===n?this.pack_integer(n):this.pack_double(n);else if("boolean"==r)n===!0?this.bufferBuilder.append(195):n===!1&&this.bufferBuilder.append(194);else if("undefined"==r)this.bufferBuilder.append(192);else{if("object"!=r)throw new Error('Type "'+r+'" not yet supported');if(null===n)this.bufferBuilder.append(192);else{var e=n.constructor;if(e==Array)this.pack_array(n);else if(e==Blob||e==File)this.pack_bin(n);else if(e==ArrayBuffer)l.useArrayBufferView?this.pack_bin(new Uint8Array(n)):this.pack_bin(n);else if("BYTES_PER_ELEMENT"in n)l.useArrayBufferView?this.pack_bin(new Uint8Array(n.buffer)):this.pack_bin(n.buffer);else if(e==Object)this.pack_object(n);else if(e==Date)this.pack_string(n.toString());else{if("function"!=typeof n.toBinaryPack)throw new Error('Type "'+e.toString()+'" not yet supported');this.bufferBuilder.append(n.toBinaryPack())}}}this.bufferBuilder.flush()},i.prototype.pack_bin=function(n){var r=n.length||n.byteLength||n.size;if(15>=r)this.pack_uint8(160+r);else if(65535>=r)this.bufferBuilder.append(218),this.pack_uint16(r);else{if(!(4294967295>=r))throw new Error("Invalid length");this.bufferBuilder.append(219),this.pack_uint32(r)}this.bufferBuilder.append(n)},i.prototype.pack_string=function(n){var r=o(n);if(15>=r)this.pack_uint8(176+r);else if(65535>=r)this.bufferBuilder.append(216),this.pack_uint16(r);else{if(!(4294967295>=r))throw new Error("Invalid length");this.bufferBuilder.append(217),this.pack_uint32(r)}this.bufferBuilder.append(n)},i.prototype.pack_array=function(n){var r=n.length;if(15>=r)this.pack_uint8(144+r);else if(65535>=r)this.bufferBuilder.append(220),this.pack_uint16(r);else{if(!(4294967295>=r))throw new Error("Invalid length");this.bufferBuilder.append(221),this.pack_uint32(r)}for(var e=0;r>e;e++)this.pack(n[e])},i.prototype.pack_integer=function(n){if(n>=-32&&127>=n)this.bufferBuilder.append(255&n);else if(n>=0&&255>=n)this.bufferBuilder.append(204),this.pack_uint8(n);else if(n>=-128&&127>=n)this.bufferBuilder.append(208),this.pack_int8(n);else if(n>=0&&65535>=n)this.bufferBuilder.append(205),this.pack_uint16(n);else if(n>=-32768&&32767>=n)this.bufferBuilder.append(209),this.pack_int16(n);else if(n>=0&&4294967295>=n)this.bufferBuilder.append(206),this.pack_uint32(n);else if(n>=-2147483648&&2147483647>=n)this.bufferBuilder.append(210),this.pack_int32(n);else if(n>=-0x8000000000000000&&0x8000000000000000>=n)this.bufferBuilder.append(211),this.pack_int64(n);else{if(!(n>=0&&0x10000000000000000>=n))throw new Error("Invalid integer");this.bufferBuilder.append(207),this.pack_uint64(n)}},i.prototype.pack_double=function(n){var r=0;0>n&&(r=1,n=-n);var e=Math.floor(Math.log(n)/Math.LN2),t=n/Math.pow(2,e)-1,i=Math.floor(t*Math.pow(2,52)),a=Math.pow(2,32),o=r<<31|e+1023<<20|i/a&1048575,s=i%a;this.bufferBuilder.append(203),this.pack_int32(o),this.pack_int32(s)},i.prototype.pack_object=function(n){var r=Object.keys(n),e=r.length;if(15>=e)this.pack_uint8(128+e);else if(65535>=e)this.bufferBuilder.append(222),this.pack_uint16(e);else{if(!(4294967295>=e))throw new Error("Invalid length");this.bufferBuilder.append(223),this.pack_uint32(e)}for(var t in n)n.hasOwnProperty(t)&&(this.pack(t),this.pack(n[t]))},i.prototype.pack_uint8=function(n){this.bufferBuilder.append(n)},i.prototype.pack_uint16=function(n){this.bufferBuilder.append(n>>8),this.bufferBuilder.append(255&n)},i.prototype.pack_uint32=function(n){var r=4294967295&n;this.bufferBuilder.append((4278190080&r)>>>24),this.bufferBuilder.append((16711680&r)>>>16),this.bufferBuilder.append((65280&r)>>>8),this.bufferBuilder.append(255&r)},i.prototype.pack_uint64=function(n){var r=n/Math.pow(2,32),e=n%Math.pow(2,32);this.bufferBuilder.append((4278190080&r)>>>24),this.bufferBuilder.append((16711680&r)>>>16),this.bufferBuilder.append((65280&r)>>>8),this.bufferBuilder.append(255&r),this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e)},i.prototype.pack_int8=function(n){this.bufferBuilder.append(255&n)},i.prototype.pack_int16=function(n){this.bufferBuilder.append((65280&n)>>8),this.bufferBuilder.append(255&n)},i.prototype.pack_int32=function(n){this.bufferBuilder.append(n>>>24&255),this.bufferBuilder.append((16711680&n)>>>16),this.bufferBuilder.append((65280&n)>>>8),this.bufferBuilder.append(255&n)},i.prototype.pack_int64=function(n){var r=Math.floor(n/Math.pow(2,32)),e=n%Math.pow(2,32);this.bufferBuilder.append((4278190080&r)>>>24),this.bufferBuilder.append((16711680&r)>>>16),this.bufferBuilder.append((65280&r)>>>8),this.bufferBuilder.append(255&r),this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e)}},{"./bufferbuilder":11}],11:[function(n,r,e){function t(){this._pieces=[],this._parts=[]}var i={};i.useBlobBuilder=function(){try{return new Blob([]),!1}catch(n){return!0}}(),i.useArrayBufferView=!i.useBlobBuilder&&function(){try{return 0===new Blob([new Uint8Array([])]).size}catch(n){return!0}}(),r.exports.binaryFeatures=i;var a=r.exports.BlobBuilder;"undefined"!=typeof window&&(a=r.exports.BlobBuilder=window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder||window.BlobBuilder),t.prototype.append=function(n){"number"==typeof n?this._pieces.push(n):(this.flush(),this._parts.push(n))},t.prototype.flush=function(){if(this._pieces.length>0){var n=new Uint8Array(this._pieces);i.useArrayBufferView||(n=n.buffer),this._parts.push(n),this._pieces=[]}},t.prototype.getBuffer=function(){if(this.flush(),i.useBlobBuilder){for(var n=new a,r=0,e=this._parts.length;e>r;r++)n.append(this._parts[r]);return n.getBlob()}return new Blob(this._parts)},r.exports.BufferBuilder=t},{}],12:[function(n,r,e){function t(n,r){return this instanceof t?(this._dc=n,i.debug=r,this._outgoing={},this._incoming={},this._received={},this._window=1e3,this._mtu=500,this._interval=0,this._count=0,this._queue=[],void this._setupDC()):new t(n)}var i=n("./util");t.prototype.send=function(n){var r=i.pack(n);return r.size<this._mtu?void this._handleSend(["no",r]):(this._outgoing[this._count]={ack:0,chunks:this._chunk(r)},i.debug&&(this._outgoing[this._count].timer=new Date),this._sendWindowedChunks(this._count),void(this._count+=1))},t.prototype._setupInterval=function(){var n=this;this._timeout=setInterval(function(){var r=n._queue.shift();if(r._multiple)for(var e=0,t=r.length;t>e;e+=1)n._intervalSend(r[e]);else n._intervalSend(r)},this._interval)},t.prototype._intervalSend=function(n){var r=this;n=i.pack(n),i.blobToBinaryString(n,function(n){r._dc.send(n)}),0===r._queue.length&&(clearTimeout(r._timeout),r._timeout=null)},t.prototype._processAcks=function(){for(var n in this._outgoing)this._outgoing.hasOwnProperty(n)&&this._sendWindowedChunks(n)},t.prototype._handleSend=function(n){for(var r=!0,e=0,t=this._queue.length;t>e;e+=1){var i=this._queue[e];i===n?r=!1:i._multiple&&-1!==i.indexOf(n)&&(r=!1)}r&&(this._queue.push(n),this._timeout||this._setupInterval())},t.prototype._setupDC=function(){var n=this;this._dc.onmessage=function(r){var e=r.data,t=e.constructor;if(t===String){var a=i.binaryStringToArrayBuffer(e);e=i.unpack(a),n._handleMessage(e)}}},t.prototype._handleMessage=function(n){var r,e=n[1],t=this._incoming[e],a=this._outgoing[e];switch(n[0]){case"no":var o=e;o&&this.onmessage(i.unpack(o));break;case"end":if(r=t,this._received[e]=n[2],!r)break;this._ack(e);break;case"ack":if(r=a){var s=n[2];r.ack=Math.max(s,r.ack),r.ack>=r.chunks.length?(i.log("Time: ",new Date-r.timer),delete this._outgoing[e]):this._processAcks()}break;case"chunk":if(r=t,!r){var l=this._received[e];if(l===!0)break;r={ack:["ack",e,0],chunks:[]},this._incoming[e]=r}var c=n[2],u=n[3];r.chunks[c]=new Uint8Array(u),c===r.ack[2]&&this._calculateNextAck(e),this._ack(e);break;default:this._handleSend(n)}},t.prototype._chunk=function(n){for(var r=[],e=n.size,t=0;e>t;){var a=Math.min(e,t+this._mtu),o=n.slice(t,a),s={payload:o};r.push(s),t=a}return i.log("Created",r.length,"chunks."),r},t.prototype._ack=function(n){var r=this._incoming[n].ack;this._received[n]===r[2]&&(this._complete(n),this._received[n]=!0),this._handleSend(r)},t.prototype._calculateNextAck=function(n){for(var r=this._incoming[n],e=r.chunks,t=0,i=e.length;i>t;t+=1)if(void 0===e[t])return void(r.ack[2]=t);r.ack[2]=e.length},t.prototype._sendWindowedChunks=function(n){i.log("sendWindowedChunks for: ",n);for(var r=this._outgoing[n],e=r.chunks,t=[],a=Math.min(r.ack+this._window,e.length),o=r.ack;a>o;o+=1)e[o].sent&&o!==r.ack||(e[o].sent=!0,t.push(["chunk",n,o,e[o].payload]));r.ack+this._window>=e.length&&t.push(["end",n,e.length]),t._multiple=!0,this._handleSend(t)},t.prototype._complete=function(n){i.log("Completed called for",n);var r=this,e=this._incoming[n].chunks,t=new Blob(e);i.blobToArrayBuffer(t,function(n){r.onmessage(i.unpack(n))}),delete this._incoming[n]},t.higherBandwidthSDP=function(n){var r=navigator.appVersion.match(/Chrome\/(.*?) /);if(r&&(r=parseInt(r[1].split(".").shift()),31>r)){var e=n.split("b=AS:30"),t="b=AS:102400";if(e.length>1)return e[0]+t+e[1]}return n},t.prototype.onmessage=function(n){},r.exports.Reliable=t},{"./util":13}],13:[function(n,r,e){var t=n("js-binarypack"),i={debug:!1,inherits:function(n,r){n.super_=r,n.prototype=Object.create(r.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}})},extend:function(n,r){for(var e in r)r.hasOwnProperty(e)&&(n[e]=r[e]);return n},pack:t.pack,unpack:t.unpack,log:function(){if(i.debug){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];n.unshift("Reliable: "),console.log.apply(console,n)}},setZeroTimeout:function(n){function r(r){t.push(r),n.postMessage(i,"*")}function e(r){r.source==n&&r.data==i&&(r.stopPropagation&&r.stopPropagation(),t.length&&t.shift()())}var t=[],i="zero-timeout-message";return n.addEventListener?n.addEventListener("message",e,!0):n.attachEvent&&n.attachEvent("onmessage",e),r}(this),blobToArrayBuffer:function(n,r){var e=new FileReader;e.onload=function(n){r(n.target.result)},e.readAsArrayBuffer(n)},blobToBinaryString:function(n,r){var e=new FileReader;e.onload=function(n){r(n.target.result)},e.readAsBinaryString(n)},binaryStringToArrayBuffer:function(n){for(var r=new Uint8Array(n.length),e=0;e<n.length;e++)r[e]=255&n.charCodeAt(e);return r.buffer},randomToken:function(){return Math.random().toString(36).substr(2)}};r.exports=i},{"js-binarypack":10}]},{},[3]);var Stats=function(){function n(n,r,e){return n=document.createElement(n),n.id=r,n.style.cssText=e,n}function r(r,e,t){var i=n("div",r,"padding:0 0 3px 3px;text-align:left;background:"+t),a=n("div",r+"Text","font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px;color:"+e);for(a.innerHTML=r.toUpperCase(),i.appendChild(a),r=n("div",r+"Graph","width:74px;height:30px;background:"+e),i.appendChild(r),e=0;74>e;e++)r.appendChild(n("span","","width:1px;height:30px;float:left;opacity:0.9;background:"+t));return i}function e(n){for(var r=c.children,e=0;e<r.length;e++)r[e].style.display=e===n?"block":"none";l=n}function t(n,r){n.appendChild(n.firstChild).style.height=Math.min(30,30-30*r)+"px"}var i=self.performance&&self.performance.now?self.performance.now.bind(performance):Date.now,a=i(),o=a,s=0,l=0,c=n("div","stats","width:80px;opacity:0.9;cursor:pointer");c.addEventListener("mousedown",function(n){n.preventDefault(),e(++l%c.children.length)},!1);var u=0,h=1/0,d=0,p=r("fps","#0ff","#002"),f=p.children[0],m=p.children[1];c.appendChild(p);var g=0,v=1/0,y=0,p=r("ms","#0f0","#020"),E=p.children[0],b=p.children[1];if(c.appendChild(p),self.performance&&self.performance.memory){var x=0,T=1/0,_=0,p=r("mb","#f08","#201"),w=p.children[0],R=p.children[1];c.appendChild(p)}return e(l),{REVISION:14,domElement:c,setMode:e,begin:function(){a=i()},end:function(){var n=i();if(g=n-a,v=Math.min(v,g),y=Math.max(y,g),E.textContent=(0|g)+" MS ("+(0|v)+"-"+(0|y)+")",t(b,g/200),s++,n>o+1e3&&(u=Math.round(1e3*s/(n-o)),h=Math.min(h,u),d=Math.max(d,u),f.textContent=u+" FPS ("+h+"-"+d+")",t(m,u/100),o=n,s=0,void 0!==x)){var r=performance.memory.usedJSHeapSize,e=performance.memory.jsHeapSizeLimit;x=Math.round(9.54e-7*r),T=Math.min(T,x),_=Math.max(_,x),w.textContent=x+" MB ("+T+"-"+_+")",t(R,r/e)}return n},update:function(){a=this.end()}}};"object"==typeof module&&(module.exports=Stats);var SHADER_LOADER=SHADER_LOADER||{};SHADER_LOADER.load=function(n){var r,e,t,i=function(){0>=c&&n&&n(o)},a=function(n,r){var e=function(n,e){--c,o[s]||(o[s]={vertex:"",fragment:""}),o[s][r]=n.responseText,i()},t=$(n),a=t.data("src"),s=t.data("name");$.ajax({url:a,dataType:"text",context:{name:s,type:r},complete:e})},o={},s=$('script[type="x-shader/x-vertex"]'),l=$('script[type="x-shader/x-fragment"]'),c=s.length+l.length;for(e=0,t=s.length;t>e;++e)r=s[e],a(r,"vertex");for(e=0,t=l.length;t>e;++e)r=l[e],a(r,"fragment");i()}(function(n){function r(t){if(e[t])return e[t].exports;var i=e[t]={exports:{},id:t,loaded:!1};return n[t].call(i.exports,i,i.exports,r),i.loaded=!0,i.exports}var e={};return r.m=n,r.c=e,r.p="",r(0)})([function(module,exports,__webpack_require__){eval("(function () {\n	'use strict';\n\n	//global-ish declarations\n	var VR,\n		NoSleep = __webpack_require__(1).NoSleep,\n		isMobile = __webpack_require__(2);\n\n	function initRequirements() {\n		//load styles\n		__webpack_require__(3);\n\n		VR = __webpack_require__(7);\n	}\n\n	function initUI() {\n		var container,\n			enableFullscreen,\n			disableFullscreen,\n			vrButton,\n			orientationButton,\n			element,\n\n			noSleep = new NoSleep(),\n\n			fullScreenElement = document.body,\n\n			fullscreenEnabled = document.fullscreenEnabled ||\n				document.webkitFullscreenEnabled ||\n				document.mozFullScreenEnabled ||\n				document.msFullscreenEnabled,\n\n			requestFullscreen = fullScreenElement.webkitRequestFullscreen ||\n				fullScreenElement.mozRequestFullScreen ||\n				fullScreenElement.msRequestFullscreen;\n\n		function svgButton(source, id) {\n			var span = document.createElement('span'),\n				svg;\n\n			span.innerHTML = source;\n			span.id = id;\n\n			svg = span.firstChild;\n			svg.setAttribute('width', 18);\n			svg.setAttribute('height', 18);\n\n			container.appendChild(span);\n\n			return span;\n		}\n\n		function toggleOrientation() {\n			if (VR.orientationEnabled()) {\n				VR.disableOrientation();\n			} else {\n				VR.enableOrientation();\n			}\n		}\n\n		function deviceChange() {\n			if (VR.controlMode()) {\n				vrButton.classList.remove('unsupported');\n				orientationButton.classList.remove('unsupported');\n			}\n\n			//todo: enable this\n			//info.innerHTML = hmd && hmd.deviceName ? 'HMD: ' + hmd.deviceName : '';\n			//info.className = hmd && hmd.deviceId !== 'debug-0' ? 'has-hmd' : '';\n		}\n\n		//set up meta viewport tag for mobile devices\n		element = document.createElement('meta');\n		element.setAttribute('name', 'viewport');\n		element.setAttribute('content', 'width=device-width, initial-scale=1, user-scalable=no');\n		document.head.appendChild(element);\n\n		container = document.createElement('div');\n		container.id = 'buttons';\n		document.body.appendChild(container);\n\n		//todo: use icons instead of text\n		if (requestFullscreen && fullscreenEnabled) {\n			enableFullscreen = svgButton(__webpack_require__(82), 'fs-enable');\n			enableFullscreen.setAttribute('title', 'Enable Full Screen');\n			enableFullscreen.addEventListener('click', requestFullscreen.bind(fullScreenElement), false);\n\n			disableFullscreen = svgButton(__webpack_require__(83), 'fs-disable');\n			disableFullscreen.setAttribute('title', 'Exit Full Screen');\n			disableFullscreen.addEventListener('click', VR.exitFullscreen, false);\n		}\n\n		VR.on('fullscreenchange', function () {\n			if (VR.isFullscreen()) {\n				disableFullscreen.style.display = 'inline-block';\n				enableFullscreen.style.display = 'none';\n			} else {\n				disableFullscreen.style.display = '';\n				enableFullscreen.style.display = '';\n			}\n\n			//disable sleep on mobile devices in VR mode\n			if (VR.vrMode()) {\n				noSleep.enable();\n			} else {\n				noSleep.disable();\n			}\n		});\n\n		vrButton = svgButton(__webpack_require__(84), 'vr');\n		vrButton.setAttribute('title', 'Toggle Virtual Reality');\n		vrButton.className = 'unsupported';\n		vrButton.addEventListener('click', VR.requestVR, false);\n\n		orientationButton = svgButton(__webpack_require__(85), 'orientation-button');\n		orientationButton.setAttribute('title', 'Toggle Orientation');\n		orientationButton.className = 'unsupported';\n		orientationButton.addEventListener('click', toggleOrientation, false);\n\n		//report on HMD\n		VR.on('devicechange', deviceChange);\n		deviceChange();\n\n		//keyboard shortcuts for making life a little easier\n		window.addEventListener('keydown', function (evt) {\n			if (evt.keyCode === 'Z'.charCodeAt(0)) {\n				VR.zeroSensor();\n			} else if (evt.keyCode === 'O'.charCodeAt(0)) {\n				VR.enableOrientation();\n			} else if (evt.keyCode === 13) {\n				VR.requestVR();\n			}\n		}, false);\n\n		VR.resize();\n	}\n\n	function initialize() {\n		initRequirements();\n\n		//todo: set up button/info elements\n\n		VR.init();\n\n		if (document.body) {\n			initUI();\n		} else {\n			window.addEventListener('load', initUI, false);\n		}\n\n		window.addEventListener('resize', VR.resize, false);\n\n		if (!isMobile.any) {\n			VR.disableOrientation();\n		}\n\n		/*\n		export global things\n		*/\n		window.VR = VR;\n		window.THREE = VR.THREE;\n	}\n\n	initialize();\n	VR.start();\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/entry.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/entry.js?")},function(module,exports){eval('/**\n * NoSleep.js v0.5.0 - git.io/vfn01\n * Rich Tibbett\n * MIT license\n **/\n(function(root) {\n  // UA matching\n  var ua = {\n    Android: /Android/ig.test(navigator.userAgent),\n    iOS: /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n  };\n\n  var media = {\n    WebM: "data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=",\n    MP4: "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=="\n  };\n\n  function addSourceToVideo(element, type, dataURI) {\n    var source = document.createElement(\'source\');\n    source.src = dataURI;\n    source.type = "video/" + type;\n    element.appendChild(source);\n  }\n\n  // NoSleep instance constructor\n  var NoSleep = function() {\n    if (ua.iOS) {\n      this.noSleepTimer = null;\n    } else if (ua.Android) {\n      // Set up no sleep video element\n      this.noSleepVideo = document.createElement(\'video\');\n      this.noSleepVideo.setAttribute("loop", "");\n\n      // Append nosleep video sources\n      addSourceToVideo(this.noSleepVideo, "webm", media.WebM);\n      addSourceToVideo(this.noSleepVideo, "mp4", media.MP4);\n    }\n\n    return this;\n  };\n\n  // Enable NoSleep instance\n  NoSleep.prototype.enable = function(duration) {\n    if (ua.iOS) {\n      this.disable();\n      this.noSleepTimer = window.setInterval(function() {\n        window.location = window.location;\n        window.setTimeout(window.stop, 0);\n      }, duration || 15000);\n    } else if (ua.Android) {\n      this.noSleepVideo.play();\n    }\n  };\n\n  // Disable NoSleep instance\n  NoSleep.prototype.disable = function() {\n    if (ua.iOS) {\n      if (this.noSleepTimer) {\n        window.clearInterval(this.noSleepTimer);\n        this.noSleepTimer = null;\n      }\n    } else if (ua.Android) {\n      this.noSleepVideo.pause();\n    }\n  };\n\n  // Append NoSleep API to root object\n  root.NoSleep = NoSleep;\n})(this);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/nosleep/NoSleep.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/nosleep/NoSleep.js?');
},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * isMobile.js v0.3.9\n *\n * A simple library to detect Apple phones and tablets,\n * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),\n * and any kind of seven inch device, via user agent sniffing.\n *\n * @author: Kai Mallea (kmallea@gmail.com)\n *\n * @license: http://creativecommons.org/publicdomain/zero/1.0/\n */\n(function (global) {\n\n    var apple_phone         = /iPhone/i,\n        apple_ipod          = /iPod/i,\n        apple_tablet        = /iPad/i,\n        android_phone       = /(?=.*\\bAndroid\\b)(?=.*\\bMobile\\b)/i, // Match 'Android' AND 'Mobile'\n        android_tablet      = /Android/i,\n        amazon_phone        = /(?=.*\\bAndroid\\b)(?=.*\\bSD4930UR\\b)/i,\n        amazon_tablet       = /(?=.*\\bAndroid\\b)(?=.*\\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\\b)/i,\n        windows_phone       = /IEMobile/i,\n        windows_tablet      = /(?=.*\\bWindows\\b)(?=.*\\bARM\\b)/i, // Match 'Windows' AND 'ARM'\n        other_blackberry    = /BlackBerry/i,\n        other_blackberry_10 = /BB10/i,\n        other_opera         = /Opera Mini/i,\n        other_chrome        = /(CriOS|Chrome)(?=.*\\bMobile\\b)/i,\n        other_firefox       = /(?=.*\\bFirefox\\b)(?=.*\\bMobile\\b)/i, // Match 'Firefox' AND 'Mobile'\n        seven_inch = new RegExp(\n            '(?:' +         // Non-capturing group\n\n            'Nexus 7' +     // Nexus 7\n\n            '|' +           // OR\n\n            'BNTV250' +     // B&N Nook Tablet 7 inch\n\n            '|' +           // OR\n\n            'Kindle Fire' + // Kindle Fire\n\n            '|' +           // OR\n\n            'Silk' +        // Kindle Fire, Silk Accelerated\n\n            '|' +           // OR\n\n            'GT-P1000' +    // Galaxy Tab 7 inch\n\n            ')',            // End non-capturing group\n\n            'i');           // Case-insensitive matching\n\n    var match = function(regex, userAgent) {\n        return regex.test(userAgent);\n    };\n\n    var IsMobileClass = function(userAgent) {\n        var ua = userAgent || navigator.userAgent;\n        // Facebook mobile app's integrated browser adds a bunch of strings that\n        // match everything. Strip it out if it exists.\n        var tmp = ua.split('[FBAN');\n        if (typeof tmp[1] !== 'undefined') {\n            ua = tmp[0];\n        }\n\n        this.apple = {\n            phone:  match(apple_phone, ua),\n            ipod:   match(apple_ipod, ua),\n            tablet: !match(apple_phone, ua) && match(apple_tablet, ua),\n            device: match(apple_phone, ua) || match(apple_ipod, ua) || match(apple_tablet, ua)\n        };\n        this.amazon = {\n            phone:  match(amazon_phone, ua),\n            tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),\n            device: match(amazon_phone, ua) || match(amazon_tablet, ua)\n        };\n        this.android = {\n            phone:  match(amazon_phone, ua) || match(android_phone, ua),\n            tablet: !match(amazon_phone, ua) && !match(android_phone, ua) && (match(amazon_tablet, ua) || match(android_tablet, ua)),\n            device: match(amazon_phone, ua) || match(amazon_tablet, ua) || match(android_phone, ua) || match(android_tablet, ua)\n        };\n        this.windows = {\n            phone:  match(windows_phone, ua),\n            tablet: match(windows_tablet, ua),\n            device: match(windows_phone, ua) || match(windows_tablet, ua)\n        };\n        this.other = {\n            blackberry:   match(other_blackberry, ua),\n            blackberry10: match(other_blackberry_10, ua),\n            opera:        match(other_opera, ua),\n            firefox:      match(other_firefox, ua),\n            chrome:       match(other_chrome, ua),\n            device:       match(other_blackberry, ua) || match(other_blackberry_10, ua) || match(other_opera, ua) || match(other_firefox, ua) || match(other_chrome, ua)\n        };\n        this.seven_inch = match(seven_inch, ua);\n        this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch;\n        // excludes 'other' devices and ipods, targeting touchscreen phones\n        this.phone = this.apple.phone || this.android.phone || this.windows.phone;\n        // excludes 7 inch devices, classifying as phone or tablet is left to the user\n        this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet;\n\n        if (typeof window === 'undefined') {\n            return this;\n        }\n    };\n\n    var instantiate = function() {\n        var IM = new IsMobileClass();\n        IM.Class = IsMobileClass;\n        return IM;\n    };\n\n    if (typeof module != 'undefined' && module.exports && typeof window === 'undefined') {\n        //node\n        module.exports = IsMobileClass;\n    } else if (typeof module != 'undefined' && module.exports && typeof window !== 'undefined') {\n        //browserify\n        module.exports = instantiate();\n    } else if (true) {\n        //AMD\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (global.isMobile = instantiate()), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        global.isMobile = instantiate();\n    }\n\n})(this);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ismobilejs/isMobile.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/ismobilejs/isMobile.js?")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(6)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n	// When the styles change, update the <style> tags\n	if(!content.locals) {\n		module.hot.accept(\"!!./../../node_modules/css-loader/index.js!./style.css\", function() {\n			var newContent = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\n			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n			update(newContent);\n		});\n	}\n	// When the module is disposed, remove the <style> tags\n	module.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader!./~/css-loader!./src/css/style.css\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/css/style.css?./~/style-loader!./~/css-loader")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(5)();\n// imports\n\n\n// module\nexports.push([module.id, "body {\\n\\tfont-family: \'Helvetica Neue\', Helvetica, Arial, sans-serif;\\n\\tcolor: #eee;\\n\\toverflow: hidden;\\n\\tbackground: rgb(40, 40, 40);\\n\\n\\theight: 100%;\\n\\twidth: 100%;\\n\\tmargin: 0px;\\n\\tpadding: 0px;\\n}\\n\\ncanvas {\\n\\twidth: 100% !important;\\n\\theight: 100% !important;\\n\\t/*position: absolute;*/\\n\\ttop: 0;\\n\\tleft: 0;\\n}\\n\\n#buttons {\\n\\tposition: absolute;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tpadding: 12px;\\n\\tmargin: 8px;\\n\\tborder-radius: 8px;\\n\\tbackground-color: rgba(128, 128, 128, 0.6);\\n}\\n\\n#buttons > * {\\n\\tmargin: 0 10px;\\n\\tdisplay: inline-block;\\n\\twidth: 18px;\\n\\theight: 18px;\\n\\tcursor: pointer;\\n}\\n\\n#buttons > *:first-child {\\n\\tmargin-left: 0;\\n}\\n\\n#buttons > .unsupported {\\n\\tdisplay: none;\\n}\\n\\n#fs-disable {\\n\\tdisplay: none;\\n}", ""]);\n\n// exports\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/style.css\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/css/style.css?./~/css-loader')},function(module,exports){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n	var list = [];\r\n\r\n	// return the list of modules as css string\r\n	list.toString = function toString() {\r\n		var result = [];\r\n		for(var i = 0; i < this.length; i++) {\r\n			var item = this[i];\r\n			if(item[2]) {\r\n				result.push("@media " + item[2] + "{" + item[1] + "}");\r\n			} else {\r\n				result.push(item[1]);\r\n			}\r\n		}\r\n		return result.join("");\r\n	};\r\n\r\n	// import a list of modules into the list\r\n	list.i = function(modules, mediaQuery) {\r\n		if(typeof modules === "string")\r\n			modules = [[null, modules, ""]];\r\n		var alreadyImportedModules = {};\r\n		for(var i = 0; i < this.length; i++) {\r\n			var id = this[i][0];\r\n			if(typeof id === "number")\r\n				alreadyImportedModules[id] = true;\r\n		}\r\n		for(i = 0; i < modules.length; i++) {\r\n			var item = modules[i];\r\n			// skip already imported module\r\n			// this implementation is not 100% perfect for weird media query combinations\r\n			//  when a module is imported multiple times with different media queries.\r\n			//  I hope this will never occur (Hey this way we have smaller bundles)\r\n			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n				if(mediaQuery && !item[2]) {\r\n					item[2] = mediaQuery;\r\n				} else if(mediaQuery) {\r\n					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n				}\r\n				list.push(item);\r\n			}\r\n		}\r\n	};\r\n	return list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?')},function(module,exports,__webpack_require__){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n	memoize = function(fn) {\r\n		var memo;\r\n		return function () {\r\n			if (typeof memo === "undefined") memo = fn.apply(this, arguments);\r\n			return memo;\r\n		};\r\n	},\r\n	isOldIE = memoize(function() {\r\n		return /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n	}),\r\n	getHeadElement = memoize(function () {\r\n		return document.head || document.getElementsByTagName("head")[0];\r\n	}),\r\n	singletonElement = null,\r\n	singletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n	if(true) {\r\n		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\r\n	}\r\n\r\n	options = options || {};\r\n	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n	// tags it will allow on a page\r\n	if (typeof options.singleton === "undefined") options.singleton = isOldIE();\r\n\r\n	var styles = listToStyles(list);\r\n	addStylesToDom(styles, options);\r\n\r\n	return function update(newList) {\r\n		var mayRemove = [];\r\n		for(var i = 0; i < styles.length; i++) {\r\n			var item = styles[i];\r\n			var domStyle = stylesInDom[item.id];\r\n			domStyle.refs--;\r\n			mayRemove.push(domStyle);\r\n		}\r\n		if(newList) {\r\n			var newStyles = listToStyles(newList);\r\n			addStylesToDom(newStyles, options);\r\n		}\r\n		for(var i = 0; i < mayRemove.length; i++) {\r\n			var domStyle = mayRemove[i];\r\n			if(domStyle.refs === 0) {\r\n				for(var j = 0; j < domStyle.parts.length; j++)\r\n					domStyle.parts[j]();\r\n				delete stylesInDom[domStyle.id];\r\n			}\r\n		}\r\n	};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n	for(var i = 0; i < styles.length; i++) {\r\n		var item = styles[i];\r\n		var domStyle = stylesInDom[item.id];\r\n		if(domStyle) {\r\n			domStyle.refs++;\r\n			for(var j = 0; j < domStyle.parts.length; j++) {\r\n				domStyle.parts[j](item.parts[j]);\r\n			}\r\n			for(; j < item.parts.length; j++) {\r\n				domStyle.parts.push(addStyle(item.parts[j], options));\r\n			}\r\n		} else {\r\n			var parts = [];\r\n			for(var j = 0; j < item.parts.length; j++) {\r\n				parts.push(addStyle(item.parts[j], options));\r\n			}\r\n			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n		}\r\n	}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n	var styles = [];\r\n	var newStyles = {};\r\n	for(var i = 0; i < list.length; i++) {\r\n		var item = list[i];\r\n		var id = item[0];\r\n		var css = item[1];\r\n		var media = item[2];\r\n		var sourceMap = item[3];\r\n		var part = {css: css, media: media, sourceMap: sourceMap};\r\n		if(!newStyles[id])\r\n			styles.push(newStyles[id] = {id: id, parts: [part]});\r\n		else\r\n			newStyles[id].parts.push(part);\r\n	}\r\n	return styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n	var styleElement = document.createElement("style");\r\n	var head = getHeadElement();\r\n	styleElement.type = "text/css";\r\n	head.appendChild(styleElement);\r\n	return styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n	var linkElement = document.createElement("link");\r\n	var head = getHeadElement();\r\n	linkElement.rel = "stylesheet";\r\n	head.appendChild(linkElement);\r\n	return linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n	var styleElement, update, remove;\r\n\r\n	if (options.singleton) {\r\n		var styleIndex = singletonCounter++;\r\n		styleElement = singletonElement || (singletonElement = createStyleElement());\r\n		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n	} else if(obj.sourceMap &&\r\n		typeof URL === "function" &&\r\n		typeof URL.createObjectURL === "function" &&\r\n		typeof URL.revokeObjectURL === "function" &&\r\n		typeof Blob === "function" &&\r\n		typeof btoa === "function") {\r\n		styleElement = createLinkElement();\r\n		update = updateLink.bind(null, styleElement);\r\n		remove = function() {\r\n			styleElement.parentNode.removeChild(styleElement);\r\n			if(styleElement.href)\r\n				URL.revokeObjectURL(styleElement.href);\r\n		};\r\n	} else {\r\n		styleElement = createStyleElement();\r\n		update = applyToTag.bind(null, styleElement);\r\n		remove = function() {\r\n			styleElement.parentNode.removeChild(styleElement);\r\n		};\r\n	}\r\n\r\n	update(obj);\r\n\r\n	return function updateStyle(newObj) {\r\n		if(newObj) {\r\n			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n				return;\r\n			update(obj = newObj);\r\n		} else {\r\n			remove();\r\n		}\r\n	};\r\n}\r\n\r\nvar replaceText = (function () {\r\n	var textStore = [];\r\n\r\n	return function (index, replacement) {\r\n		textStore[index] = replacement;\r\n		return textStore.filter(Boolean).join(\'\\n\');\r\n	};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n	var css = remove ? "" : obj.css;\r\n\r\n	if (styleElement.styleSheet) {\r\n		styleElement.styleSheet.cssText = replaceText(index, css);\r\n	} else {\r\n		var cssNode = document.createTextNode(css);\r\n		var childNodes = styleElement.childNodes;\r\n		if (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n		if (childNodes.length) {\r\n			styleElement.insertBefore(cssNode, childNodes[index]);\r\n		} else {\r\n			styleElement.appendChild(cssNode);\r\n		}\r\n	}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n	var css = obj.css;\r\n	var media = obj.media;\r\n	var sourceMap = obj.sourceMap;\r\n\r\n	if(media) {\r\n		styleElement.setAttribute("media", media)\r\n	}\r\n\r\n	if(styleElement.styleSheet) {\r\n		styleElement.styleSheet.cssText = css;\r\n	} else {\r\n		while(styleElement.firstChild) {\r\n			styleElement.removeChild(styleElement.firstChild);\r\n		}\r\n		styleElement.appendChild(document.createTextNode(css));\r\n	}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n	var css = obj.css;\r\n	var media = obj.media;\r\n	var sourceMap = obj.sourceMap;\r\n\r\n	if(sourceMap) {\r\n		// http://stackoverflow.com/a/26603875\r\n		css += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\r\n	}\r\n\r\n	var blob = new Blob([css], { type: "text/css" });\r\n\r\n	var oldSrc = linkElement.href;\r\n\r\n	linkElement.href = URL.createObjectURL(blob);\r\n\r\n	if(oldSrc)\r\n		URL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?')},function(module,exports,__webpack_require__){eval("(function () {\n	'use strict';\n\n	//constants\n	var NEAR = 0.1,\n		FAR = 1000000,\n\n	//global-ish declarations\n		THREE,\n		eventEmitter,\n		materials = __webpack_require__(8),\n		nop = function () {},\n		requestFullscreen = nop,\n		exitFullscreen = (\n			document.exitFullscreen ||\n			document.mozCancelFullScreen ||\n			document.webkitExitFullscreen ||\n			document.msExitFullscreen ||\n			nop\n		).bind(document),\n\n	//scene assets\n		camera,\n		scene,\n		body,\n		renderer,\n		audioListener,\n		vrControls,\n		vrEffect,\n		mouseControls,\n		raycaster,\n		target,\n\n		bodyWrapper,\n		cameraWrapper,\n\n		floor,\n\n	//state\n		going = false,\n		vrMode = false,\n		orientationEnabled,\n		orientationPossible = false,\n\n	//exported object\n		VR,\n\n		VRObject = __webpack_require__(44),\n		objectMethods = [\n			'box',\n			'cylinder',\n			'torus',\n			'sphere',\n			'empty',\n			'sound',\n			'floor',\n			'sky',\n			'panorama',\n			'image',\n			'video',\n			'lvideo',\n			'text',\n			'grid'\n		],\n\n		//todo: use a weak map or set instead\n		vrObjects = [],\n		raycastable = [],\n\n		lastTick = 0,\n		animationCallbacks = [];\n\n	function isFullscreen() {\n		return !!(document.fullscreenElement ||\n			document.mozFullScreenElement ||\n			document.webkitFullscreenElement ||\n			document.msFullscreenElement);\n	}\n\n	function fullScreenError() {\n		vrMode = false;\n		if (vrEffect) {\n			vrEffect.exit();\n		}\n	}\n\n	function pruneObject(object) {\n		var i = raycastable.indexOf(object);\n		if (i >= 0) {\n			raycastable.splice(i, 1);\n		}\n\n		i = vrObjects.indexOf(VRObject.findObject(object));\n		if (i >= 0) {\n			vrObjects.splice(i, 1);\n		}\n\n		object.children.forEach(pruneObject);\n	}\n\n	function raycast() {\n		var i,\n			intersect,\n			object,\n			intersects,\n			parent,\n			prune = [],\n			vrObject;\n\n		raycaster.ray.origin.setFromMatrixPosition(camera.matrixWorld); // world position\n		raycaster.ray.direction.set(0, 0, 0.5).unproject(camera).sub(raycaster.ray.origin).normalize();\n\n		intersects = raycaster.intersectObjects(raycastable, true);\n		for (i = 0; i < intersects.length; i++) {\n			intersect = intersects[i];\n\n			// if object has been removed from scene, remove it from raycastable\n			parent = intersect.object;\n			while (parent && parent !== scene) {\n				if (!parent.parent) {\n					prune.push(parent);\n				}\n				parent = parent.parent;\n			}\n\n			if (parent && intersect.object instanceof THREE.Mesh) {\n				object = intersect.object;\n				break;\n			}\n		}\n\n		prune.forEach(pruneObject);\n\n		if (target !== object) {\n			if (target) {\n				vrObject = VRObject.findObject(target);\n				vrObject.emit('lookaway');\n				VR.emit('lookaway', vrObject);\n			}\n			target = object;\n			if (target) {\n				vrObject = VRObject.findObject(target);\n				while (!vrObject && target.parent) {\n					target = target.parent;\n					vrObject = VRObject.findObject(target);\n				}\n				if (vrObject) {\n					vrObject.emit('lookat', intersect);\n					VR.emit('lookat', vrObject, intersect);\n				}\n			}\n		}\n	}\n\n	function render() {\n		var now = Date.now() / 1000,\n			delta = Math.min(1, now - lastTick);\n\n		vrControls.update();\n\n		animationCallbacks.forEach(function (cb) {\n			cb(delta, now);\n		});\n\n		scene.updateMatrixWorld();\n\n		vrObjects.forEach(function (object) {\n			object.update(now);\n		});\n\n		raycast();\n\n		vrEffect.render(scene, camera);\n\n		lastTick = now;\n	}\n\n	function renderLoop() {\n		if (going) {\n			render();\n			requestAnimationFrame(renderLoop);\n		}\n	}\n\n	function stop() {\n		going = false;\n	}\n\n	function start() {\n		if (!going) {\n			going = true;\n			renderLoop();\n		}\n	}\n\n	/*\n	Mute any sounds when this browser tab is in the background or minimized.\n	*/\n	function visibilityChange() {\n		if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n			audioListener.volume(0);\n		} else {\n			audioListener.volume(1);\n		}\n	}\n\n	function resize(width, height) {\n		width = typeof width === 'number' && width || window.innerWidth;\n		height = typeof height === 'number' && height || window.innerHeight;\n\n		camera.aspect = width / height;\n		camera.updateProjectionMatrix();\n		renderer.setSize(width, height);\n	}\n\n	function initShake() {\n		var lastTime = 0,\n			lastX,\n			lastY,\n			lastZ,\n			threshold = 15;\n\n		window.addEventListener('devicemotion', function (evt) {\n			var current = evt.accelerationIncludingGravity,\n				time,\n				diff,\n				deltaX = 0,\n				deltaY = 0,\n				deltaZ = 0,\n				dist;\n\n			if (lastX !== undefined) {\n				deltaX = Math.abs(lastX - current.x);\n				deltaY = Math.abs(lastY - current.y);\n				deltaZ = Math.abs(lastZ - current.z);\n\n				// if (deltaX > threshold &&\n				// 		(deltaY > threshold || deltaZ > threshold)\n				// 	) {\n				dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);\n				if (dist > threshold) {\n\n					time = Date.now();\n					diff = time - lastTime;\n					if (diff > 1000) {\n						if (navigator.vibrate) {\n							navigator.vibrate(100);\n						}\n\n						lastTime = Date.now();\n\n						VR.emit('shake');\n					}\n				}\n			}\n\n			lastX = current.x;\n			lastY = current.y;\n			lastZ = current.z;\n\n			orientationPossible = true;\n		}, false);\n	}\n\n	function initScene() {\n		function attachCanvas() {\n			document.body.insertBefore(renderer.domElement, document.body.firstChild || null);\n			resize();\n		}\n\n		if (renderer) {\n			return;\n		}\n\n		//create renderer and place in document\n		renderer = new THREE.WebGLRenderer({ antialias: true });\n		renderer.domElement.addEventListener('webglcontextlost', function contextLost(event) {\n			console.log('lost context', event);\n		});\n		// renderer.shadowMapEnabled = true;\n		// renderer.shadowMapSoft = true;\n\n		//need a scene to put all our objects in\n		scene = new THREE.Scene();\n\n		bodyWrapper = new VRObject(scene, __webpack_require__(60), null, {\n			name: 'body'\n		}).moveTo(0, 1.5, 4);\n		body = bodyWrapper.object;\n\n		cameraWrapper = new VRObject(body, function (parent) {\n			//need a camera with which to look at stuff\n			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, NEAR, FAR);\n			parent.add(camera);\n\n			return camera;\n		})\n		// set camera position so that OrbitControls works properly.\n			.moveTo(0, 0.0001, 0.0001);\n\n		audioListener = new THREE.AudioListener();\n		audioListener.name = 'audio-listener';\n		camera.add(audioListener);\n\n		//VRControls point the camera wherever we're looking\n		vrControls = new THREE.VRControls(camera);\n		vrControls.freeze = !orientationEnabled;\n\n		//render left and right eye\n		vrEffect = new THREE.VRStereoEffect(renderer);\n		vrEffect.near = NEAR;\n		vrEffect.far = FAR;\n		vrEffect.addEventListener('fullscreenchange', function (evt) {\n			var screen;\n			if (isFullscreen()) {\n				if (vrMode) {\n					//no mouse control\n					mouseControls.enabled = false;\n\n					vrControls.freeze = false;\n					vrControls.reset();\n\n					screen = window.screen;\n					if (screen.lockOrientation) {\n						screen.lockOrientation('landscape-primary');\n					} else if (screen.mozLockOrientation) {\n						screen.mozLockOrientation('landscape-primary');\n					} else if (screen.orientation && screen.orientation.lock) {\n						screen.orientation.lock('landscape-primary');\n					}\n				}\n			} else {\n				VR.exitVR();\n			}\n\n			camera.position.set(0, 0.0001, 0.0001);\n			camera.rotation.set(0, 0, 0);\n\n			VR.emit('fullscreenchange', evt);\n		});\n\n		//report on HMD\n		vrControls.addEventListener('devicechange', function () {\n			orientationPossible = true;\n			if (orientationEnabled === undefined) {\n				orientationEnabled = vrControls.mode() === 'deviceorientation';\n			}\n\n			vrControls.freeze = !orientationEnabled && !vrMode;\n\n			VR.emit('devicechange', vrControls.mode(), vrEffect.hmd());\n		});\n\n		//mouse control in case got no orientation device\n		mouseControls = new THREE.OrbitControls(camera, renderer.domElement);\n		mouseControls.target0.set(0, 0.0001, 0.000);\n		mouseControls.target.copy(mouseControls.target0);\n		mouseControls.update();\n\n		//todo: remove any default lights once other lights are added\n		var dLight = new THREE.DirectionalLight(0xffffff, 0.8);\n		dLight.name = 'directional-light';\n		dLight.position.set(20, 100, 100);\n\n		dLight.castShadow = true;\n		dLight.shadowCameraVisible = true;\n\n		dLight.shadowMapWidth = 2048;\n		dLight.shadowMapHeight = 2048;\n\n		dLight.shadowCameraLeft = -10;\n		dLight.shadowCameraRight = 10;\n		dLight.shadowCameraTop = 10;\n		dLight.shadowCameraBottom = -10;\n\n		dLight.shadowCameraFar = 150;\n		dLight.shadowCameraNear = 100;\n		dLight.shadowDarkness = 1;\n\n		scene.add(dLight);\n\n		scene.add(new THREE.AmbientLight(0x444444));\n\n		if (VR) {\n			VR.camera = cameraWrapper;\n			VR.body = bodyWrapper;\n			VR.scene = scene;\n			VR.canvas = renderer.domElement;\n			VR.renderer = renderer;\n			VR.zeroSensor = vrControls.zeroSensor;\n		}\n\n		raycaster = new THREE.Raycaster();\n\n		if (document.body) {\n			attachCanvas();\n		} else {\n			window.addEventListener('load', attachCanvas, false);\n		}\n\n		VR.canvas.addEventListener('mozfullscreenerror', fullScreenError, false);\n		VR.canvas.addEventListener('webkitfullscreenerror', fullScreenError, false);\n		VR.canvas.addEventListener('fullscreenerror', fullScreenError, false);\n	}\n\n	function initRequirements() {\n		//load external requirements\n		THREE = __webpack_require__(9);\n		__webpack_require__(61);\n		__webpack_require__(62);\n\n		//if (typeof __DEV__ !== 'undefined' && __DEV__) {\n			__webpack_require__(63);\n		//}\n\n		THREE.ImageUtils.crossOrigin = '';\n\n		eventEmitter = __webpack_require__(45);\n\n		//my VR stuff. todo: move these to a separate repo or two for easy packaging\n		__webpack_require__(64);\n		__webpack_require__(65);\n	}\n\n	function initialize() {\n		//todo: set up button/info elements\n\n		initScene();\n\n		initShake();\n\n		resize();\n\n		document.addEventListener('visibilitychange', visibilityChange);\n		document.addEventListener('mozvisibilitychange', visibilityChange);\n		document.addEventListener('msvisibilitychange', visibilityChange);\n		document.addEventListener('webkitvisibilitychange', visibilityChange);\n	}\n\n	initRequirements();\n\n	module.exports = VR = {\n		init: initialize,\n		render: render,\n		start: start,\n		stop: stop,\n		resize: resize,\n\n		THREE: THREE,\n\n		materials: materials,\n\n		animate: function (callback) {\n			var i;\n			if (typeof callback === 'function') {\n				i = animationCallbacks.indexOf(callback);\n				if (i < 0) {\n					animationCallbacks.push(callback);\n				}\n			}\n		},\n\n		end: function (callback) {\n			var i;\n\n			if (!callback) {\n				animationCallbacks.length = 0;\n				return;\n			}\n\n			if (typeof callback === 'function') {\n				i = animationCallbacks.indexOf(callback);\n				if (i >= 0) {\n					animationCallbacks.splice(i, 1);\n				}\n			}\n		},\n\n		requestVR: function () {\n			//todo: check if it's possible\n			if (vrMode || !vrEffect) {\n				return;\n			}\n\n			vrMode = true;\n\n			//full screen and render two eyes\n			//always full screen\n			vrEffect.requestFullScreen();\n		},\n\n		exitVR: function () {\n			vrMode = false;\n			if (isFullscreen()) {\n				exitFullscreen();\n				return;\n			}\n\n			mouseControls.enabled = true;\n			vrControls.freeze = !orientationEnabled;\n			camera.rotation.set(0, 0, 0);\n		},\n\n		vrMode: function () {\n			return vrMode && isFullscreen();\n		},\n\n		orientationEnabled: function () {\n			return !!orientationEnabled;\n		},\n		enableOrientation: function () {\n			orientationEnabled = true;\n			if (!vrMode) {\n				vrControls.freeze = false;\n			}\n		},\n		disableOrientation: function () {\n			orientationEnabled = false;\n			camera.rotation.set(0, 0, 0);\n			vrControls.freeze = !vrMode;\n		},\n\n		isFullscreen: isFullscreen,\n		requestFullscreen: requestFullscreen,\n		exitFullscreen: function () {\n			if (isFullscreen()) {\n				exitFullscreen();\n			}\n		},\n\n		controlMode: function () {\n			return vrControls && vrControls.mode();\n		},\n\n		zeroSensor: nop,\n\n		vibrate: navigator.vibrate ? navigator.vibrate.bind(navigator) : nop,\n\n		// Utility\n		times: function (n, callback) {\n			var i;\n\n			for (i = 0; i < n; i++) {\n				callback(i);\n			}\n		},\n\n		camera: cameraWrapper,\n		body: bodyWrapper,\n		scene: scene,\n		renderer: renderer || null,\n		canvas: renderer && renderer.domElement || null\n	};\n\n	objectMethods.forEach(function (method) {\n		var creator = __webpack_require__(66)(\"./\" + method),\n			key;\n\n		VR[method] = function (options) {\n			var obj = new VRObject(scene, creator, body, options);\n			vrObjects.push(obj);\n			if (obj.raycastable) {\n				raycastable.push(obj.object);\n			}\n			return obj;\n		};\n\n		VRObject.prototype[method] = function (options) {\n			var obj = new VRObject(this.object, creator, body, options);\n			vrObjects.push(obj);\n			if (obj.raycastable) {\n				raycastable.push(obj.object);\n			}\n			return obj;\n		};\n\n		for (key in creator) {\n			if (creator.hasOwnProperty(key) && typeof creator[key] === 'function') {\n				VR[method][key] = creator[key];\n				VRObject.prototype[method][key] = creator[key];\n			}\n		}\n	});\n\n	eventEmitter(VR);\n\n	Object.defineProperty(VR, 'target', {\n		get: function () {\n			return target;\n		}\n	});\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vr.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/vr.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var THREE = __webpack_require__(9),\n		forEach = __webpack_require__(10),\n		assign = __webpack_require__(18),\n\n		iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g),\n\n		// https://gist.github.com/dperini/729294\n		//urlRegex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/i,\n		urlRegex = __webpack_require__(29),\n\n		dataUri = /^data:image\\/(?:png|jpe?g|gif);/,\n		assetPath = (\"http://pov-tc.pbs.org/pov/flv/2015/webvr-starter-kit/\"),\n\n		images = {},\n\n		materialTypes = {\n			lambert: THREE.MeshLambertMaterial,\n			basic: THREE.MeshBasicMaterial,\n			phong: THREE.MeshPhongMaterial,\n			normal: THREE.MeshNormalMaterial,\n			depth: THREE.MeshDepthMaterial\n		},\n		textureFiles = {\n			'asphalt': {\n				repeat: 12\n			},\n			'brick-tiles': {\n				repeat: 2\n			},\n			'bricks': {\n				type: 'phong',\n				repeat: 4,\n				normalMap: 'bricks-normal.jpg',\n				specularMap: 'bricks-specular.jpg'\n			},\n			'checkerboard': {\n				repeat: 10,\n				map: 'checkerboard.png'\n			},\n			'grass': {\n				repeat: 12\n			},\n			'metal-floor': {\n				type: 'phong',\n				shininess: 100,\n\n				repeat: 2\n			},\n			'metal': {\n				type: 'phong',\n				shininess: 100,\n				shading: THREE.SmoothShading,\n\n				repeat: 2\n			},\n			'stone': {\n				repeat: 8\n			},\n			'tiles': {\n				repeat: 4\n			},\n			'weathered-wood': {\n				repeat: 8\n			},\n			'wood': {\n				repeat: 4\n			}\n		},\n		textures = {},\n		materials;\n\n	function imageTexture(src, mapping, callback) {\n		var image,\n			parse,\n			texture,\n			isDataUri;\n\n		function imageLoaded() {\n			var scale,\n				canvas,\n				ctx,\n				smallImage;\n\n			/*\n			iOS doesn't know how to handle large images. Even though the MAX_TEXTURE_SIZE\n			may be 4096, it still breaks on images that large. So we scale them down.\n			*/\n			if (iOS && (image.naturalWidth > 2048 || image.naturalHeight > 2048)) {\n				scale = 2048 / Math.max( image.naturalWidth, image.naturalHeight );\n\n				canvas = document.createElement('canvas');\n				canvas.width = Math.floor(image.naturalWidth * scale);\n				canvas.height = Math.floor(image.naturalHeight * scale);\n\n				ctx = canvas.getContext('2d');\n				ctx.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight, 0, 0, canvas.width, canvas.height);\n\n				image = canvas;\n			}\n\n			texture.image = image;\n			texture.needsUpdate = true;\n			if (typeof callback === 'function') {\n				setTimeout(callback.bind(null, texture, image), 1);\n			}\n		}\n\n		parse = dataUri.exec(src);\n		isDataUri = !!parse;\n		if (!parse) {\n			parse = urlRegex.exec(src);\n		}\n\n		// if (!parse) {\n		// 	console.error('Invalid image URL: ' + src);\n		// 	return;\n		// }\n\n		if (images[src]) {\n			image = images[src];\n		} else {\n			image = document.createElement('img');\n			if (parse && (parse[1] && parse[1] !== window.location.hostname || parse[2] && parse[2] !== window.location.port)) {\n				image.crossOrigin = 'anonymous';\n			}\n			image.src = src;\n			images[src] = image;\n		}\n\n		texture = new THREE.Texture(undefined, mapping);\n\n		if (image.naturalWidth || isDataUri) {\n			setTimeout(imageLoaded, 1);\n		} else {\n			image.addEventListener('load', imageLoaded);\n		}\n\n		return texture;\n	}\n\n	function material(options) {\n		var opts,\n			Material = materialTypes[options.type] || THREE.MeshLambertMaterial;\n\n		function threeTexture(fn) {\n			if (typeof fn === 'string') {\n				if (urlRegex.test(fn) || dataUri.test(fn)) {\n					return imageTexture(fn);\n				}\n\n				fn = textures[fn];\n			}\n			if (typeof fn === 'function') {\n				return fn(options);\n			}\n\n			return fn;\n		}\n\n		if (typeof options === 'string') {\n			options = {\n				map: options\n			};\n		}\n\n		opts = assign({}, options);\n		forEach({\n			ambient: options.ambient || options.color,\n			emissive: options.emissive || options.color,\n			map: threeTexture(options.map),\n			specularMap: threeTexture(options.specularMap),\n			normalMap: threeTexture(options.normalMap),\n			alphaMap: threeTexture(options.alphaMap),\n			envMap: threeTexture(options.envMap),\n			lightMap: threeTexture(options.lightMap)\n		}, function (val, key) {\n			if (val !== undefined) {\n				opts[key] = val;\n			}\n		});\n\n		delete opts.type;\n\n		return new Material(opts);\n	}\n\n	//figure out if script is loaded relative so we know where to find the images\n	assetPath = (function () {\n		var url,\n			scripts;\n\n		if (document.currentScript) {\n			url = document.currentScript.getAttribute('src');\n		} else {\n			scripts = document.getElementsByTagName('script');\n			url = scripts[scripts.length - 1].getAttribute('src');\n		}\n\n		if (!urlRegex.test(url)) {\n			return url.replace(/[a-z\\-\\.]+\\.js$/i, '');\n		}\n\n		return (\"http://pov-tc.pbs.org/pov/flv/2015/webvr-starter-kit/\");\n	}());\n\n	materials = {\n		standard: function () {\n			return new THREE.MeshLambertMaterial();\n		},\n		textures: textures,\n		imageTexture: imageTexture,\n		material: material,\n		library: ['standard']\n	};\n\n	forEach(textureFiles, function (props, key) {\n		function textureFactory(file, options) {\n			function imagePath(url) {\n				if ((/^[a-z0-9\\/\\-]+\\.(png|jpg)$/i).test(url)) {\n					return assetPath + url;\n				}\n\n				return url;\n			}\n\n			options = options || {};\n\n			return function (opts) {\n				var texture = imageTexture(imagePath(__webpack_require__(30)(\"./\" + file)));\n\n				opts = assign({}, options, opts);\n\n				if (opts.repeat) {\n					if (opts.repeat > 0) {\n						texture.repeat.set(opts.repeat, opts.repeat);\n					} else if (opts.repeat instanceof THREE.Vector2) {\n						texture.repeat.copy(opts.repeat);\n					}\n					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n				}\n				return texture;\n			};\n		}\n\n		var map = textureFactory(props.map || key + '.jpg', props),\n			materialDef;\n\n		materialDef = assign({}, props, {\n			map: map\n		});\n		textures[key] = map;\n\n		if (props.normalMap) {\n			materialDef.normalMap = textures[key + '-normal'] = textureFactory(props.normalMap, props);\n		}\n\n		if (props.specularMap) {\n			materialDef.specularMap = textures[key + '-specular'] = textureFactory(props.specularMap, props);\n		}\n\n		materials.library.push(key);\n		materials[key] = function (options) {\n			var opts = assign({}, materialDef, options);\n\n			return material(opts);\n		};\n	});\n\n	return materials;\n\n	//var parse = urlRegex.exec('https://lh5.googleusercontent.com:80/-SNO8rWDqbUM/U085rfOBRuI/AAAAAAAAEdM/nWEWCtNceZ0/w955-h382-no/PANO_20130225_131211.jpg');\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/materials.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/materials.js?");
},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '72' };\r\n\r\n//\r\n\r\nif ( true ) {\r\n\r\n		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\r\n		module.exports = THREE;\r\n\r\n}\r\n\r\n\r\n// polyfills\r\n\r\nif ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {\r\n\r\n	// Missing in Android stock browser.\r\n\r\n	( function () {\r\n\r\n		var lastTime = 0;\r\n		var vendors = [ 'ms', 'moz', 'webkit', 'o' ];\r\n\r\n		for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {\r\n\r\n			self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];\r\n			self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\r\n\r\n		}\r\n\r\n		if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {\r\n\r\n			self.requestAnimationFrame = function ( callback ) {\r\n\r\n				var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\r\n				var id = self.setTimeout( function () {\r\n\r\n					callback( currTime + timeToCall );\r\n\r\n				}, timeToCall );\r\n				lastTime = currTime + timeToCall;\r\n				return id;\r\n\r\n			};\r\n\r\n		}\r\n\r\n		if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {\r\n\r\n			self.cancelAnimationFrame = function ( id ) {\r\n\r\n				self.clearTimeout( id );\r\n\r\n			};\r\n\r\n		}\r\n\r\n	}() );\r\n\r\n}\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n	Math.sign = function ( x ) {\r\n\r\n		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\r\n	};\r\n\r\n}\r\n\r\nif ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {\r\n\r\n	// Missing in IE9-11.\r\n	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\r\n	Object.defineProperty( Function.prototype, 'name', {\r\n\r\n		get: function () {\r\n\r\n			return this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\r\n		}\r\n\r\n	} );\r\n\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n// mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n// depth modes\r\n\r\nTHREE.NeverDepth = 0;\r\nTHREE.AlwaysDepth = 1;\r\nTHREE.LessDepth = 2;\r\nTHREE.LessEqualDepth = 3;\r\nTHREE.EqualDepth = 4;\r\nTHREE.GreaterEqualDepth = 5;\r\nTHREE.GreaterDepth = 6;\r\nTHREE.NotEqualDepth = 7;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfFloatType = 1025;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n\r\n// DEPRECATED\r\n\r\nTHREE.Projector = function () {\r\n\r\n	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n	this.projectVector = function ( vector, camera ) {\r\n\r\n		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n		vector.project( camera );\r\n\r\n	};\r\n\r\n	this.unprojectVector = function ( vector, camera ) {\r\n\r\n		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n		vector.unproject( camera );\r\n\r\n	};\r\n\r\n	this.pickingRay = function ( vector, camera ) {\r\n\r\n		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n	this.domElement = document.createElement( 'canvas' );\r\n	this.clear = function () {};\r\n	this.render = function () {};\r\n	this.setClearColor = function () {};\r\n	this.setSize = function () {};\r\n\r\n};\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n	if ( arguments.length === 3 ) {\r\n\r\n		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\r\n	}\r\n\r\n	return this.set( color );\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n	constructor: THREE.Color,\r\n\r\n	r: 1, g: 1, b: 1,\r\n\r\n	set: function ( value ) {\r\n\r\n		if ( value instanceof THREE.Color ) {\r\n\r\n			this.copy( value );\r\n\r\n		} else if ( typeof value === 'number' ) {\r\n\r\n			this.setHex( value );\r\n\r\n		} else if ( typeof value === 'string' ) {\r\n\r\n			this.setStyle( value );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setHex: function ( hex ) {\r\n\r\n		hex = Math.floor( hex );\r\n\r\n		this.r = ( hex >> 16 & 255 ) / 255;\r\n		this.g = ( hex >> 8 & 255 ) / 255;\r\n		this.b = ( hex & 255 ) / 255;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setRGB: function ( r, g, b ) {\r\n\r\n		this.r = r;\r\n		this.g = g;\r\n		this.b = b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setHSL: function () {\r\n\r\n		function hue2rgb ( p, q, t ) {\r\n\r\n			if ( t < 0 ) t += 1;\r\n			if ( t > 1 ) t -= 1;\r\n			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n			if ( t < 1 / 2 ) return q;\r\n			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n			return p;\r\n\r\n		}\r\n\r\n		return function ( h, s, l ) {\r\n\r\n			// h,s,l ranges are in 0.0 - 1.0\r\n			h = THREE.Math.euclideanModulo( h, 1 );\r\n			s = THREE.Math.clamp( s, 0, 1 );\r\n			l = THREE.Math.clamp( l, 0, 1 );\r\n\r\n			if ( s === 0 ) {\r\n\r\n				this.r = this.g = this.b = l;\r\n\r\n			} else {\r\n\r\n				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n				var q = ( 2 * l ) - p;\r\n\r\n				this.r = hue2rgb( q, p, h + 1 / 3 );\r\n				this.g = hue2rgb( q, p, h );\r\n				this.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n			}\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setStyle: function ( style ) {\r\n\r\n		var parseAlpha = function ( strAlpha ) {\r\n\r\n			var alpha = parseFloat( strAlpha );\r\n\r\n			if ( alpha < 1 ) {\r\n\r\n				console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );\r\n\r\n			}\r\n\r\n			return alpha;\r\n\r\n		}\r\n\r\n\r\n		var m;\r\n\r\n		if ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n			// rgb / hsl\r\n\r\n			var color;\r\n			var name = m[ 1 ];\r\n			var components = m[ 2 ];\r\n\r\n			switch ( name ) {\r\n\r\n				case 'rgb':\r\n\r\n					if ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*$/.exec( components ) ) {\r\n\r\n						// rgb(255,0,0)\r\n						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n						return this;\r\n\r\n					}\r\n\r\n					if ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*$/.exec( components ) ) {\r\n\r\n						// rgb(100%,0%,0%)\r\n						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n						return this;\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'rgba':\r\n\r\n					if ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*$/.exec( components ) ) {\r\n\r\n						// rgba(255,0,0,0.5)\r\n						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n						parseAlpha( color[ 4 ] );\r\n\r\n						return this;\r\n\r\n					}\r\n\r\n					if ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*$/.exec( components ) ) {\r\n\r\n						// rgba(100%,0%,0%,0.5)\r\n						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n						parseAlpha( color[ 4 ] );\r\n\r\n						return this;\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'hsl':\r\n\r\n					if ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*$/.exec( components ) ) {\r\n\r\n						// hsl(120,50%,50%)\r\n						var h = parseFloat( color[ 1 ] );\r\n						var s = parseInt( color[ 2 ], 10 ) / 100;\r\n						var l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n						return this.setHSL( h, s, l );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'hsla':\r\n\r\n					if ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*$/.exec( components ) ) {\r\n\r\n						// hsla(120,50%,50%,0.5)\r\n						var h = parseFloat( color[ 1 ] );\r\n						var s = parseInt( color[ 2 ], 10 ) / 100;\r\n						var l = parseInt( color[ 3 ], 10 ) / 100;\r\n						parseAlpha( color[ 4 ] );\r\n\r\n						return this.setHSL( h, s, l );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n			}\r\n\r\n		} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n			// hex color\r\n\r\n			var hex = m[ 1 ];\r\n			var size = hex.length;\r\n\r\n			if ( size === 3 ) {\r\n\r\n				// #ff0\r\n				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n				return this;\r\n\r\n			} else if ( size === 6 ) {\r\n\r\n				// #ff0000\r\n				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n				return this;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( style && style.length > 0 ) {\r\n\r\n			// color keywords\r\n			var hex = THREE.ColorKeywords[ style ];\r\n\r\n			if ( hex !== undefined ) {\r\n\r\n				// red\r\n				this.setHex( hex );\r\n\r\n			} else {\r\n\r\n				// unknown color\r\n				console.warn( 'THREE.Color: Unknown color ' + style );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.r, this.g, this.b );\r\n\r\n	},\r\n\r\n	copy: function ( color ) {\r\n\r\n		this.r = color.r;\r\n		this.g = color.g;\r\n		this.b = color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n		if ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n		this.r = Math.pow( color.r, gammaFactor );\r\n		this.g = Math.pow( color.g, gammaFactor );\r\n		this.b = Math.pow( color.b, gammaFactor );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n		if ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n		this.r = Math.pow( color.r, safeInverse );\r\n		this.g = Math.pow( color.g, safeInverse );\r\n		this.b = Math.pow( color.b, safeInverse );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	convertGammaToLinear: function () {\r\n\r\n		var r = this.r, g = this.g, b = this.b;\r\n\r\n		this.r = r * r;\r\n		this.g = g * g;\r\n		this.b = b * b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	convertLinearToGamma: function () {\r\n\r\n		this.r = Math.sqrt( this.r );\r\n		this.g = Math.sqrt( this.g );\r\n		this.b = Math.sqrt( this.b );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getHex: function () {\r\n\r\n		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n	},\r\n\r\n	getHexString: function () {\r\n\r\n		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n	},\r\n\r\n	getHSL: function ( optionalTarget ) {\r\n\r\n		// h,s,l ranges are in 0.0 - 1.0\r\n\r\n		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n		var r = this.r, g = this.g, b = this.b;\r\n\r\n		var max = Math.max( r, g, b );\r\n		var min = Math.min( r, g, b );\r\n\r\n		var hue, saturation;\r\n		var lightness = ( min + max ) / 2.0;\r\n\r\n		if ( min === max ) {\r\n\r\n			hue = 0;\r\n			saturation = 0;\r\n\r\n		} else {\r\n\r\n			var delta = max - min;\r\n\r\n			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n			switch ( max ) {\r\n\r\n				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n				case g: hue = ( b - r ) / delta + 2; break;\r\n				case b: hue = ( r - g ) / delta + 4; break;\r\n\r\n			}\r\n\r\n			hue /= 6;\r\n\r\n		}\r\n\r\n		hsl.h = hue;\r\n		hsl.s = saturation;\r\n		hsl.l = lightness;\r\n\r\n		return hsl;\r\n\r\n	},\r\n\r\n	getStyle: function () {\r\n\r\n		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n	},\r\n\r\n	offsetHSL: function ( h, s, l ) {\r\n\r\n		var hsl = this.getHSL();\r\n\r\n		hsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n		this.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( color ) {\r\n\r\n		this.r += color.r;\r\n		this.g += color.g;\r\n		this.b += color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addColors: function ( color1, color2 ) {\r\n\r\n		this.r = color1.r + color2.r;\r\n		this.g = color1.g + color2.g;\r\n		this.b = color1.b + color2.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.r += s;\r\n		this.g += s;\r\n		this.b += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( color ) {\r\n\r\n		this.r *= color.r;\r\n		this.g *= color.g;\r\n		this.b *= color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		this.r *= s;\r\n		this.g *= s;\r\n		this.b *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( color, alpha ) {\r\n\r\n		this.r += ( color.r - this.r ) * alpha;\r\n		this.g += ( color.g - this.g ) * alpha;\r\n		this.b += ( color.b - this.b ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( c ) {\r\n\r\n		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.r = array[ 0 ];\r\n		this.g = array[ 1 ];\r\n		this.b = array[ 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.r;\r\n		array[ offset + 1 ] = this.g;\r\n		array[ offset + 2 ] = this.b;\r\n\r\n		return array;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n	this._x = x || 0;\r\n	this._y = y || 0;\r\n	this._z = z || 0;\r\n	this._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n	constructor: THREE.Quaternion,\r\n\r\n	get x () {\r\n\r\n		return this._x;\r\n\r\n	},\r\n\r\n	set x ( value ) {\r\n\r\n		this._x = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get y () {\r\n\r\n		return this._y;\r\n\r\n	},\r\n\r\n	set y ( value ) {\r\n\r\n		this._y = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get z () {\r\n\r\n		return this._z;\r\n\r\n	},\r\n\r\n	set z ( value ) {\r\n\r\n		this._z = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get w () {\r\n\r\n		return this._w;\r\n\r\n	},\r\n\r\n	set w ( value ) {\r\n\r\n		this._w = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	set: function ( x, y, z, w ) {\r\n\r\n		this._x = x;\r\n		this._y = y;\r\n		this._z = z;\r\n		this._w = w;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n	},\r\n\r\n	copy: function ( quaternion ) {\r\n\r\n		this._x = quaternion.x;\r\n		this._y = quaternion.y;\r\n		this._z = quaternion.z;\r\n		this._w = quaternion.w;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromEuler: function ( euler, update ) {\r\n\r\n		if ( euler instanceof THREE.Euler === false ) {\r\n\r\n			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n		}\r\n\r\n		// http://www.mathworks.com/matlabcentral/fileexchange/\r\n		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n		//	content/SpinCalc.m\r\n\r\n		var c1 = Math.cos( euler._x / 2 );\r\n		var c2 = Math.cos( euler._y / 2 );\r\n		var c3 = Math.cos( euler._z / 2 );\r\n		var s1 = Math.sin( euler._x / 2 );\r\n		var s2 = Math.sin( euler._y / 2 );\r\n		var s3 = Math.sin( euler._z / 2 );\r\n\r\n		var order = euler.order;\r\n\r\n		if ( order === 'XYZ' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( order === 'YXZ' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		} else if ( order === 'ZXY' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( order === 'ZYX' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		} else if ( order === 'YZX' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( order === 'XZY' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		}\r\n\r\n		if ( update !== false ) this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromAxisAngle: function ( axis, angle ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n		// assumes axis is normalized\r\n\r\n		var halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n		this._x = axis.x * s;\r\n		this._y = axis.y * s;\r\n		this._z = axis.z * s;\r\n		this._w = Math.cos( halfAngle );\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromRotationMatrix: function ( m ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var te = m.elements,\r\n\r\n			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n			trace = m11 + m22 + m33,\r\n			s;\r\n\r\n		if ( trace > 0 ) {\r\n\r\n			s = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n			this._w = 0.25 / s;\r\n			this._x = ( m32 - m23 ) * s;\r\n			this._y = ( m13 - m31 ) * s;\r\n			this._z = ( m21 - m12 ) * s;\r\n\r\n		} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n			this._w = ( m32 - m23 ) / s;\r\n			this._x = 0.25 * s;\r\n			this._y = ( m12 + m21 ) / s;\r\n			this._z = ( m13 + m31 ) / s;\r\n\r\n		} else if ( m22 > m33 ) {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n			this._w = ( m13 - m31 ) / s;\r\n			this._x = ( m12 + m21 ) / s;\r\n			this._y = 0.25 * s;\r\n			this._z = ( m23 + m32 ) / s;\r\n\r\n		} else {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n			this._w = ( m21 - m12 ) / s;\r\n			this._x = ( m13 + m31 ) / s;\r\n			this._y = ( m23 + m32 ) / s;\r\n			this._z = 0.25 * s;\r\n\r\n		}\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromUnitVectors: function () {\r\n\r\n		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n		// assumes direction vectors vFrom and vTo are normalized\r\n\r\n		var v1, r;\r\n\r\n		var EPS = 0.000001;\r\n\r\n		return function ( vFrom, vTo ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			r = vFrom.dot( vTo ) + 1;\r\n\r\n			if ( r < EPS ) {\r\n\r\n				r = 0;\r\n\r\n				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n					v1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n				} else {\r\n\r\n					v1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				v1.crossVectors( vFrom, vTo );\r\n\r\n			}\r\n\r\n			this._x = v1.x;\r\n			this._y = v1.y;\r\n			this._z = v1.z;\r\n			this._w = r;\r\n\r\n			this.normalize();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	inverse: function () {\r\n\r\n		this.conjugate().normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	conjugate: function () {\r\n\r\n		this._x *= - 1;\r\n		this._y *= - 1;\r\n		this._z *= - 1;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		var l = this.length();\r\n\r\n		if ( l === 0 ) {\r\n\r\n			this._x = 0;\r\n			this._y = 0;\r\n			this._z = 0;\r\n			this._w = 1;\r\n\r\n		} else {\r\n\r\n			l = 1 / l;\r\n\r\n			this._x = this._x * l;\r\n			this._y = this._y * l;\r\n			this._z = this._z * l;\r\n			this._w = this._w * l;\r\n\r\n		}\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( q, p ) {\r\n\r\n		if ( p !== undefined ) {\r\n\r\n			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n			return this.multiplyQuaternions( q, p );\r\n\r\n		}\r\n\r\n		return this.multiplyQuaternions( this, q );\r\n\r\n	},\r\n\r\n	multiplyQuaternions: function ( a, b ) {\r\n\r\n		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVector3: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n		return vector.applyQuaternion( this );\r\n\r\n	},\r\n\r\n	slerp: function ( qb, t ) {\r\n\r\n		if ( t === 0 ) return this;\r\n		if ( t === 1 ) return this.copy( qb );\r\n\r\n		var x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n		if ( cosHalfTheta < 0 ) {\r\n\r\n			this._w = - qb._w;\r\n			this._x = - qb._x;\r\n			this._y = - qb._y;\r\n			this._z = - qb._z;\r\n\r\n			cosHalfTheta = - cosHalfTheta;\r\n\r\n		} else {\r\n\r\n			this.copy( qb );\r\n\r\n		}\r\n\r\n		if ( cosHalfTheta >= 1.0 ) {\r\n\r\n			this._w = w;\r\n			this._x = x;\r\n			this._y = y;\r\n			this._z = z;\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		var halfTheta = Math.acos( cosHalfTheta );\r\n		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n		if ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n			this._w = 0.5 * ( w + this._w );\r\n			this._x = 0.5 * ( x + this._x );\r\n			this._y = 0.5 * ( y + this._y );\r\n			this._z = 0.5 * ( z + this._z );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n		this._w = ( w * ratioA + this._w * ratioB );\r\n		this._x = ( x * ratioA + this._x * ratioB );\r\n		this._y = ( y * ratioA + this._y * ratioB );\r\n		this._z = ( z * ratioA + this._z * ratioB );\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( quaternion ) {\r\n\r\n		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this._x = array[ offset ];\r\n		this._y = array[ offset + 1 ];\r\n		this._z = array[ offset + 2 ];\r\n		this._w = array[ offset + 3 ];\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this._x;\r\n		array[ offset + 1 ] = this._y;\r\n		array[ offset + 2 ] = this._z;\r\n		array[ offset + 3 ] = this._w;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	onChange: function ( callback ) {\r\n\r\n		this.onChangeCallback = callback;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	onChangeCallback: function () {}\r\n\r\n};\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n	return qm.copy( qa ).slerp( qb, t );\r\n\r\n};\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n	constructor: THREE.Vector2,\r\n\r\n	set: function ( x, y ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.x, this.y );\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScaledVector: function ( v, s ) {\r\n\r\n		this.x += v.x * s;\r\n		this.y += v.y * s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subScalar: function ( s ) {\r\n\r\n		this.x -= s;\r\n		this.y -= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( v ) {\r\n\r\n		this.x *= v.x;\r\n		this.y *= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		this.x *= s;\r\n		this.y *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divide: function ( v ) {\r\n\r\n		this.x /= v.x;\r\n		this.y /= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		if ( scalar !== 0 ) {\r\n\r\n			var invScalar = 1 / scalar;\r\n\r\n			this.x *= invScalar;\r\n			this.y *= invScalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		if ( this.x > v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y > v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		if ( this.x < v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y < v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		if ( this.x < min.x ) {\r\n\r\n			this.x = min.x;\r\n\r\n		} else if ( this.x > max.x ) {\r\n\r\n			this.x = max.x;\r\n\r\n		}\r\n\r\n		if ( this.y < min.y ) {\r\n\r\n			this.y = min.y;\r\n\r\n		} else if ( this.y > max.y ) {\r\n\r\n			this.y = max.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: function () {\r\n\r\n		var min, max;\r\n\r\n		return function clampScalar( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector2();\r\n				max = new THREE.Vector2();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal );\r\n			max.set( maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n	},\r\n\r\n	lengthManhattan: function() {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	distanceTo: function ( v ) {\r\n\r\n		return Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n	},\r\n\r\n	distanceToSquared: function ( v ) {\r\n\r\n		var dx = this.x - v.x, dy = this.y - v.y;\r\n		return dx * dx + dy * dy;\r\n\r\n	},\r\n\r\n	setLength: function ( l ) {\r\n\r\n		var oldLength = this.length();\r\n\r\n		if ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n			this.multiplyScalar( l / oldLength );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerpVectors: function ( v1, v2, alpha ) {\r\n\r\n		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		index = index * attribute.itemSize + offset;\r\n\r\n		this.x = attribute.array[ index ];\r\n		this.y = attribute.array[ index + 1 ];\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n	this.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n	constructor: THREE.Vector3,\r\n\r\n	set: function ( x, y, z ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( z ) {\r\n\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			case 2: this.z = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			case 2: return this.z;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.x, this.y, this.z );\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n		this.z = v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n		this.z += v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n		this.z += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n		this.z = a.z + b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScaledVector: function ( v, s ) {\r\n\r\n		this.x += v.x * s;\r\n		this.y += v.y * s;\r\n		this.z += v.z * s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n		this.z -= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subScalar: function ( s ) {\r\n\r\n		this.x -= s;\r\n		this.y -= s;\r\n		this.z -= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n		this.z = a.z - b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n			return this.multiplyVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x *= v.x;\r\n		this.y *= v.y;\r\n		this.z *= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		this.x *= scalar;\r\n		this.y *= scalar;\r\n		this.z *= scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVectors: function ( a, b ) {\r\n\r\n		this.x = a.x * b.x;\r\n		this.y = a.y * b.y;\r\n		this.z = a.z * b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyEuler: function () {\r\n\r\n		var quaternion;\r\n\r\n		return function applyEuler( euler ) {\r\n\r\n			if ( euler instanceof THREE.Euler === false ) {\r\n\r\n				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n			}\r\n\r\n			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n			this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyAxisAngle: function () {\r\n\r\n		var quaternion;\r\n\r\n		return function applyAxisAngle( axis, angle ) {\r\n\r\n			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyMatrix3: function ( m ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 affine matrix\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyProjection: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 projection matrix\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyQuaternion: function ( q ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n\r\n		var qx = q.x;\r\n		var qy = q.y;\r\n		var qz = q.z;\r\n		var qw = q.w;\r\n\r\n		// calculate quat * vector\r\n\r\n		var ix =  qw * x + qy * z - qz * y;\r\n		var iy =  qw * y + qz * x - qx * z;\r\n		var iz =  qw * z + qx * y - qy * x;\r\n		var iw = - qx * x - qy * y - qz * z;\r\n\r\n		// calculate result * inverse quat\r\n\r\n		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	project: function () {\r\n\r\n		var matrix;\r\n\r\n		return function project( camera ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n			return this.applyProjection( matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	unproject: function () {\r\n\r\n		var matrix;\r\n\r\n		return function unproject( camera ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n			return this.applyProjection( matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	transformDirection: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 affine matrix\r\n		// vector interpreted as a direction\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n		this.normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divide: function ( v ) {\r\n\r\n		this.x /= v.x;\r\n		this.y /= v.y;\r\n		this.z /= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		if ( scalar !== 0 ) {\r\n\r\n			var invScalar = 1 / scalar;\r\n\r\n			this.x *= invScalar;\r\n			this.y *= invScalar;\r\n			this.z *= invScalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n			this.z = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		if ( this.x > v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y > v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z > v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		if ( this.x < v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y < v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z < v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		if ( this.x < min.x ) {\r\n\r\n			this.x = min.x;\r\n\r\n		} else if ( this.x > max.x ) {\r\n\r\n			this.x = max.x;\r\n\r\n		}\r\n\r\n		if ( this.y < min.y ) {\r\n\r\n			this.y = min.y;\r\n\r\n		} else if ( this.y > max.y ) {\r\n\r\n			this.y = max.y;\r\n\r\n		}\r\n\r\n		if ( this.z < min.z ) {\r\n\r\n			this.z = min.z;\r\n\r\n		} else if ( this.z > max.z ) {\r\n\r\n			this.z = max.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: function () {\r\n\r\n		var min, max;\r\n\r\n		return function clampScalar( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector3();\r\n				max = new THREE.Vector3();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal, minVal );\r\n			max.set( maxVal, maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n		this.z = Math.floor( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n		this.z = Math.ceil( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n		this.z = Math.round( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n		this.z = - this.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n	},\r\n\r\n	lengthManhattan: function () {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	setLength: function ( l ) {\r\n\r\n		var oldLength = this.length();\r\n\r\n		if ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n			this.multiplyScalar( l / oldLength );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n		this.z += ( v.z - this.z ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerpVectors: function ( v1, v2, alpha ) {\r\n\r\n		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	cross: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n			return this.crossVectors( v, w );\r\n\r\n		}\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		this.x = y * v.z - z * v.y;\r\n		this.y = z * v.x - x * v.z;\r\n		this.z = x * v.y - y * v.x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	crossVectors: function ( a, b ) {\r\n\r\n		var ax = a.x, ay = a.y, az = a.z;\r\n		var bx = b.x, by = b.y, bz = b.z;\r\n\r\n		this.x = ay * bz - az * by;\r\n		this.y = az * bx - ax * bz;\r\n		this.z = ax * by - ay * bx;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	projectOnVector: function () {\r\n\r\n		var v1, dot;\r\n\r\n		return function projectOnVector( vector ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			v1.copy( vector ).normalize();\r\n\r\n			dot = this.dot( v1 );\r\n\r\n			return this.copy( v1 ).multiplyScalar( dot );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	projectOnPlane: function () {\r\n\r\n		var v1;\r\n\r\n		return function projectOnPlane( planeNormal ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			v1.copy( this ).projectOnVector( planeNormal );\r\n\r\n			return this.sub( v1 );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	reflect: function () {\r\n\r\n		// reflect incident vector off plane orthogonal to normal\r\n		// normal is assumed to have unit length\r\n\r\n		var v1;\r\n\r\n		return function reflect( normal ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	angleTo: function ( v ) {\r\n\r\n		var theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n		// clamp, to handle numerical problems\r\n\r\n		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n	},\r\n\r\n	distanceTo: function ( v ) {\r\n\r\n		return Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n	},\r\n\r\n	distanceToSquared: function ( v ) {\r\n\r\n		var dx = this.x - v.x;\r\n		var dy = this.y - v.y;\r\n		var dz = this.z - v.z;\r\n\r\n		return dx * dx + dy * dy + dz * dz;\r\n\r\n	},\r\n\r\n	setEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\r\n	},\r\n\r\n	setEulerFromQuaternion: function ( q, order ) {\r\n\r\n		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\r\n	},\r\n\r\n	getPositionFromMatrix: function ( m ) {\r\n\r\n		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\r\n		return this.setFromMatrixPosition( m );\r\n\r\n	},\r\n\r\n	getScaleFromMatrix: function ( m ) {\r\n\r\n		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\r\n		return this.setFromMatrixScale( m );\r\n\r\n	},\r\n\r\n	getColumnFromMatrix: function ( index, matrix ) {\r\n\r\n		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\r\n		return this.setFromMatrixColumn( index, matrix );\r\n\r\n	},\r\n\r\n	setFromMatrixPosition: function ( m ) {\r\n\r\n		this.x = m.elements[ 12 ];\r\n		this.y = m.elements[ 13 ];\r\n		this.z = m.elements[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrixScale: function ( m ) {\r\n\r\n		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();\r\n		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();\r\n		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\r\n		this.x = sx;\r\n		this.y = sy;\r\n		this.z = sz;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrixColumn: function ( index, matrix ) {\r\n\r\n		var offset = index * 4;\r\n\r\n		var me = matrix.elements;\r\n\r\n		this.x = me[ offset ];\r\n		this.y = me[ offset + 1 ];\r\n		this.z = me[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n		this.z = array[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n		array[ offset + 2 ] = this.z;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		index = index * attribute.itemSize + offset;\r\n\r\n		this.x = attribute.array[ index ];\r\n		this.y = attribute.array[ index + 1 ];\r\n		this.z = attribute.array[ index + 2 ];\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n	this.z = z || 0;\r\n	this.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n	constructor: THREE.Vector4,\r\n\r\n	set: function ( x, y, z, w ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n		this.z = z;\r\n		this.w = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( z ) {\r\n\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setW: function ( w ) {\r\n\r\n		this.w = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			case 2: this.z = value; break;\r\n			case 3: this.w = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			case 2: return this.z;\r\n			case 3: return this.w;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n		this.z = v.z;\r\n		this.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n		this.z += v.z;\r\n		this.w += v.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n		this.z += s;\r\n		this.w += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n		this.z = a.z + b.z;\r\n		this.w = a.w + b.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScaledVector: function ( v, s ) {\r\n\r\n		this.x += v.x * s;\r\n		this.y += v.y * s;\r\n		this.z += v.z * s;\r\n		this.w += v.w * s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n		this.z -= v.z;\r\n		this.w -= v.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subScalar: function ( s ) {\r\n\r\n		this.x -= s;\r\n		this.y -= s;\r\n		this.z -= s;\r\n		this.w -= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n		this.z = a.z - b.z;\r\n		this.w = a.w - b.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		this.x *= scalar;\r\n		this.y *= scalar;\r\n		this.z *= scalar;\r\n		this.w *= scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( m ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n		var w = this.w;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		if ( scalar !== 0 ) {\r\n\r\n			var invScalar = 1 / scalar;\r\n\r\n			this.x *= invScalar;\r\n			this.y *= invScalar;\r\n			this.z *= invScalar;\r\n			this.w *= invScalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n			this.z = 0;\r\n			this.w = 1;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setAxisAngleFromQuaternion: function ( q ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n		// q is assumed to be normalized\r\n\r\n		this.w = 2 * Math.acos( q.w );\r\n\r\n		var s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n		if ( s < 0.0001 ) {\r\n\r\n			 this.x = 1;\r\n			 this.y = 0;\r\n			 this.z = 0;\r\n\r\n		} else {\r\n\r\n			 this.x = q.x / s;\r\n			 this.y = q.y / s;\r\n			 this.z = q.z / s;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var angle, x, y, z,		// variables for result\r\n			epsilon = 0.01,		// margin to allow for rounding errors\r\n			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees\r\n\r\n			te = m.elements,\r\n\r\n			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n		if ( ( Math.abs( m12 - m21 ) < epsilon )\r\n		   && ( Math.abs( m13 - m31 ) < epsilon )\r\n		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n			// singularity found\r\n			// first check for identity matrix which must have +1 for all terms\r\n			// in leading diagonal and zero in other terms\r\n\r\n			if ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n			   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n			   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n				// this singularity is identity matrix so angle = 0\r\n\r\n				this.set( 1, 0, 0, 0 );\r\n\r\n				return this; // zero angle, arbitrary axis\r\n\r\n			}\r\n\r\n			// otherwise this singularity is angle = 180\r\n\r\n			angle = Math.PI;\r\n\r\n			var xx = ( m11 + 1 ) / 2;\r\n			var yy = ( m22 + 1 ) / 2;\r\n			var zz = ( m33 + 1 ) / 2;\r\n			var xy = ( m12 + m21 ) / 4;\r\n			var xz = ( m13 + m31 ) / 4;\r\n			var yz = ( m23 + m32 ) / 4;\r\n\r\n			if ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n				// m11 is the largest diagonal term\r\n\r\n				if ( xx < epsilon ) {\r\n\r\n					x = 0;\r\n					y = 0.707106781;\r\n					z = 0.707106781;\r\n\r\n				} else {\r\n\r\n					x = Math.sqrt( xx );\r\n					y = xy / x;\r\n					z = xz / x;\r\n\r\n				}\r\n\r\n			} else if ( yy > zz ) {\r\n\r\n				// m22 is the largest diagonal term\r\n\r\n				if ( yy < epsilon ) {\r\n\r\n					x = 0.707106781;\r\n					y = 0;\r\n					z = 0.707106781;\r\n\r\n				} else {\r\n\r\n					y = Math.sqrt( yy );\r\n					x = xy / y;\r\n					z = yz / y;\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// m33 is the largest diagonal term so base result on this\r\n\r\n				if ( zz < epsilon ) {\r\n\r\n					x = 0.707106781;\r\n					y = 0.707106781;\r\n					z = 0;\r\n\r\n				} else {\r\n\r\n					z = Math.sqrt( zz );\r\n					x = xz / z;\r\n					y = yz / z;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.set( x, y, z, angle );\r\n\r\n			return this; // return 180 deg rotation\r\n\r\n		}\r\n\r\n		// as we have reached here there are no singularities so we can handle normally\r\n\r\n		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n						  + ( m13 - m31 ) * ( m13 - m31 )\r\n						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n		if ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n		// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n		// caught by singularity test above, but I've left it in just in case\r\n\r\n		this.x = ( m32 - m23 ) / s;\r\n		this.y = ( m13 - m31 ) / s;\r\n		this.z = ( m21 - m12 ) / s;\r\n		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		if ( this.x > v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y > v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z > v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		if ( this.w > v.w ) {\r\n\r\n			this.w = v.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		if ( this.x < v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y < v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z < v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		if ( this.w < v.w ) {\r\n\r\n			this.w = v.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		if ( this.x < min.x ) {\r\n\r\n			this.x = min.x;\r\n\r\n		} else if ( this.x > max.x ) {\r\n\r\n			this.x = max.x;\r\n\r\n		}\r\n\r\n		if ( this.y < min.y ) {\r\n\r\n			this.y = min.y;\r\n\r\n		} else if ( this.y > max.y ) {\r\n\r\n			this.y = max.y;\r\n\r\n		}\r\n\r\n		if ( this.z < min.z ) {\r\n\r\n			this.z = min.z;\r\n\r\n		} else if ( this.z > max.z ) {\r\n\r\n			this.z = max.z;\r\n\r\n		}\r\n\r\n		if ( this.w < min.w ) {\r\n\r\n			this.w = min.w;\r\n\r\n		} else if ( this.w > max.w ) {\r\n\r\n			this.w = max.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: function () {\r\n\r\n		var min, max;\r\n\r\n		return function clampScalar( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector4();\r\n				max = new THREE.Vector4();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal, minVal, minVal );\r\n			max.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n		this.z = Math.floor( this.z );\r\n		this.w = Math.floor( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n		this.z = Math.ceil( this.z );\r\n		this.w = Math.ceil( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n		this.z = Math.round( this.z );\r\n		this.w = Math.round( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n		this.z = - this.z;\r\n		this.w = - this.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n	},\r\n\r\n	lengthManhattan: function () {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	setLength: function ( l ) {\r\n\r\n		var oldLength = this.length();\r\n\r\n		if ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n			this.multiplyScalar( l / oldLength );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n		this.z += ( v.z - this.z ) * alpha;\r\n		this.w += ( v.w - this.w ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerpVectors: function ( v1, v2, alpha ) {\r\n\r\n		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n		this.z = array[ offset + 2 ];\r\n		this.w = array[ offset + 3 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n		array[ offset + 2 ] = this.z;\r\n		array[ offset + 3 ] = this.w;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		index = index * attribute.itemSize + offset;\r\n\r\n		this.x = attribute.array[ index ];\r\n		this.y = attribute.array[ index + 1 ];\r\n		this.z = attribute.array[ index + 2 ];\r\n		this.w = attribute.array[ index + 3 ];\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n	this._x = x || 0;\r\n	this._y = y || 0;\r\n	this._z = z || 0;\r\n	this._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n	constructor: THREE.Euler,\r\n\r\n	get x () {\r\n\r\n		return this._x;\r\n\r\n	},\r\n\r\n	set x ( value ) {\r\n\r\n		this._x = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get y () {\r\n\r\n		return this._y;\r\n\r\n	},\r\n\r\n	set y ( value ) {\r\n\r\n		this._y = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get z () {\r\n\r\n		return this._z;\r\n\r\n	},\r\n\r\n	set z ( value ) {\r\n\r\n		this._z = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get order () {\r\n\r\n		return this._order;\r\n\r\n	},\r\n\r\n	set order ( value ) {\r\n\r\n		this._order = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	set: function ( x, y, z, order ) {\r\n\r\n		this._x = x;\r\n		this._y = y;\r\n		this._z = z;\r\n		this._order = order || this._order;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this._x, this._y, this._z, this._order);\r\n\r\n	},\r\n\r\n	copy: function ( euler ) {\r\n\r\n		this._x = euler._x;\r\n		this._y = euler._y;\r\n		this._z = euler._z;\r\n		this._order = euler._order;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromRotationMatrix: function ( m, order, update ) {\r\n\r\n		var clamp = THREE.Math.clamp;\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var te = m.elements;\r\n		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n		order = order || this._order;\r\n\r\n		if ( order === 'XYZ' ) {\r\n\r\n			this._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( - m23, m33 );\r\n				this._z = Math.atan2( - m12, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = Math.atan2( m32, m22 );\r\n				this._z = 0;\r\n\r\n			}\r\n\r\n		} else if ( order === 'YXZ' ) {\r\n\r\n			this._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n				this._y = Math.atan2( m13, m33 );\r\n				this._z = Math.atan2( m21, m22 );\r\n\r\n			} else {\r\n\r\n				this._y = Math.atan2( - m31, m11 );\r\n				this._z = 0;\r\n\r\n			}\r\n\r\n		} else if ( order === 'ZXY' ) {\r\n\r\n			this._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n				this._y = Math.atan2( - m31, m33 );\r\n				this._z = Math.atan2( - m12, m22 );\r\n\r\n			} else {\r\n\r\n				this._y = 0;\r\n				this._z = Math.atan2( m21, m11 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'ZYX' ) {\r\n\r\n			this._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( m32, m33 );\r\n				this._z = Math.atan2( m21, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = 0;\r\n				this._z = Math.atan2( - m12, m22 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'YZX' ) {\r\n\r\n			this._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( - m23, m22 );\r\n				this._y = Math.atan2( - m31, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = 0;\r\n				this._y = Math.atan2( m13, m33 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'XZY' ) {\r\n\r\n			this._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( m32, m22 );\r\n				this._y = Math.atan2( m13, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = Math.atan2( - m23, m33 );\r\n				this._y = 0;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n		}\r\n\r\n		this._order = order;\r\n\r\n		if ( update !== false ) this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromQuaternion: function () {\r\n\r\n		var matrix;\r\n\r\n		return function ( q, order, update ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n			matrix.makeRotationFromQuaternion( q );\r\n			this.setFromRotationMatrix( matrix, order, update );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setFromVector3: function ( v, order ) {\r\n\r\n		return this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n	},\r\n\r\n	reorder: function () {\r\n\r\n		// WARNING: this discards revolution information -bhouston\r\n\r\n		var q = new THREE.Quaternion();\r\n\r\n		return function ( newOrder ) {\r\n\r\n			q.setFromEuler( this );\r\n			this.setFromQuaternion( q, newOrder );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	equals: function ( euler ) {\r\n\r\n		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this._x = array[ 0 ];\r\n		this._y = array[ 1 ];\r\n		this._z = array[ 2 ];\r\n		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this._x;\r\n		array[ offset + 1 ] = this._y;\r\n		array[ offset + 2 ] = this._z;\r\n		array[ offset + 3 ] = this._order;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	toVector3: function ( optionalResult ) {\r\n\r\n		if ( optionalResult ) {\r\n\r\n			return optionalResult.set( this._x, this._y, this._z );\r\n\r\n		} else {\r\n\r\n			return new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	onChange: function ( callback ) {\r\n\r\n		this.onChangeCallback = callback;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	onChangeCallback: function () {}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n	this.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n	this.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n	constructor: THREE.Line3,\r\n\r\n	set: function ( start, end ) {\r\n\r\n		this.start.copy( start );\r\n		this.end.copy( end );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( line ) {\r\n\r\n		this.start.copy( line.start );\r\n		this.end.copy( line.end );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	delta: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.subVectors( this.end, this.start );\r\n\r\n	},\r\n\r\n	distanceSq: function () {\r\n\r\n		return this.start.distanceToSquared( this.end );\r\n\r\n	},\r\n\r\n	distance: function () {\r\n\r\n		return this.start.distanceTo( this.end );\r\n\r\n	},\r\n\r\n	at: function ( t, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n	},\r\n\r\n	closestPointToPointParameter: function () {\r\n\r\n		var startP = new THREE.Vector3();\r\n		var startEnd = new THREE.Vector3();\r\n\r\n		return function ( point, clampToLine ) {\r\n\r\n			startP.subVectors( point, this.start );\r\n			startEnd.subVectors( this.end, this.start );\r\n\r\n			var startEnd2 = startEnd.dot( startEnd );\r\n			var startEnd_startP = startEnd.dot( startP );\r\n\r\n			var t = startEnd_startP / startEnd2;\r\n\r\n			if ( clampToLine ) {\r\n\r\n				t = THREE.Math.clamp( t, 0, 1 );\r\n\r\n			}\r\n\r\n			return t;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n		var t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( matrix ) {\r\n\r\n		this.start.applyMatrix4( matrix );\r\n		this.end.applyMatrix4( matrix );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( line ) {\r\n\r\n		return line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n	constructor: THREE.Box2,\r\n\r\n	set: function ( min, max ) {\r\n\r\n		this.min.copy( min );\r\n		this.max.copy( max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function ( points ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n			this.expandByPoint( points[ i ] )\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCenterAndSize: function () {\r\n\r\n		var v1 = new THREE.Vector2();\r\n\r\n		return function ( center, size ) {\r\n\r\n			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n			this.min.copy( center ).sub( halfSize );\r\n			this.max.copy( center ).add( halfSize );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n	\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( box ) {\r\n\r\n		this.min.copy( box.min );\r\n		this.max.copy( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeEmpty: function () {\r\n\r\n		this.min.x = this.min.y = Infinity;\r\n		this.max.x = this.max.y = - Infinity;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	size: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.subVectors( this.max, this.min );\r\n\r\n	},\r\n\r\n	expandByPoint: function ( point ) {\r\n\r\n		this.min.min( point );\r\n		this.max.max( point );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByVector: function ( vector ) {\r\n\r\n		this.min.sub( vector );\r\n		this.max.add( vector );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByScalar: function ( scalar ) {\r\n\r\n		this.min.addScalar( - scalar );\r\n		this.max.addScalar( scalar );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		if ( point.x < this.min.x || point.x > this.max.x ||\r\n		     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	containsBox: function ( box ) {\r\n\r\n		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	getParameter: function ( point, optionalTarget ) {\r\n\r\n		// This can potentially have a divide by zero if the box\r\n		// has a size dimension of 0.\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n\r\n		return result.set(\r\n			( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n			( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n		);\r\n\r\n	},\r\n\r\n	isIntersectionBox: function ( box ) {\r\n\r\n		// using 6 splitting planes to rule out intersections.\r\n\r\n		if ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n		     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.copy( point ).clamp( this.min, this.max );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector2();\r\n\r\n		return function ( point ) {\r\n\r\n			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n			return clampedPoint.sub( point ).length();\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersect: function ( box ) {\r\n\r\n		this.min.max( box.min );\r\n		this.max.min( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	union: function ( box ) {\r\n\r\n		this.min.min( box.min );\r\n		this.max.max( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.min.add( offset );\r\n		this.max.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( box ) {\r\n\r\n		return box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n	constructor: THREE.Box3,\r\n\r\n	set: function ( min, max ) {\r\n\r\n		this.min.copy( min );\r\n		this.max.copy( max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function ( points ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n			this.expandByPoint( points[ i ] );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCenterAndSize: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( center, size ) {\r\n\r\n			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n			this.min.copy( center ).sub( halfSize );\r\n			this.max.copy( center ).add( halfSize );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setFromObject: function () {\r\n\r\n		// Computes the world-axis-aligned bounding box of an object (including its children),\r\n		// accounting for both the object's, and children's, world transforms\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( object ) {\r\n\r\n			var scope = this;\r\n\r\n			object.updateMatrixWorld( true );\r\n\r\n			this.makeEmpty();\r\n\r\n			object.traverse( function ( node ) {\r\n\r\n				var geometry = node.geometry;\r\n\r\n				if ( geometry !== undefined ) {\r\n\r\n					if ( geometry instanceof THREE.Geometry ) {\r\n\r\n						var vertices = geometry.vertices;\r\n\r\n						for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n							v1.copy( vertices[ i ] );\r\n\r\n							v1.applyMatrix4( node.matrixWorld );\r\n\r\n							scope.expandByPoint( v1 );\r\n\r\n						}\r\n\r\n					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\r\n						var positions = geometry.attributes[ 'position' ].array;\r\n\r\n						for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n							v1.applyMatrix4( node.matrixWorld );\r\n\r\n							scope.expandByPoint( v1 );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( box ) {\r\n\r\n		this.min.copy( box.min );\r\n		this.max.copy( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeEmpty: function () {\r\n\r\n		this.min.x = this.min.y = this.min.z = Infinity;\r\n		this.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	size: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.subVectors( this.max, this.min );\r\n\r\n	},\r\n\r\n	expandByPoint: function ( point ) {\r\n\r\n		this.min.min( point );\r\n		this.max.max( point );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByVector: function ( vector ) {\r\n\r\n		this.min.sub( vector );\r\n		this.max.add( vector );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByScalar: function ( scalar ) {\r\n\r\n		this.min.addScalar( - scalar );\r\n		this.max.addScalar( scalar );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		if ( point.x < this.min.x || point.x > this.max.x ||\r\n		     point.y < this.min.y || point.y > this.max.y ||\r\n		     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	containsBox: function ( box ) {\r\n\r\n		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	getParameter: function ( point, optionalTarget ) {\r\n\r\n		// This can potentially have a divide by zero if the box\r\n		// has a size dimension of 0.\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return result.set(\r\n			( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n			( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n			( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n		);\r\n\r\n	},\r\n\r\n	isIntersectionBox: function ( box ) {\r\n\r\n		// using 6 splitting planes to rule out intersections.\r\n\r\n		if ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n		     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n		     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( point ).clamp( this.min, this.max );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( point ) {\r\n\r\n			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n			return clampedPoint.sub( point ).length();\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getBoundingSphere: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Sphere();\r\n\r\n			result.center = this.center();\r\n			result.radius = this.size( v1 ).length() * 0.5;\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersect: function ( box ) {\r\n\r\n		this.min.max( box.min );\r\n		this.max.min( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	union: function ( box ) {\r\n\r\n		this.min.min( box.min );\r\n		this.max.max( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function () {\r\n\r\n		var points = [\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3()\r\n		];\r\n\r\n		return function ( matrix ) {\r\n\r\n			// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n			this.makeEmpty();\r\n			this.setFromPoints( points );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.min.add( offset );\r\n		this.max.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( box ) {\r\n\r\n		return box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n	this.elements = new Float32Array( [\r\n\r\n		1, 0, 0,\r\n		0, 1, 0,\r\n		0, 0, 1\r\n\r\n	] );\r\n\r\n	if ( arguments.length > 0 ) {\r\n\r\n		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n	constructor: THREE.Matrix3,\r\n\r\n	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	identity: function () {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0,\r\n			0, 1, 0,\r\n			0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().fromArray( this.elements );\r\n\r\n	},\r\n\r\n	copy: function ( m ) {\r\n\r\n		var me = m.elements;\r\n\r\n		this.set(\r\n\r\n			me[ 0 ], me[ 3 ], me[ 6 ],\r\n			me[ 1 ], me[ 4 ], me[ 7 ],\r\n			me[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVector3: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n		return vector.applyMatrix3( this );\r\n\r\n	},\r\n\r\n	multiplyVector3Array: function ( a ) {\r\n\r\n		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n		return this.applyToVector3Array( a );\r\n\r\n	},\r\n\r\n	applyToVector3Array: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( array, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = array.length;\r\n\r\n			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n				v1.fromArray( array, j );\r\n				v1.applyMatrix3( this );\r\n				v1.toArray( array, j );\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyToBuffer: function () {\r\n\r\n		var v1;\r\n\r\n		return function applyToBuffer( buffer, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n				v1.x = buffer.getX( j );\r\n				v1.y = buffer.getY( j );\r\n				v1.z = buffer.getZ( j );\r\n\r\n				v1.applyMatrix3( this );\r\n\r\n				buffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n			}\r\n\r\n			return buffer;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	determinant: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n	},\r\n\r\n	getInverse: function ( matrix, throwOnInvertible ) {\r\n\r\n		// input: THREE.Matrix4\r\n		// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n		var me = matrix.elements;\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\r\n		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n		// no inverse\r\n\r\n		if ( det === 0 ) {\r\n\r\n			var msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n			if ( throwOnInvertible || false ) {\r\n\r\n				throw new Error( msg );\r\n\r\n			} else {\r\n\r\n				console.warn( msg );\r\n\r\n			}\r\n\r\n			this.identity();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		this.multiplyScalar( 1.0 / det );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	transpose: function () {\r\n\r\n		var tmp, m = this.elements;\r\n\r\n		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	flattenToArrayOffset: function ( array, offset ) {\r\n\r\n		var te = this.elements;\r\n\r\n		array[ offset ] = te[ 0 ];\r\n		array[ offset + 1 ] = te[ 1 ];\r\n		array[ offset + 2 ] = te[ 2 ];\r\n\r\n		array[ offset + 3 ] = te[ 3 ];\r\n		array[ offset + 4 ] = te[ 4 ];\r\n		array[ offset + 5 ] = te[ 5 ];\r\n\r\n		array[ offset + 6 ] = te[ 6 ];\r\n		array[ offset + 7 ] = te[ 7 ];\r\n		array[ offset + 8 ]  = te[ 8 ];\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	getNormalMatrix: function ( m ) {\r\n\r\n		// input: THREE.Matrix4\r\n\r\n		this.getInverse( m ).transpose();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	transposeIntoArray: function ( r ) {\r\n\r\n		var m = this.elements;\r\n\r\n		r[ 0 ] = m[ 0 ];\r\n		r[ 1 ] = m[ 3 ];\r\n		r[ 2 ] = m[ 6 ];\r\n		r[ 3 ] = m[ 1 ];\r\n		r[ 4 ] = m[ 4 ];\r\n		r[ 5 ] = m[ 7 ];\r\n		r[ 6 ] = m[ 2 ];\r\n		r[ 7 ] = m[ 5 ];\r\n		r[ 8 ] = m[ 8 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.elements.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		return [\r\n			te[ 0 ], te[ 1 ], te[ 2 ],\r\n			te[ 3 ], te[ 4 ], te[ 5 ],\r\n			te[ 6 ], te[ 7 ], te[ 8 ]\r\n		];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n	this.elements = new Float32Array( [\r\n\r\n		1, 0, 0, 0,\r\n		0, 1, 0, 0,\r\n		0, 0, 1, 0,\r\n		0, 0, 0, 1\r\n\r\n	] );\r\n\r\n	if ( arguments.length > 0 ) {\r\n\r\n		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n	constructor: THREE.Matrix4,\r\n\r\n	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	identity: function () {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0, 0,\r\n			0, 1, 0, 0,\r\n			0, 0, 1, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Matrix4().fromArray( this.elements );\r\n\r\n	},\r\n\r\n	copy: function ( m ) {\r\n\r\n		this.elements.set( m.elements );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractPosition: function ( m ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n		return this.copyPosition( m );\r\n\r\n	},\r\n\r\n	copyPosition: function ( m ) {\r\n\r\n		var te = this.elements;\r\n		var me = m.elements;\r\n\r\n		te[ 12 ] = me[ 12 ];\r\n		te[ 13 ] = me[ 13 ];\r\n		te[ 14 ] = me[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n		var te = this.elements;\r\n\r\n		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n		this.set(\r\n			xAxis.x, yAxis.x, zAxis.x, 0,\r\n			xAxis.y, yAxis.y, zAxis.y, 0,\r\n			xAxis.z, yAxis.z, zAxis.z, 0,\r\n			0,       0,       0,       1\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractRotation: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( m ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			var te = this.elements;\r\n			var me = m.elements;\r\n\r\n			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\r\n			te[ 0 ] = me[ 0 ] * scaleX;\r\n			te[ 1 ] = me[ 1 ] * scaleX;\r\n			te[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n			te[ 4 ] = me[ 4 ] * scaleY;\r\n			te[ 5 ] = me[ 5 ] * scaleY;\r\n			te[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n			te[ 8 ] = me[ 8 ] * scaleZ;\r\n			te[ 9 ] = me[ 9 ] * scaleZ;\r\n			te[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	makeRotationFromEuler: function ( euler ) {\r\n\r\n		if ( euler instanceof THREE.Euler === false ) {\r\n\r\n			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n		}\r\n\r\n		var te = this.elements;\r\n\r\n		var x = euler.x, y = euler.y, z = euler.z;\r\n		var a = Math.cos( x ), b = Math.sin( x );\r\n		var c = Math.cos( y ), d = Math.sin( y );\r\n		var e = Math.cos( z ), f = Math.sin( z );\r\n\r\n		if ( euler.order === 'XYZ' ) {\r\n\r\n			var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = - c * f;\r\n			te[ 8 ] = d;\r\n\r\n			te[ 1 ] = af + be * d;\r\n			te[ 5 ] = ae - bf * d;\r\n			te[ 9 ] = - b * c;\r\n\r\n			te[ 2 ] = bf - ae * d;\r\n			te[ 6 ] = be + af * d;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'YXZ' ) {\r\n\r\n			var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n			te[ 0 ] = ce + df * b;\r\n			te[ 4 ] = de * b - cf;\r\n			te[ 8 ] = a * d;\r\n\r\n			te[ 1 ] = a * f;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = - b;\r\n\r\n			te[ 2 ] = cf * b - de;\r\n			te[ 6 ] = df + ce * b;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'ZXY' ) {\r\n\r\n			var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n			te[ 0 ] = ce - df * b;\r\n			te[ 4 ] = - a * f;\r\n			te[ 8 ] = de + cf * b;\r\n\r\n			te[ 1 ] = cf + de * b;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = df - ce * b;\r\n\r\n			te[ 2 ] = - a * d;\r\n			te[ 6 ] = b;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'ZYX' ) {\r\n\r\n			var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = be * d - af;\r\n			te[ 8 ] = ae * d + bf;\r\n\r\n			te[ 1 ] = c * f;\r\n			te[ 5 ] = bf * d + ae;\r\n			te[ 9 ] = af * d - be;\r\n\r\n			te[ 2 ] = - d;\r\n			te[ 6 ] = b * c;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'YZX' ) {\r\n\r\n			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = bd - ac * f;\r\n			te[ 8 ] = bc * f + ad;\r\n\r\n			te[ 1 ] = f;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = - b * e;\r\n\r\n			te[ 2 ] = - d * e;\r\n			te[ 6 ] = ad * f + bc;\r\n			te[ 10 ] = ac - bd * f;\r\n\r\n		} else if ( euler.order === 'XZY' ) {\r\n\r\n			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = - f;\r\n			te[ 8 ] = d * e;\r\n\r\n			te[ 1 ] = ac * f + bd;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = ad * f - bc;\r\n\r\n			te[ 2 ] = bc * f - ad;\r\n			te[ 6 ] = b * e;\r\n			te[ 10 ] = bd * f + ac;\r\n\r\n		}\r\n\r\n		// last column\r\n		te[ 3 ] = 0;\r\n		te[ 7 ] = 0;\r\n		te[ 11 ] = 0;\r\n\r\n		// bottom row\r\n		te[ 12 ] = 0;\r\n		te[ 13 ] = 0;\r\n		te[ 14 ] = 0;\r\n		te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setRotationFromQuaternion: function ( q ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\r\n		return this.makeRotationFromQuaternion( q );\r\n\r\n	},\r\n\r\n	makeRotationFromQuaternion: function ( q ) {\r\n\r\n		var te = this.elements;\r\n\r\n		var x = q.x, y = q.y, z = q.z, w = q.w;\r\n		var x2 = x + x, y2 = y + y, z2 = z + z;\r\n		var xx = x * x2, xy = x * y2, xz = x * z2;\r\n		var yy = y * y2, yz = y * z2, zz = z * z2;\r\n		var wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n		te[ 0 ] = 1 - ( yy + zz );\r\n		te[ 4 ] = xy - wz;\r\n		te[ 8 ] = xz + wy;\r\n\r\n		te[ 1 ] = xy + wz;\r\n		te[ 5 ] = 1 - ( xx + zz );\r\n		te[ 9 ] = yz - wx;\r\n\r\n		te[ 2 ] = xz - wy;\r\n		te[ 6 ] = yz + wx;\r\n		te[ 10 ] = 1 - ( xx + yy );\r\n\r\n		// last column\r\n		te[ 3 ] = 0;\r\n		te[ 7 ] = 0;\r\n		te[ 11 ] = 0;\r\n\r\n		// bottom row\r\n		te[ 12 ] = 0;\r\n		te[ 13 ] = 0;\r\n		te[ 14 ] = 0;\r\n		te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lookAt: function () {\r\n\r\n		var x, y, z;\r\n\r\n		return function ( eye, target, up ) {\r\n\r\n			if ( x === undefined ) x = new THREE.Vector3();\r\n			if ( y === undefined ) y = new THREE.Vector3();\r\n			if ( z === undefined ) z = new THREE.Vector3();\r\n\r\n			var te = this.elements;\r\n\r\n			z.subVectors( eye, target ).normalize();\r\n\r\n			if ( z.length() === 0 ) {\r\n\r\n				z.z = 1;\r\n\r\n			}\r\n\r\n			x.crossVectors( up, z ).normalize();\r\n\r\n			if ( x.length() === 0 ) {\r\n\r\n				z.x += 0.0001;\r\n				x.crossVectors( up, z ).normalize();\r\n\r\n			}\r\n\r\n			y.crossVectors( z, x );\r\n\r\n\r\n			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	multiply: function ( m, n ) {\r\n\r\n		if ( n !== undefined ) {\r\n\r\n			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n			return this.multiplyMatrices( m, n );\r\n\r\n		}\r\n\r\n		return this.multiplyMatrices( this, m );\r\n\r\n	},\r\n\r\n	multiplyMatrices: function ( a, b ) {\r\n\r\n		var ae = a.elements;\r\n		var be = b.elements;\r\n		var te = this.elements;\r\n\r\n		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyToArray: function ( a, b, r ) {\r\n\r\n		var te = this.elements;\r\n\r\n		this.multiplyMatrices( a, b );\r\n\r\n		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVector3: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n		return vector.applyProjection( this );\r\n\r\n	},\r\n\r\n	multiplyVector4: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n		return vector.applyMatrix4( this );\r\n\r\n	},\r\n\r\n	multiplyVector3Array: function ( a ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n		return this.applyToVector3Array( a );\r\n\r\n	},\r\n\r\n	applyToVector3Array: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( array, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = array.length;\r\n\r\n			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n				v1.fromArray( array, j );\r\n				v1.applyMatrix4( this );\r\n				v1.toArray( array, j );\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyToBuffer: function () {\r\n\r\n		var v1;\r\n\r\n		return function applyToBuffer( buffer, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n				v1.x = buffer.getX( j );\r\n				v1.y = buffer.getY( j );\r\n				v1.z = buffer.getZ( j );\r\n\r\n				v1.applyMatrix4( this );\r\n\r\n				buffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n			}\r\n\r\n			return buffer;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateAxis: function ( v ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\r\n		v.transformDirection( this );\r\n\r\n	},\r\n\r\n	crossVector: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n		return vector.applyMatrix4( this );\r\n\r\n	},\r\n\r\n	determinant: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n		//TODO: make this more efficient\r\n		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n		return (\r\n			n41 * (\r\n				+ n14 * n23 * n32\r\n				 - n13 * n24 * n32\r\n				 - n14 * n22 * n33\r\n				 + n12 * n24 * n33\r\n				 + n13 * n22 * n34\r\n				 - n12 * n23 * n34\r\n			) +\r\n			n42 * (\r\n				+ n11 * n23 * n34\r\n				 - n11 * n24 * n33\r\n				 + n14 * n21 * n33\r\n				 - n13 * n21 * n34\r\n				 + n13 * n24 * n31\r\n				 - n14 * n23 * n31\r\n			) +\r\n			n43 * (\r\n				+ n11 * n24 * n32\r\n				 - n11 * n22 * n34\r\n				 - n14 * n21 * n32\r\n				 + n12 * n21 * n34\r\n				 + n14 * n22 * n31\r\n				 - n12 * n24 * n31\r\n			) +\r\n			n44 * (\r\n				- n13 * n22 * n31\r\n				 - n11 * n23 * n32\r\n				 + n11 * n22 * n33\r\n				 + n13 * n21 * n32\r\n				 - n12 * n21 * n33\r\n				 + n12 * n23 * n31\r\n			)\r\n\r\n		);\r\n\r\n	},\r\n\r\n	transpose: function () {\r\n\r\n		var te = this.elements;\r\n		var tmp;\r\n\r\n		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	flattenToArrayOffset: function ( array, offset ) {\r\n\r\n		var te = this.elements;\r\n\r\n		array[ offset ] = te[ 0 ];\r\n		array[ offset + 1 ] = te[ 1 ];\r\n		array[ offset + 2 ] = te[ 2 ];\r\n		array[ offset + 3 ] = te[ 3 ];\r\n\r\n		array[ offset + 4 ] = te[ 4 ];\r\n		array[ offset + 5 ] = te[ 5 ];\r\n		array[ offset + 6 ] = te[ 6 ];\r\n		array[ offset + 7 ] = te[ 7 ];\r\n\r\n		array[ offset + 8 ]  = te[ 8 ];\r\n		array[ offset + 9 ]  = te[ 9 ];\r\n		array[ offset + 10 ] = te[ 10 ];\r\n		array[ offset + 11 ] = te[ 11 ];\r\n\r\n		array[ offset + 12 ] = te[ 12 ];\r\n		array[ offset + 13 ] = te[ 13 ];\r\n		array[ offset + 14 ] = te[ 14 ];\r\n		array[ offset + 15 ] = te[ 15 ];\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	getPosition: function () {\r\n\r\n		var v1;\r\n\r\n		return function () {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n			var te = this.elements;\r\n			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setPosition: function ( v ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 12 ] = v.x;\r\n		te[ 13 ] = v.y;\r\n		te[ 14 ] = v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getInverse: function ( m, throwOnInvertible ) {\r\n\r\n		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n		var te = this.elements;\r\n		var me = m.elements;\r\n\r\n		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\r\n		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\r\n		if ( det === 0 ) {\r\n\r\n			var msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n			if ( throwOnInvertible || false ) {\r\n\r\n				throw new Error( msg );\r\n\r\n			} else {\r\n\r\n				console.warn( msg );\r\n\r\n			}\r\n\r\n			this.identity();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		this.multiplyScalar( 1 / det );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( v ) {\r\n\r\n		console.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateX: function ( angle ) {\r\n\r\n		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateY: function ( angle ) {\r\n\r\n		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateZ: function ( angle ) {\r\n\r\n		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateByAxis: function ( axis, angle ) {\r\n\r\n		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\r\n	},\r\n\r\n	scale: function ( v ) {\r\n\r\n		var te = this.elements;\r\n		var x = v.x, y = v.y, z = v.z;\r\n\r\n		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getMaxScaleOnAxis: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n	},\r\n\r\n	makeTranslation: function ( x, y, z ) {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0, x,\r\n			0, 1, 0, y,\r\n			0, 0, 1, z,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationX: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			1, 0,  0, 0,\r\n			0, c, - s, 0,\r\n			0, s,  c, 0,\r\n			0, 0,  0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationY: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			 c, 0, s, 0,\r\n			 0, 1, 0, 0,\r\n			- s, 0, c, 0,\r\n			 0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationZ: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			c, - s, 0, 0,\r\n			s,  c, 0, 0,\r\n			0,  0, 1, 0,\r\n			0,  0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationAxis: function ( axis, angle ) {\r\n\r\n		// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n		var c = Math.cos( angle );\r\n		var s = Math.sin( angle );\r\n		var t = 1 - c;\r\n		var x = axis.x, y = axis.y, z = axis.z;\r\n		var tx = t * x, ty = t * y;\r\n\r\n		this.set(\r\n\r\n			tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n			tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		 return this;\r\n\r\n	},\r\n\r\n	makeScale: function ( x, y, z ) {\r\n\r\n		this.set(\r\n\r\n			x, 0, 0, 0,\r\n			0, y, 0, 0,\r\n			0, 0, z, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	compose: function ( position, quaternion, scale ) {\r\n\r\n		this.makeRotationFromQuaternion( quaternion );\r\n		this.scale( scale );\r\n		this.setPosition( position );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	decompose: function () {\r\n\r\n		var vector, matrix;\r\n\r\n		return function ( position, quaternion, scale ) {\r\n\r\n			if ( vector === undefined ) vector = new THREE.Vector3();\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			var te = this.elements;\r\n\r\n			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n			// if determine is negative, we need to invert one scale\r\n			var det = this.determinant();\r\n			if ( det < 0 ) {\r\n\r\n				sx = - sx;\r\n\r\n			}\r\n\r\n			position.x = te[ 12 ];\r\n			position.y = te[ 13 ];\r\n			position.z = te[ 14 ];\r\n\r\n			// scale the rotation part\r\n\r\n			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n			var invSX = 1 / sx;\r\n			var invSY = 1 / sy;\r\n			var invSZ = 1 / sz;\r\n\r\n			matrix.elements[ 0 ] *= invSX;\r\n			matrix.elements[ 1 ] *= invSX;\r\n			matrix.elements[ 2 ] *= invSX;\r\n\r\n			matrix.elements[ 4 ] *= invSY;\r\n			matrix.elements[ 5 ] *= invSY;\r\n			matrix.elements[ 6 ] *= invSY;\r\n\r\n			matrix.elements[ 8 ] *= invSZ;\r\n			matrix.elements[ 9 ] *= invSZ;\r\n			matrix.elements[ 10 ] *= invSZ;\r\n\r\n			quaternion.setFromRotationMatrix( matrix );\r\n\r\n			scale.x = sx;\r\n			scale.y = sy;\r\n			scale.z = sz;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	makeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n		var te = this.elements;\r\n		var x = 2 * near / ( right - left );\r\n		var y = 2 * near / ( top - bottom );\r\n\r\n		var a = ( right + left ) / ( right - left );\r\n		var b = ( top + bottom ) / ( top - bottom );\r\n		var c = - ( far + near ) / ( far - near );\r\n		var d = - 2 * far * near / ( far - near );\r\n\r\n		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;\r\n		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;\r\n		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;\r\n		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makePerspective: function ( fov, aspect, near, far ) {\r\n\r\n		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n		var ymin = - ymax;\r\n		var xmin = ymin * aspect;\r\n		var xmax = ymax * aspect;\r\n\r\n		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n	},\r\n\r\n	makeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n		var te = this.elements;\r\n		var w = right - left;\r\n		var h = top - bottom;\r\n		var p = far - near;\r\n\r\n		var x = ( right + left ) / w;\r\n		var y = ( top + bottom ) / h;\r\n		var z = ( far + near ) / p;\r\n\r\n		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;\r\n		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;\r\n		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;\r\n		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( matrix ) {\r\n\r\n		var te = this.elements;\r\n		var me = matrix.elements;\r\n\r\n		for ( var i = 0; i < 16; i ++ ) {\r\n\r\n			if ( te[ i ] !== me[ i ] ) return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.elements.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		return [\r\n			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n		];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n	constructor: THREE.Ray,\r\n\r\n	set: function ( origin, direction ) {\r\n\r\n		this.origin.copy( origin );\r\n		this.direction.copy( direction );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( ray ) {\r\n\r\n		this.origin.copy( ray.origin );\r\n		this.direction.copy( ray.direction );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	at: function ( t, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n	},\r\n\r\n	recast: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( t ) {\r\n\r\n			this.origin.copy( this.at( t, v1 ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	closestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		result.subVectors( point, this.origin );\r\n		var directionDistance = result.dot( this.direction );\r\n\r\n		if ( directionDistance < 0 ) {\r\n\r\n			return result.copy( this.origin );\r\n\r\n		}\r\n\r\n		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n	},\r\n\r\n	distanceSqToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( point ) {\r\n\r\n			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n			// point behind the ray\r\n\r\n			if ( directionDistance < 0 ) {\r\n\r\n				return this.origin.distanceToSquared( point );\r\n\r\n			}\r\n\r\n			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n			return v1.distanceToSquared( point );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	distanceSqToSegment: function () {\r\n\r\n		var segCenter = new THREE.Vector3();\r\n		var segDir = new THREE.Vector3();\r\n		var diff = new THREE.Vector3();\r\n\r\n		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n			// It returns the min distance between the ray and the segment\r\n			// defined by v0 and v1\r\n			// It can also set two optional targets :\r\n			// - The closest point on the ray\r\n			// - The closest point on the segment\r\n\r\n			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n			segDir.copy( v1 ).sub( v0 ).normalize();\r\n			diff.copy( this.origin ).sub( segCenter );\r\n\r\n			var segExtent = v0.distanceTo( v1 ) * 0.5;\r\n			var a01 = - this.direction.dot( segDir );\r\n			var b0 = diff.dot( this.direction );\r\n			var b1 = - diff.dot( segDir );\r\n			var c = diff.lengthSq();\r\n			var det = Math.abs( 1 - a01 * a01 );\r\n			var s0, s1, sqrDist, extDet;\r\n\r\n			if ( det > 0 ) {\r\n\r\n				// The ray and segment are not parallel.\r\n\r\n				s0 = a01 * b1 - b0;\r\n				s1 = a01 * b0 - b1;\r\n				extDet = segExtent * det;\r\n\r\n				if ( s0 >= 0 ) {\r\n\r\n					if ( s1 >= - extDet ) {\r\n\r\n						if ( s1 <= extDet ) {\r\n\r\n							// region 0\r\n							// Minimum at interior points of ray and segment.\r\n\r\n							var invDet = 1 / det;\r\n							s0 *= invDet;\r\n							s1 *= invDet;\r\n							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n						} else {\r\n\r\n							// region 1\r\n\r\n							s1 = segExtent;\r\n							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						// region 5\r\n\r\n						s1 = - segExtent;\r\n						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					if ( s1 <= - extDet ) {\r\n\r\n						// region 4\r\n\r\n						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					} else if ( s1 <= extDet ) {\r\n\r\n						// region 3\r\n\r\n						s0 = 0;\r\n						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					} else {\r\n\r\n						// region 2\r\n\r\n						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// Ray and segment are parallel.\r\n\r\n				s1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n			}\r\n\r\n			if ( optionalPointOnRay ) {\r\n\r\n				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n			}\r\n\r\n			if ( optionalPointOnSegment ) {\r\n\r\n				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n			}\r\n\r\n			return sqrDist;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	isIntersectionSphere: function ( sphere ) {\r\n\r\n		return this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n	},\r\n\r\n	intersectSphere: function () {\r\n\r\n		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( sphere, optionalTarget ) {\r\n\r\n			v1.subVectors( sphere.center, this.origin );\r\n\r\n			var tca = v1.dot( this.direction );\r\n\r\n			var d2 = v1.dot( v1 ) - tca * tca;\r\n\r\n			var radius2 = sphere.radius * sphere.radius;\r\n\r\n			if ( d2 > radius2 ) return null;\r\n\r\n			var thc = Math.sqrt( radius2 - d2 );\r\n\r\n			// t0 = first intersect point - entrance on front of sphere\r\n			var t0 = tca - thc;\r\n\r\n			// t1 = second intersect point - exit point on back of sphere\r\n			var t1 = tca + thc;\r\n\r\n			// test to see if both t0 and t1 are behind the ray - if so, return null\r\n			if ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n			// test to see if t0 is behind the ray:\r\n			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n			// in order to always return an intersect point that is in front of the ray.\r\n			if ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n			// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n			return this.at( t0, optionalTarget );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	isIntersectionPlane: function ( plane ) {\r\n\r\n		// check if the ray lies on the plane first\r\n\r\n		var distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n		if ( distToPoint === 0 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		var denominator = plane.normal.dot( this.direction );\r\n\r\n		if ( denominator * distToPoint < 0 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		// ray origin is behind the plane (and is pointing behind it)\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	distanceToPlane: function ( plane ) {\r\n\r\n		var denominator = plane.normal.dot( this.direction );\r\n		if ( denominator === 0 ) {\r\n\r\n			// line is coplanar, return origin\r\n			if ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n				return 0;\r\n\r\n			}\r\n\r\n			// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n			return null;\r\n\r\n		}\r\n\r\n		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n		// Return if the ray never intersects the plane\r\n\r\n		return t >= 0 ? t :  null;\r\n\r\n	},\r\n\r\n	intersectPlane: function ( plane, optionalTarget ) {\r\n\r\n		var t = this.distanceToPlane( plane );\r\n\r\n		if ( t === null ) {\r\n\r\n			return null;\r\n\r\n		}\r\n\r\n		return this.at( t, optionalTarget );\r\n\r\n	},\r\n\r\n	isIntersectionBox: function () {\r\n\r\n		var v = new THREE.Vector3();\r\n\r\n		return function ( box ) {\r\n\r\n			return this.intersectBox( box, v ) !== null;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectBox: function ( box, optionalTarget ) {\r\n\r\n		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\r\n		var tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n		var invdirx = 1 / this.direction.x,\r\n			invdiry = 1 / this.direction.y,\r\n			invdirz = 1 / this.direction.z;\r\n\r\n		var origin = this.origin;\r\n\r\n		if ( invdirx >= 0 ) {\r\n\r\n			tmin = ( box.min.x - origin.x ) * invdirx;\r\n			tmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n		} else {\r\n\r\n			tmin = ( box.max.x - origin.x ) * invdirx;\r\n			tmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n		}\r\n\r\n		if ( invdiry >= 0 ) {\r\n\r\n			tymin = ( box.min.y - origin.y ) * invdiry;\r\n			tymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n		} else {\r\n\r\n			tymin = ( box.max.y - origin.y ) * invdiry;\r\n			tymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n		}\r\n\r\n		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n		// These lines also handle the case where tmin or tmax is NaN\r\n		// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n		if ( invdirz >= 0 ) {\r\n\r\n			tzmin = ( box.min.z - origin.z ) * invdirz;\r\n			tzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n		} else {\r\n\r\n			tzmin = ( box.max.z - origin.z ) * invdirz;\r\n			tzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n		}\r\n\r\n		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n		//return point closest to the ray (positive side)\r\n\r\n		if ( tmax < 0 ) return null;\r\n\r\n		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n	},\r\n\r\n	intersectTriangle: function () {\r\n\r\n		// Compute the offset origin, edges, and normal.\r\n		var diff = new THREE.Vector3();\r\n		var edge1 = new THREE.Vector3();\r\n		var edge2 = new THREE.Vector3();\r\n		var normal = new THREE.Vector3();\r\n\r\n		return function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n			edge1.subVectors( b, a );\r\n			edge2.subVectors( c, a );\r\n			normal.crossVectors( edge1, edge2 );\r\n\r\n			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n			var DdN = this.direction.dot( normal );\r\n			var sign;\r\n\r\n			if ( DdN > 0 ) {\r\n\r\n				if ( backfaceCulling ) return null;\r\n				sign = 1;\r\n\r\n			} else if ( DdN < 0 ) {\r\n\r\n				sign = - 1;\r\n				DdN = - DdN;\r\n\r\n			} else {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			diff.subVectors( this.origin, a );\r\n			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n			// b1 < 0, no intersection\r\n			if ( DdQxE2 < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n			// b2 < 0, no intersection\r\n			if ( DdE1xQ < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// b1+b2 > 1, no intersection\r\n			if ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// Line intersects triangle, check if ray does.\r\n			var QdN = - sign * diff.dot( normal );\r\n\r\n			// t < 0, no intersection\r\n			if ( QdN < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// Ray intersects triangle.\r\n			return this.at( QdN / DdN, optionalTarget );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyMatrix4: function ( matrix4 ) {\r\n\r\n		this.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n		this.origin.applyMatrix4( matrix4 );\r\n		this.direction.sub( this.origin );\r\n		this.direction.normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( ray ) {\r\n\r\n		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n	this.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n	this.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n	constructor: THREE.Sphere,\r\n\r\n	set: function ( center, radius ) {\r\n\r\n		this.center.copy( center );\r\n		this.radius = radius;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function () {\r\n\r\n		var box = new THREE.Box3();\r\n\r\n		return function ( points, optionalCenter ) {\r\n\r\n			var center = this.center;\r\n\r\n			if ( optionalCenter !== undefined ) {\r\n\r\n				center.copy( optionalCenter );\r\n\r\n			} else {\r\n\r\n				box.setFromPoints( points ).center( center );\r\n\r\n			}\r\n\r\n			var maxRadiusSq = 0;\r\n\r\n			for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n			}\r\n\r\n			this.radius = Math.sqrt( maxRadiusSq );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( sphere ) {\r\n\r\n		this.center.copy( sphere.center );\r\n		this.radius = sphere.radius;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		return ( this.radius <= 0 );\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return ( point.distanceTo( this.center ) - this.radius );\r\n\r\n	},\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		var radiusSum = this.radius + sphere.radius;\r\n\r\n		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		result.copy( point );\r\n\r\n		if ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n			result.sub( this.center ).normalize();\r\n			result.multiplyScalar( this.radius ).add( this.center );\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	},\r\n\r\n	getBoundingBox: function ( optionalTarget ) {\r\n\r\n		var box = optionalTarget || new THREE.Box3();\r\n\r\n		box.set( this.center, this.center );\r\n		box.expandByScalar( this.radius );\r\n\r\n		return box;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( matrix ) {\r\n\r\n		this.center.applyMatrix4( matrix );\r\n		this.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.center.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( sphere ) {\r\n\r\n		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n	this.planes = [\r\n\r\n		( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n		( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n		( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n		( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n		( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n		( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n	];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n	constructor: THREE.Frustum,\r\n\r\n	set: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		planes[ 0 ].copy( p0 );\r\n		planes[ 1 ].copy( p1 );\r\n		planes[ 2 ].copy( p2 );\r\n		planes[ 3 ].copy( p3 );\r\n		planes[ 4 ].copy( p4 );\r\n		planes[ 5 ].copy( p5 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( frustum ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			planes[ i ].copy( frustum.planes[ i ] );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrix: function ( m ) {\r\n\r\n		var planes = this.planes;\r\n		var me = m.elements;\r\n		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	intersectsObject: function () {\r\n\r\n		var sphere = new THREE.Sphere();\r\n\r\n		return function ( object ) {\r\n\r\n			var geometry = object.geometry;\r\n\r\n			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n			sphere.copy( geometry.boundingSphere );\r\n			sphere.applyMatrix4( object.matrixWorld );\r\n\r\n			return this.intersectsSphere( sphere );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		var planes = this.planes;\r\n		var center = sphere.center;\r\n		var negRadius = - sphere.radius;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			var distance = planes[ i ].distanceToPoint( center );\r\n\r\n			if ( distance < negRadius ) {\r\n\r\n				return false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	intersectsBox: function () {\r\n\r\n		var p1 = new THREE.Vector3(),\r\n			p2 = new THREE.Vector3();\r\n\r\n		return function ( box ) {\r\n\r\n			var planes = this.planes;\r\n\r\n			for ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n				var plane = planes[ i ];\r\n\r\n				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n				var d1 = plane.distanceToPoint( p1 );\r\n				var d2 = plane.distanceToPoint( p2 );\r\n\r\n				// if both outside plane, no intersection\r\n\r\n				if ( d1 < 0 && d2 < 0 ) {\r\n\r\n					return false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return true;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			if ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n				return false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n	this.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n	constructor: THREE.Plane,\r\n\r\n	set: function ( normal, constant ) {\r\n\r\n		this.normal.copy( normal );\r\n		this.constant = constant;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponents: function ( x, y, z, w ) {\r\n\r\n		this.normal.set( x, y, z );\r\n		this.constant = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n		this.normal.copy( normal );\r\n		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCoplanarPoints: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n		var v2 = new THREE.Vector3();\r\n\r\n		return function ( a, b, c ) {\r\n\r\n			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n			this.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( plane ) {\r\n\r\n		this.normal.copy( plane.normal );\r\n		this.constant = plane.constant;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n		var inverseNormalLength = 1.0 / this.normal.length();\r\n		this.normal.multiplyScalar( inverseNormalLength );\r\n		this.constant *= inverseNormalLength;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.constant *= - 1;\r\n		this.normal.negate();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return this.normal.dot( point ) + this.constant;\r\n\r\n	},\r\n\r\n	distanceToSphere: function ( sphere ) {\r\n\r\n		return this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n	},\r\n\r\n	projectPoint: function ( point, optionalTarget ) {\r\n\r\n		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n	},\r\n\r\n	orthoPoint: function ( point, optionalTarget ) {\r\n\r\n		var perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n	},\r\n\r\n	isIntersectionLine: function ( line ) {\r\n\r\n		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n		var startSign = this.distanceToPoint( line.start );\r\n		var endSign = this.distanceToPoint( line.end );\r\n\r\n		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n	},\r\n\r\n	intersectLine: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( line, optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			var direction = line.delta( v1 );\r\n\r\n			var denominator = this.normal.dot( direction );\r\n\r\n			if ( denominator === 0 ) {\r\n\r\n				// line is coplanar, return origin\r\n				if ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n					return result.copy( line.start );\r\n\r\n				}\r\n\r\n				// Unsure if this is the correct method to handle this case.\r\n				return undefined;\r\n\r\n			}\r\n\r\n			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n			if ( t < 0 || t > 1 ) {\r\n\r\n				return undefined;\r\n\r\n			}\r\n\r\n			return result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	coplanarPoint: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n	},\r\n\r\n	applyMatrix4: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n		var v2 = new THREE.Vector3();\r\n		var m1 = new THREE.Matrix3();\r\n\r\n		return function ( matrix, optionalNormalMatrix ) {\r\n\r\n			// compute new normal based on theory here:\r\n			// http://www.songho.ca/opengl/gl_normaltransform.html\r\n			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\r\n			var newCoplanarPoint = this.coplanarPoint( v2 );\r\n			newCoplanarPoint.applyMatrix4( matrix );\r\n\r\n			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.constant = this.constant - offset.dot( this.normal );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( plane ) {\r\n\r\n		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n	generateUUID: function () {\r\n\r\n		// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n		var uuid = new Array( 36 );\r\n		var rnd = 0, r;\r\n\r\n		return function () {\r\n\r\n			for ( var i = 0; i < 36; i ++ ) {\r\n\r\n				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\r\n					uuid[ i ] = '-';\r\n\r\n				} else if ( i === 14 ) {\r\n\r\n					uuid[ i ] = '4';\r\n\r\n				} else {\r\n\r\n					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n					r = rnd & 0xf;\r\n					rnd = rnd >> 4;\r\n					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return uuid.join( '' );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	// Clamp value to range <a, b>\r\n\r\n	clamp: function ( x, a, b ) {\r\n\r\n		return ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n	},\r\n\r\n	// Clamp value to range <a, inf)\r\n\r\n	clampBottom: function ( x, a ) {\r\n\r\n		return x < a ? a : x;\r\n\r\n	},\r\n\r\n	// compute euclidian modulo of m % n\r\n	// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n	euclideanModulo: function ( n, m ) {\r\n\r\n		return ( ( n % m ) + m ) % m;\r\n\r\n	},\r\n\r\n	// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n	mapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n	},\r\n\r\n	// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n	smoothstep: function ( x, min, max ) {\r\n\r\n		if ( x <= min ) return 0;\r\n		if ( x >= max ) return 1;\r\n\r\n		x = ( x - min ) / ( max - min );\r\n\r\n		return x * x * ( 3 - 2 * x );\r\n\r\n	},\r\n\r\n	smootherstep: function ( x, min, max ) {\r\n\r\n		if ( x <= min ) return 0;\r\n		if ( x >= max ) return 1;\r\n\r\n		x = ( x - min ) / ( max - min );\r\n\r\n		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n	},\r\n\r\n	// Random float from <0, 1> with 16 bits of randomness\r\n	// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n	random16: function () {\r\n\r\n		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n	},\r\n\r\n	// Random integer from <low, high> interval\r\n\r\n	randInt: function ( low, high ) {\r\n\r\n		return low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n	},\r\n\r\n	// Random float from <low, high> interval\r\n\r\n	randFloat: function ( low, high ) {\r\n\r\n		return low + Math.random() * ( high - low );\r\n\r\n	},\r\n\r\n	// Random float from <-range/2, range/2> interval\r\n\r\n	randFloatSpread: function ( range ) {\r\n\r\n		return range * ( 0.5 - Math.random() );\r\n\r\n	},\r\n\r\n	degToRad: function () {\r\n\r\n		var degreeToRadiansFactor = Math.PI / 180;\r\n\r\n		return function ( degrees ) {\r\n\r\n			return degrees * degreeToRadiansFactor;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	radToDeg: function () {\r\n\r\n		var radianToDegreesFactor = 180 / Math.PI;\r\n\r\n		return function ( radians ) {\r\n\r\n			return radians * radianToDegreesFactor;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	isPowerOfTwo: function ( value ) {\r\n\r\n		return ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n	},\r\n\r\n	nextPowerOfTwo: function ( value ) {\r\n\r\n		value --;\r\n		value |= value >> 1;\r\n		value |= value >> 2;\r\n		value |= value >> 4;\r\n		value |= value >> 8;\r\n		value |= value >> 16;\r\n		value ++;\r\n\r\n		return value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n	this.points = points;\r\n\r\n	var c = [], v3 = { x: 0, y: 0, z: 0 },\r\n	point, intPoint, weight, w2, w3,\r\n	pa, pb, pc, pd;\r\n\r\n	this.initFromArray = function ( a ) {\r\n\r\n		this.points = [];\r\n\r\n		for ( var i = 0; i < a.length; i ++ ) {\r\n\r\n			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.getPoint = function ( k ) {\r\n\r\n		point = ( this.points.length - 1 ) * k;\r\n		intPoint = Math.floor( point );\r\n		weight = point - intPoint;\r\n\r\n		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n		c[ 1 ] = intPoint;\r\n		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n		pa = this.points[ c[ 0 ] ];\r\n		pb = this.points[ c[ 1 ] ];\r\n		pc = this.points[ c[ 2 ] ];\r\n		pd = this.points[ c[ 3 ] ];\r\n\r\n		w2 = weight * weight;\r\n		w3 = weight * w2;\r\n\r\n		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n		return v3;\r\n\r\n	};\r\n\r\n	this.getControlPointsArray = function () {\r\n\r\n		var i, p, l = this.points.length,\r\n			coords = [];\r\n\r\n		for ( i = 0; i < l; i ++ ) {\r\n\r\n			p = this.points[ i ];\r\n			coords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n		}\r\n\r\n		return coords;\r\n\r\n	};\r\n\r\n	// approximate length by summing linear segments\r\n\r\n	this.getLength = function ( nSubDivisions ) {\r\n\r\n		var i, index, nSamples, position,\r\n			point = 0, intPoint = 0, oldIntPoint = 0,\r\n			oldPosition = new THREE.Vector3(),\r\n			tmpVec = new THREE.Vector3(),\r\n			chunkLengths = [],\r\n			totalLength = 0;\r\n\r\n		// first point has 0 length\r\n\r\n		chunkLengths[ 0 ] = 0;\r\n\r\n		if ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n		nSamples = this.points.length * nSubDivisions;\r\n\r\n		oldPosition.copy( this.points[ 0 ] );\r\n\r\n		for ( i = 1; i < nSamples; i ++ ) {\r\n\r\n			index = i / nSamples;\r\n\r\n			position = this.getPoint( index );\r\n			tmpVec.copy( position );\r\n\r\n			totalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n			oldPosition.copy( position );\r\n\r\n			point = ( this.points.length - 1 ) * index;\r\n			intPoint = Math.floor( point );\r\n\r\n			if ( intPoint !== oldIntPoint ) {\r\n\r\n				chunkLengths[ intPoint ] = totalLength;\r\n				oldIntPoint = intPoint;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// last point ends with total length\r\n\r\n		chunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n		return { chunks: chunkLengths, total: totalLength };\r\n\r\n	};\r\n\r\n	this.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n		var i, j,\r\n			index, indexCurrent, indexNext,\r\n			realDistance,\r\n			sampling, position,\r\n			newpoints = [],\r\n			tmpVec = new THREE.Vector3(),\r\n			sl = this.getLength();\r\n\r\n		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n		for ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n			//tmpVec.copy( this.points[ i - 1 ] );\r\n			//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n			sampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n			indexNext = i / ( this.points.length - 1 );\r\n\r\n			for ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n				position = this.getPoint( index );\r\n				newpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n			}\r\n\r\n			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n		}\r\n\r\n		this.points = newpoints;\r\n\r\n	};\r\n\r\n	// Catmull-Rom\r\n\r\n	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5,\r\n			v1 = ( p3 - p1 ) * 0.5;\r\n\r\n		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n	this.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n	this.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n	this.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n	var v0 = new THREE.Vector3();\r\n\r\n	return function ( a, b, c, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		result.subVectors( c, b );\r\n		v0.subVectors( a, b );\r\n		result.cross( v0 );\r\n\r\n		var resultLengthSq = result.lengthSq();\r\n		if ( resultLengthSq > 0 ) {\r\n\r\n			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n		}\r\n\r\n		return result.set( 0, 0, 0 );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycentric coordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n	var v0 = new THREE.Vector3();\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n\r\n	return function ( point, a, b, c, optionalTarget ) {\r\n\r\n		v0.subVectors( c, a );\r\n		v1.subVectors( b, a );\r\n		v2.subVectors( point, a );\r\n\r\n		var dot00 = v0.dot( v0 );\r\n		var dot01 = v0.dot( v1 );\r\n		var dot02 = v0.dot( v2 );\r\n		var dot11 = v1.dot( v1 );\r\n		var dot12 = v1.dot( v2 );\r\n\r\n		var denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		// collinear or singular triangle\r\n		if ( denom === 0 ) {\r\n\r\n			// arbitrary location outside of triangle?\r\n			// not sure if this is the best idea, maybe should be returning undefined\r\n			return result.set( - 2, - 1, - 1 );\r\n\r\n		}\r\n\r\n		var invDenom = 1 / denom;\r\n		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n		// barycentric coordinates must always sum to 1\r\n		return result.set( 1 - u - v, v, u );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n\r\n	return function ( point, a, b, c ) {\r\n\r\n		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n	constructor: THREE.Triangle,\r\n\r\n	set: function ( a, b, c ) {\r\n\r\n		this.a.copy( a );\r\n		this.b.copy( b );\r\n		this.c.copy( c );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n		this.a.copy( points[ i0 ] );\r\n		this.b.copy( points[ i1 ] );\r\n		this.c.copy( points[ i2 ] );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( triangle ) {\r\n\r\n		this.a.copy( triangle.a );\r\n		this.b.copy( triangle.b );\r\n		this.c.copy( triangle.c );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	area: function () {\r\n\r\n		var v0 = new THREE.Vector3();\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			v0.subVectors( this.c, this.b );\r\n			v1.subVectors( this.a, this.b );\r\n\r\n			return v0.cross( v1 ).length() * 0.5;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	midpoint: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n	},\r\n\r\n	normal: function ( optionalTarget ) {\r\n\r\n		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n	},\r\n\r\n	plane: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Plane();\r\n\r\n		return result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n	},\r\n\r\n	barycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n	},\r\n\r\n	equals: function ( triangle ) {\r\n\r\n		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n	this.startTime = 0;\r\n	this.oldTime = 0;\r\n	this.elapsedTime = 0;\r\n\r\n	this.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n	constructor: THREE.Clock,\r\n\r\n	start: function () {\r\n\r\n		this.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n					 ? self.performance.now()\r\n					 : Date.now();\r\n\r\n		this.oldTime = this.startTime;\r\n		this.running = true;\r\n\r\n	},\r\n\r\n	stop: function () {\r\n\r\n		this.getElapsedTime();\r\n		this.running = false;\r\n\r\n	},\r\n\r\n	getElapsedTime: function () {\r\n\r\n		this.getDelta();\r\n		return this.elapsedTime;\r\n\r\n	},\r\n\r\n	getDelta: function () {\r\n\r\n		var diff = 0;\r\n\r\n		if ( this.autoStart && ! this.running ) {\r\n\r\n			this.start();\r\n\r\n		}\r\n\r\n		if ( this.running ) {\r\n\r\n			var newTime = self.performance !== undefined && self.performance.now !== undefined\r\n					 ? self.performance.now()\r\n					 : Date.now();\r\n\r\n			diff = 0.001 * ( newTime - this.oldTime );\r\n			this.oldTime = newTime;\r\n\r\n			this.elapsedTime += diff;\r\n\r\n		}\r\n\r\n		return diff;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {};\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n	constructor: THREE.EventDispatcher,\r\n\r\n	apply: function ( object ) {\r\n\r\n		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n	},\r\n\r\n	addEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) this._listeners = {};\r\n\r\n		var listeners = this._listeners;\r\n\r\n		if ( listeners[ type ] === undefined ) {\r\n\r\n			listeners[ type ] = [];\r\n\r\n		}\r\n\r\n		if ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n			listeners[ type ].push( listener );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	hasEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) return false;\r\n\r\n		var listeners = this._listeners;\r\n\r\n		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	removeEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) return;\r\n\r\n		var listeners = this._listeners;\r\n		var listenerArray = listeners[ type ];\r\n\r\n		if ( listenerArray !== undefined ) {\r\n\r\n			var index = listenerArray.indexOf( listener );\r\n\r\n			if ( index !== - 1 ) {\r\n\r\n				listenerArray.splice( index, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	dispatchEvent: function ( event ) {\r\n\r\n		if ( this._listeners === undefined ) return;\r\n\r\n		var listeners = this._listeners;\r\n		var listenerArray = listeners[ event.type ];\r\n\r\n		if ( listenerArray !== undefined ) {\r\n\r\n			event.target = this;\r\n\r\n			var array = [];\r\n			var length = listenerArray.length;\r\n\r\n			for ( var i = 0; i < length; i ++ ) {\r\n\r\n				array[ i ] = listenerArray[ i ];\r\n\r\n			}\r\n\r\n			for ( var i = 0; i < length; i ++ ) {\r\n\r\n				array[ i ].call( this, event );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n	THREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n		this.ray = new THREE.Ray( origin, direction );\r\n		// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n		this.near = near || 0;\r\n		this.far = far || Infinity;\r\n\r\n		this.params = {\r\n			Mesh: {},\r\n			Line: {},\r\n			LOD: {},\r\n			Points: { threshold: 1 },\r\n			Sprite: {}\r\n		};\r\n\r\n		Object.defineProperties( this.params, {\r\n			PointCloud: {\r\n				get: function () {\r\n					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n					return this.Points;\r\n				}\r\n			}\r\n		} );\r\n\r\n	};\r\n\r\n	function descSort( a, b ) {\r\n\r\n		return a.distance - b.distance;\r\n\r\n	}\r\n\r\n	var intersectObject = function ( object, raycaster, intersects, recursive ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		object.raycast( raycaster, intersects );\r\n\r\n		if ( recursive === true ) {\r\n\r\n			var children = object.children;\r\n\r\n			for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n				intersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	//\r\n\r\n	THREE.Raycaster.prototype = {\r\n\r\n		constructor: THREE.Raycaster,\r\n\r\n		linePrecision: 1,\r\n\r\n		set: function ( origin, direction ) {\r\n\r\n			// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n			this.ray.set( origin, direction );\r\n\r\n		},\r\n\r\n		setFromCamera: function ( coords, camera ) {\r\n\r\n			if ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n			} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n			} else {\r\n\r\n				console.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n			}\r\n\r\n		},\r\n\r\n		intersectObject: function ( object, recursive ) {\r\n\r\n			var intersects = [];\r\n\r\n			intersectObject( object, this, intersects, recursive );\r\n\r\n			intersects.sort( descSort );\r\n\r\n			return intersects;\r\n\r\n		},\r\n\r\n		intersectObjects: function ( objects, recursive ) {\r\n\r\n			var intersects = [];\r\n\r\n			if ( Array.isArray( objects ) === false ) {\r\n\r\n				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n				return intersects;\r\n\r\n			}\r\n\r\n			for ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n				intersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n			}\r\n\r\n			intersects.sort( descSort );\r\n\r\n			return intersects;\r\n\r\n		}\r\n\r\n	};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Object3D';\r\n\r\n	this.parent = null;\r\n	this.children = [];\r\n\r\n	this.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n	var position = new THREE.Vector3();\r\n	var rotation = new THREE.Euler();\r\n	var quaternion = new THREE.Quaternion();\r\n	var scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n	var onRotationChange = function () {\r\n\r\n		quaternion.setFromEuler( rotation, false );\r\n\r\n	};\r\n\r\n	var onQuaternionChange = function () {\r\n\r\n		rotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n	};\r\n\r\n	rotation.onChange( onRotationChange );\r\n	quaternion.onChange( onQuaternionChange );\r\n\r\n	Object.defineProperties( this, {\r\n		position: {\r\n			enumerable: true,\r\n			value: position\r\n		},\r\n		rotation: {\r\n			enumerable: true,\r\n			value: rotation\r\n		},\r\n		quaternion: {\r\n			enumerable: true,\r\n			value: quaternion\r\n		},\r\n		scale: {\r\n			enumerable: true,\r\n			value: scale\r\n		},\r\n		modelViewMatrix: {\r\n			value: new THREE.Matrix4()\r\n		},\r\n		normalMatrix: {\r\n			value: new THREE.Matrix3()\r\n		}\r\n	} );\r\n\r\n	this.rotationAutoUpdate = true;\r\n\r\n	this.matrix = new THREE.Matrix4();\r\n	this.matrixWorld = new THREE.Matrix4();\r\n\r\n	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n	this.matrixWorldNeedsUpdate = false;\r\n\r\n	this.visible = true;\r\n\r\n	this.castShadow = false;\r\n	this.receiveShadow = false;\r\n\r\n	this.frustumCulled = true;\r\n	this.renderOrder = 0;\r\n\r\n	this.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n	constructor: THREE.Object3D,\r\n\r\n	get eulerOrder () {\r\n\r\n		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n		return this.rotation.order;\r\n\r\n	},\r\n\r\n	set eulerOrder ( value ) {\r\n\r\n		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n		this.rotation.order = value;\r\n\r\n	},\r\n\r\n	get useQuaternion () {\r\n\r\n		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n	},\r\n\r\n	set useQuaternion ( value ) {\r\n\r\n		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n	},\r\n\r\n	set renderDepth ( value ) {\r\n\r\n		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\r\n	},\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		this.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n		this.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n	},\r\n\r\n	setRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n		// assumes axis is normalized\r\n\r\n		this.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n	},\r\n\r\n	setRotationFromEuler: function ( euler ) {\r\n\r\n		this.quaternion.setFromEuler( euler, true );\r\n\r\n	},\r\n\r\n	setRotationFromMatrix: function ( m ) {\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		this.quaternion.setFromRotationMatrix( m );\r\n\r\n	},\r\n\r\n	setRotationFromQuaternion: function ( q ) {\r\n\r\n		// assumes q is normalized\r\n\r\n		this.quaternion.copy( q );\r\n\r\n	},\r\n\r\n	rotateOnAxis: function () {\r\n\r\n		// rotate object on axis in object space\r\n		// axis is assumed to be normalized\r\n\r\n		var q1 = new THREE.Quaternion();\r\n\r\n		return function ( axis, angle ) {\r\n\r\n			q1.setFromAxisAngle( axis, angle );\r\n\r\n			this.quaternion.multiply( q1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateX: function () {\r\n\r\n		var v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateOnAxis: function () {\r\n\r\n		// translate object by distance along axis in object space\r\n		// axis is assumed to be normalized\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( axis, distance ) {\r\n\r\n			v1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n			this.position.add( v1.multiplyScalar( distance ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( distance, axis ) {\r\n\r\n		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n		return this.translateOnAxis( axis, distance );\r\n\r\n	},\r\n\r\n	translateX: function () {\r\n\r\n		var v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateY: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateZ: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	localToWorld: function ( vector ) {\r\n\r\n		return vector.applyMatrix4( this.matrixWorld );\r\n\r\n	},\r\n\r\n	worldToLocal: function () {\r\n\r\n		var m1 = new THREE.Matrix4();\r\n\r\n		return function ( vector ) {\r\n\r\n			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n		var m1 = new THREE.Matrix4();\r\n\r\n		return function ( vector ) {\r\n\r\n			m1.lookAt( vector, this.position, this.up );\r\n\r\n			this.quaternion.setFromRotationMatrix( m1 );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	add: function ( object ) {\r\n\r\n		if ( arguments.length > 1 ) {\r\n\r\n			for ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n				this.add( arguments[ i ] );\r\n\r\n			}\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		if ( object === this ) {\r\n\r\n			console.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n			return this;\r\n\r\n		}\r\n\r\n		if ( object instanceof THREE.Object3D ) {\r\n\r\n			if ( object.parent !== null ) {\r\n\r\n				object.parent.remove( object );\r\n\r\n			}\r\n\r\n			object.parent = this;\r\n			object.dispatchEvent( { type: 'added' } );\r\n\r\n			this.children.push( object );\r\n\r\n		} else {\r\n\r\n			console.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	remove: function ( object ) {\r\n\r\n		if ( arguments.length > 1 ) {\r\n\r\n			for ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n				this.remove( arguments[ i ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var index = this.children.indexOf( object );\r\n\r\n		if ( index !== - 1 ) {\r\n\r\n			object.parent = null;\r\n\r\n			object.dispatchEvent( { type: 'removed' } );\r\n\r\n			this.children.splice( index, 1 );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getChildByName: function ( name ) {\r\n\r\n		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n		return this.getObjectByName( name );\r\n\r\n	},\r\n\r\n	getObjectById: function ( id ) {\r\n\r\n		return this.getObjectByProperty( 'id', id );\r\n\r\n	},\r\n\r\n	getObjectByName: function ( name ) {\r\n\r\n		return this.getObjectByProperty( 'name', name );\r\n\r\n	},\r\n\r\n	getObjectByProperty: function ( name, value ) {\r\n\r\n		if ( this[ name ] === value ) return this;\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			var child = this.children[ i ];\r\n			var object = child.getObjectByProperty( name, value );\r\n\r\n			if ( object !== undefined ) {\r\n\r\n				return object;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return undefined;\r\n\r\n	},\r\n\r\n	getWorldPosition: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		this.updateMatrixWorld( true );\r\n\r\n		return result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n	},\r\n\r\n	getWorldQuaternion: function () {\r\n\r\n		var position = new THREE.Vector3();\r\n		var scale = new THREE.Vector3();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Quaternion();\r\n\r\n			this.updateMatrixWorld( true );\r\n\r\n			this.matrixWorld.decompose( position, result, scale );\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getWorldRotation: function () {\r\n\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Euler();\r\n\r\n			this.getWorldQuaternion( quaternion );\r\n\r\n			return result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getWorldScale: function () {\r\n\r\n		var position = new THREE.Vector3();\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			this.updateMatrixWorld( true );\r\n\r\n			this.matrixWorld.decompose( position, quaternion, result );\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getWorldDirection: function () {\r\n\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			this.getWorldQuaternion( quaternion );\r\n\r\n			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	raycast: function () {},\r\n\r\n	traverse: function ( callback ) {\r\n\r\n		callback( this );\r\n\r\n		var children = this.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			children[ i ].traverse( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	traverseVisible: function ( callback ) {\r\n\r\n		if ( this.visible === false ) return;\r\n\r\n		callback( this );\r\n\r\n		var children = this.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			children[ i ].traverseVisible( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	traverseAncestors: function ( callback ) {\r\n\r\n		var parent = this.parent;\r\n\r\n		if ( parent !== null ) {\r\n\r\n			callback( parent );\r\n\r\n			parent.traverseAncestors( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	updateMatrix: function () {\r\n\r\n		this.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n		this.matrixWorldNeedsUpdate = true;\r\n\r\n	},\r\n\r\n	updateMatrixWorld: function ( force ) {\r\n\r\n		if ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n		if ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n			if ( this.parent === null ) {\r\n\r\n				this.matrixWorld.copy( this.matrix );\r\n\r\n			} else {\r\n\r\n				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n			}\r\n\r\n			this.matrixWorldNeedsUpdate = false;\r\n\r\n			force = true;\r\n\r\n		}\r\n\r\n		// update children\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			this.children[ i ].updateMatrixWorld( force );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		var isRootObject = ( meta === undefined );\r\n\r\n		var data = {};\r\n\r\n		// meta is a hash used to collect geometries, materials.\r\n		// not providing it implies that this is the root object\r\n		// being serialized.\r\n		if ( isRootObject ) {\r\n\r\n			// initialize meta obj\r\n			meta = {\r\n				geometries: {},\r\n				materials: {},\r\n				textures: {},\r\n				images: {}\r\n			};\r\n\r\n			data.metadata = {\r\n				version: 4.4,\r\n				type: 'Object',\r\n				generator: 'Object3D.toJSON'\r\n			};\r\n\r\n		}\r\n\r\n		// standard Object3D serialization\r\n\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n\r\n		if ( this.name !== '' ) data.name = this.name;\r\n		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\r\n		if ( this.visible !== true ) data.visible = this.visible;\r\n\r\n		data.matrix = this.matrix.toArray();\r\n\r\n		if ( this.children.length > 0 ) {\r\n\r\n			data.children = [];\r\n\r\n			for ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n				data.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var output = {};\r\n\r\n		if ( isRootObject ) {\r\n\r\n			var geometries = extractFromCache( meta.geometries );\r\n			var materials = extractFromCache( meta.materials );\r\n			var textures = extractFromCache( meta.textures );\r\n			var images = extractFromCache( meta.images );\r\n\r\n			if ( geometries.length > 0 ) output.geometries = geometries;\r\n			if ( materials.length > 0 ) output.materials = materials;\r\n			if ( textures.length > 0 ) output.textures = textures;\r\n			if ( images.length > 0 ) output.images = images;\r\n\r\n		}\r\n\r\n		output.object = data;\r\n\r\n		return output;\r\n\r\n		// extract data from the cache hash\r\n		// remove metadata on each item\r\n		// and return as array\r\n		function extractFromCache ( cache ) {\r\n\r\n			var values = [];\r\n			for ( var key in cache ) {\r\n\r\n				var data = cache[ key ];\r\n				delete data.metadata;\r\n				values.push( data );\r\n\r\n			}\r\n			return values;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function ( recursive ) {\r\n\r\n		return new this.constructor().copy( this, recursive );\r\n\r\n	},\r\n\r\n	copy: function ( source, recursive ) {\r\n\r\n		if ( recursive === undefined ) recursive = true;\r\n\r\n		this.name = source.name;\r\n\r\n		this.up.copy( source.up );\r\n\r\n		this.position.copy( source.position );\r\n		this.quaternion.copy( source.quaternion );\r\n		this.scale.copy( source.scale );\r\n\r\n		this.rotationAutoUpdate = source.rotationAutoUpdate;\r\n\r\n		this.matrix.copy( source.matrix );\r\n		this.matrixWorld.copy( source.matrixWorld );\r\n\r\n		this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n		this.visible = source.visible;\r\n\r\n		this.castShadow = source.castShadow;\r\n		this.receiveShadow = source.receiveShadow;\r\n\r\n		this.frustumCulled = source.frustumCulled;\r\n		this.renderOrder = source.renderOrder;\r\n\r\n		this.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n		if ( recursive === true ) {\r\n\r\n			for ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n				var child = source.children[ i ];\r\n				this.add( child.clone() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n	this.a = a;\r\n	this.b = b;\r\n	this.c = c;\r\n\r\n	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n	this.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n	this.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n	this.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n	constructor: THREE.Face3,\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.a = source.a;\r\n		this.b = source.b;\r\n		this.c = source.c;\r\n\r\n		this.normal.copy( source.normal );\r\n		this.color.copy( source.color );\r\n\r\n		this.materialIndex = source.materialIndex;\r\n\r\n		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n			this.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Face4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n	return new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.array = array;\r\n	this.itemSize = itemSize;\r\n\r\n	this.dynamic = false;\r\n	this.updateRange = { offset: 0, count: - 1 };\r\n\r\n	this.version = 0;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n	constructor: THREE.BufferAttribute,\r\n\r\n	get length() {\r\n\r\n		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n		return this.array.length;\r\n\r\n	},\r\n\r\n	get count() {\r\n\r\n		return this.array.length / this.itemSize;\r\n\r\n	},\r\n\r\n	set needsUpdate( value ) {\r\n\r\n		if ( value === true ) this.version ++;\r\n\r\n	},\r\n\r\n	setDynamic: function ( value ) {\r\n\r\n		this.dynamic = value;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.array = new source.array.constructor( source.array );\r\n		this.itemSize = source.itemSize;\r\n\r\n		this.dynamic = source.dynamic;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyAt: function ( index1, attribute, index2 ) {\r\n\r\n		index1 *= this.itemSize;\r\n		index2 *= attribute.itemSize;\r\n\r\n		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n			this.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyArray: function ( array ) {\r\n\r\n		this.array.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyColorsArray: function ( colors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n			var color = colors[ i ];\r\n\r\n			if ( color === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n				color = new THREE.Color();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = color.r;\r\n			array[ offset ++ ] = color.g;\r\n			array[ offset ++ ] = color.b;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyIndicesArray: function ( indices ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n			var index = indices[ i ];\r\n\r\n			array[ offset ++ ] = index.a;\r\n			array[ offset ++ ] = index.b;\r\n			array[ offset ++ ] = index.c;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyVector2sArray: function ( vectors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n			var vector = vectors[ i ];\r\n\r\n			if ( vector === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n				vector = new THREE.Vector2();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = vector.x;\r\n			array[ offset ++ ] = vector.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyVector3sArray: function ( vectors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n			var vector = vectors[ i ];\r\n\r\n			if ( vector === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n				vector = new THREE.Vector3();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = vector.x;\r\n			array[ offset ++ ] = vector.y;\r\n			array[ offset ++ ] = vector.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyVector4sArray: function ( vectors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n			var vector = vectors[ i ];\r\n\r\n			if ( vector === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n				vector = new THREE.Vector4();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = vector.x;\r\n			array[ offset ++ ] = vector.y;\r\n			array[ offset ++ ] = vector.z;\r\n			array[ offset ++ ] = vector.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	set: function ( value, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.array.set( value, offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getX: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize ];\r\n\r\n	},\r\n\r\n	setX: function ( index, x ) {\r\n\r\n		this.array[ index * this.itemSize ] = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getY: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize + 1 ];\r\n\r\n	},\r\n\r\n	setY: function ( index, y ) {\r\n\r\n		this.array[ index * this.itemSize + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getZ: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize + 2 ];\r\n\r\n	},\r\n\r\n	setZ: function ( index, z ) {\r\n\r\n		this.array[ index * this.itemSize + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getW: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize + 3 ];\r\n\r\n	},\r\n\r\n	setW: function ( index, w ) {\r\n\r\n		this.array[ index * this.itemSize + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXY: function ( index, x, y ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index + 0 ] = x;\r\n		this.array[ index + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZ: function ( index, x, y, z ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index + 0 ] = x;\r\n		this.array[ index + 1 ] = y;\r\n		this.array[ index + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZW: function ( index, x, y, z, w ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index + 0 ] = x;\r\n		this.array[ index + 1 ] = y;\r\n		this.array[ index + 2 ] = z;\r\n		this.array[ index + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\r\n};\r\n\r\n\r\n// Deprecated\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n	return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\r\n};\r\n\r\n// File:src/core/InstancedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\r\n	THREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n	this.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\r\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\r\n	THREE.BufferAttribute.prototype.copy.call( this, source );\r\n\r\n	this.meshPerAttribute = source.meshPerAttribute;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.array = array;\r\n	this.stride = stride;\r\n\r\n	this.dynamic = false;\r\n	this.updateRange = { offset: 0, count: - 1 };\r\n\r\n	this.version = 0;\r\n\r\n};\r\n\r\nTHREE.InterleavedBuffer.prototype = {\r\n\r\n	constructor: THREE.InterleavedBuffer,\r\n\r\n	get length () {\r\n\r\n		return this.array.length;\r\n\r\n	},\r\n\r\n	get count () {\r\n\r\n		return this.array.length / this.stride;\r\n\r\n	},\r\n\r\n	set needsUpdate( value ) {\r\n\r\n		if ( value === true ) this.version ++;\r\n\r\n	},\r\n\r\n	setDynamic: function ( value ) {\r\n\r\n		this.dynamic = value;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.array = new source.array.constructor( source.array );\r\n		this.stride = source.stride;\r\n		this.dynamic = source.dynamic;\r\n\r\n	},\r\n\r\n	copyAt: function ( index1, attribute, index2 ) {\r\n\r\n		index1 *= this.stride;\r\n		index2 *= attribute.stride;\r\n\r\n		for ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\r\n			this.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	set: function ( value, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.array.set( value, offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/InstancedInterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\r\n	THREE.InterleavedBuffer.call( this, array, stride );\r\n\r\n	this.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\r\n	THREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\r\n	this.meshPerAttribute = source.meshPerAttribute;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.data = interleavedBuffer;\r\n	this.itemSize = itemSize;\r\n	this.offset = offset;\r\n\r\n};\r\n\r\n\r\nTHREE.InterleavedBufferAttribute.prototype = {\r\n\r\n	constructor: THREE.InterleavedBufferAttribute,\r\n\r\n	get length() {\r\n\r\n		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n		return this.array.length;\r\n\r\n	},\r\n\r\n	get count() {\r\n\r\n		return this.data.array.length / this.data.stride;\r\n\r\n	},\r\n\r\n	setX: function ( index, x ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset ] = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( index, y ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( index, z ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setW: function ( index, w ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getX: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset ];\r\n\r\n	},\r\n\r\n	getY: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\r\n	},\r\n\r\n	getZ: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\r\n	},\r\n\r\n	getW: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\r\n	},\r\n\r\n	setXY: function ( index, x, y ) {\r\n\r\n		index = index * this.data.stride + this.offset;\r\n\r\n		this.data.array[ index + 0 ] = x;\r\n		this.data.array[ index + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZ: function ( index, x, y, z ) {\r\n\r\n		index = index * this.data.stride + this.offset;\r\n\r\n		this.data.array[ index + 0 ] = x;\r\n		this.data.array[ index + 1 ] = y;\r\n		this.data.array[ index + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZW: function ( index, x, y, z, w ) {\r\n\r\n		index = index * this.data.stride + this.offset;\r\n\r\n		this.data.array[ index + 0 ] = x;\r\n		this.data.array[ index + 1 ] = y;\r\n		this.data.array[ index + 2 ] = z;\r\n		this.data.array[ index + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Geometry';\r\n\r\n	this.vertices = [];\r\n	this.colors = [];\r\n	this.faces = [];\r\n	this.faceVertexUvs = [ [] ];\r\n\r\n	this.morphTargets = [];\r\n	this.morphColors = [];\r\n	this.morphNormals = [];\r\n\r\n	this.skinWeights = [];\r\n	this.skinIndices = [];\r\n\r\n	this.lineDistances = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	// update flags\r\n\r\n	this.verticesNeedUpdate = false;\r\n	this.elementsNeedUpdate = false;\r\n	this.uvsNeedUpdate = false;\r\n	this.normalsNeedUpdate = false;\r\n	this.colorsNeedUpdate = false;\r\n	this.lineDistancesNeedUpdate = false;\r\n	this.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n	constructor: THREE.Geometry,\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n			var vertex = this.vertices[ i ];\r\n			vertex.applyMatrix4( matrix );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n			var face = this.faces[ i ];\r\n			face.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( this.boundingBox !== null ) {\r\n\r\n			this.computeBoundingBox();\r\n\r\n		}\r\n\r\n		if ( this.boundingSphere !== null ) {\r\n\r\n			this.computeBoundingSphere();\r\n\r\n		}\r\n\r\n		this.verticesNeedUpdate = true;\r\n		this.normalsNeedUpdate = true;\r\n\r\n	},\r\n\r\n	rotateX: function () {\r\n\r\n		// rotate geometry around world x-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateX( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationX( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		// rotate geometry around world y-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateY( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationY( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		// rotate geometry around world z-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateZ( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationZ( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function () {\r\n\r\n		// translate geometry\r\n\r\n		var m1;\r\n\r\n		return function translate( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeTranslation( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	scale: function () {\r\n\r\n		// scale geometry\r\n\r\n		var m1;\r\n\r\n		return function scale( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeScale( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		var obj;\r\n\r\n		return function lookAt( vector ) {\r\n\r\n			if ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n			obj.lookAt( vector );\r\n\r\n			obj.updateMatrix();\r\n\r\n			this.applyMatrix( obj.matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	fromBufferGeometry: function ( geometry ) {\r\n\r\n		var scope = this;\r\n\r\n		var indices = geometry.index !== null ? geometry.index.array : undefined;\r\n		var attributes = geometry.attributes;\r\n\r\n		var vertices = attributes.position.array;\r\n		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n		var colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n		var tempNormals = [];\r\n		var tempUVs = [];\r\n		var tempUVs2 = [];\r\n\r\n		for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {\r\n\r\n			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n			if ( normals !== undefined ) {\r\n\r\n				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n			}\r\n\r\n			if ( colors !== undefined ) {\r\n\r\n				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n			}\r\n\r\n			if ( uvs !== undefined ) {\r\n\r\n				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n			}\r\n\r\n			if ( uvs2 !== undefined ) {\r\n\r\n				tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var addFace = function ( a, b, c ) {\r\n\r\n			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n			var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );\r\n\r\n			scope.faces.push( face );\r\n\r\n			if ( uvs !== undefined ) {\r\n\r\n				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n			}\r\n\r\n			if ( uvs2 !== undefined ) {\r\n\r\n				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\r\n			}\r\n\r\n		};\r\n\r\n		if ( indices !== undefined ) {\r\n\r\n			var groups = geometry.groups;\r\n\r\n			if ( groups.length > 0 ) {\r\n\r\n				for ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n					var group = groups[ i ];\r\n\r\n					var start = group.start;\r\n					var count = group.count;\r\n\r\n					for ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				for ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			for ( var i = 0; i < vertices.length / 3; i += 3 ) {\r\n\r\n				addFace( i, i + 1, i + 2 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.computeFaceNormals();\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			this.boundingBox = geometry.boundingBox.clone();\r\n\r\n		}\r\n\r\n		if ( geometry.boundingSphere !== null ) {\r\n\r\n			this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	center: function () {\r\n\r\n		this.computeBoundingBox();\r\n\r\n		var offset = this.boundingBox.center().negate();\r\n\r\n		this.translate( offset.x, offset.y, offset.z );\r\n\r\n		return offset;\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		this.computeBoundingSphere();\r\n\r\n		var center = this.boundingSphere.center;\r\n		var radius = this.boundingSphere.radius;\r\n\r\n		var s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n		var matrix = new THREE.Matrix4();\r\n		matrix.set(\r\n			s, 0, 0, - s * center.x,\r\n			0, s, 0, - s * center.y,\r\n			0, 0, s, - s * center.z,\r\n			0, 0, 0, 1\r\n		);\r\n\r\n		this.applyMatrix( matrix );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		var cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			var face = this.faces[ f ];\r\n\r\n			var vA = this.vertices[ face.a ];\r\n			var vB = this.vertices[ face.b ];\r\n			var vC = this.vertices[ face.c ];\r\n\r\n			cb.subVectors( vC, vB );\r\n			ab.subVectors( vA, vB );\r\n			cb.cross( ab );\r\n\r\n			cb.normalize();\r\n\r\n			face.normal.copy( cb );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeVertexNormals: function ( areaWeighted ) {\r\n\r\n		var v, vl, f, fl, face, vertices;\r\n\r\n		vertices = new Array( this.vertices.length );\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			vertices[ v ] = new THREE.Vector3();\r\n\r\n		}\r\n\r\n		if ( areaWeighted ) {\r\n\r\n			// vertex normals weighted by triangle areas\r\n			// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n			var vA, vB, vC;\r\n			var cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				vA = this.vertices[ face.a ];\r\n				vB = this.vertices[ face.b ];\r\n				vC = this.vertices[ face.c ];\r\n\r\n				cb.subVectors( vC, vB );\r\n				ab.subVectors( vA, vB );\r\n				cb.cross( ab );\r\n\r\n				vertices[ face.a ].add( cb );\r\n				vertices[ face.b ].add( cb );\r\n				vertices[ face.c ].add( cb );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				vertices[ face.a ].add( face.normal );\r\n				vertices[ face.b ].add( face.normal );\r\n				vertices[ face.c ].add( face.normal );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			vertices[ v ].normalize();\r\n\r\n		}\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			var vertexNormals = face.vertexNormals;\r\n\r\n			if ( vertexNormals.length === 3 ) {\r\n\r\n				vertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n				vertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n				vertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n			} else {\r\n\r\n				vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n				vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n				vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeMorphNormals: function () {\r\n\r\n		var i, il, f, fl, face;\r\n\r\n		// save original normals\r\n		// - create temp variables on first access\r\n		//   otherwise just copy (for faster repeated calls)\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			if ( ! face.__originalFaceNormal ) {\r\n\r\n				face.__originalFaceNormal = face.normal.clone();\r\n\r\n			} else {\r\n\r\n				face.__originalFaceNormal.copy( face.normal );\r\n\r\n			}\r\n\r\n			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n				if ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n				} else {\r\n\r\n					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// use temp geometry to compute face and vertex normals for each morph\r\n\r\n		var tmpGeo = new THREE.Geometry();\r\n		tmpGeo.faces = this.faces;\r\n\r\n		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n			// create on first access\r\n\r\n			if ( ! this.morphNormals[ i ] ) {\r\n\r\n				this.morphNormals[ i ] = {};\r\n				this.morphNormals[ i ].faceNormals = [];\r\n				this.morphNormals[ i ].vertexNormals = [];\r\n\r\n				var dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n				var faceNormal, vertexNormals;\r\n\r\n				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n					faceNormal = new THREE.Vector3();\r\n					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n					dstNormalsFace.push( faceNormal );\r\n					dstNormalsVertex.push( vertexNormals );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var morphNormals = this.morphNormals[ i ];\r\n\r\n			// set vertices to morph target\r\n\r\n			tmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n			// compute morph normals\r\n\r\n			tmpGeo.computeFaceNormals();\r\n			tmpGeo.computeVertexNormals();\r\n\r\n			// store morph normals\r\n\r\n			var faceNormal, vertexNormals;\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				faceNormal = morphNormals.faceNormals[ f ];\r\n				vertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n				faceNormal.copy( face.normal );\r\n\r\n				vertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n				vertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n				vertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore original normals\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			face.normal = face.__originalFaceNormal;\r\n			face.vertexNormals = face.__originalVertexNormals;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeTangents: function () {\r\n\r\n		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\r\n	},\r\n\r\n	computeLineDistances: function () {\r\n\r\n		var d = 0;\r\n		var vertices = this.vertices;\r\n\r\n		for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n			if ( i > 0 ) {\r\n\r\n				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n			}\r\n\r\n			this.lineDistances[ i ] = d;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeBoundingBox: function () {\r\n\r\n		if ( this.boundingBox === null ) {\r\n\r\n			this.boundingBox = new THREE.Box3();\r\n\r\n		}\r\n\r\n		this.boundingBox.setFromPoints( this.vertices );\r\n\r\n	},\r\n\r\n	computeBoundingSphere: function () {\r\n\r\n		if ( this.boundingSphere === null ) {\r\n\r\n			this.boundingSphere = new THREE.Sphere();\r\n\r\n		}\r\n\r\n		this.boundingSphere.setFromPoints( this.vertices );\r\n\r\n	},\r\n\r\n	merge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n		if ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n			return;\r\n\r\n		}\r\n\r\n		var normalMatrix,\r\n		vertexOffset = this.vertices.length,\r\n		vertices1 = this.vertices,\r\n		vertices2 = geometry.vertices,\r\n		faces1 = this.faces,\r\n		faces2 = geometry.faces,\r\n		uvs1 = this.faceVertexUvs[ 0 ],\r\n		uvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n		if ( matrix !== undefined ) {\r\n\r\n			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n		}\r\n\r\n		// vertices\r\n\r\n		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n			var vertex = vertices2[ i ];\r\n\r\n			var vertexCopy = vertex.clone();\r\n\r\n			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n			vertices1.push( vertexCopy );\r\n\r\n		}\r\n\r\n		// faces\r\n\r\n		for ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n			var face = faces2[ i ], faceCopy, normal, color,\r\n			faceVertexNormals = face.vertexNormals,\r\n			faceVertexColors = face.vertexColors;\r\n\r\n			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n			faceCopy.normal.copy( face.normal );\r\n\r\n			if ( normalMatrix !== undefined ) {\r\n\r\n				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n				normal = faceVertexNormals[ j ].clone();\r\n\r\n				if ( normalMatrix !== undefined ) {\r\n\r\n					normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n				}\r\n\r\n				faceCopy.vertexNormals.push( normal );\r\n\r\n			}\r\n\r\n			faceCopy.color.copy( face.color );\r\n\r\n			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n				color = faceVertexColors[ j ];\r\n				faceCopy.vertexColors.push( color.clone() );\r\n\r\n			}\r\n\r\n			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n			faces1.push( faceCopy );\r\n\r\n		}\r\n\r\n		// uvs\r\n\r\n		for ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n			var uv = uvs2[ i ], uvCopy = [];\r\n\r\n			if ( uv === undefined ) {\r\n\r\n				continue;\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n				uvCopy.push( uv[ j ].clone() );\r\n\r\n			}\r\n\r\n			uvs1.push( uvCopy );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	mergeMesh: function ( mesh ) {\r\n\r\n		if ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n			return;\r\n\r\n		}\r\n\r\n		mesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n		this.merge( mesh.geometry, mesh.matrix );\r\n\r\n	},\r\n\r\n	/*\r\n	 * Checks for duplicate vertices with hashmap.\r\n	 * Duplicated vertices are removed\r\n	 * and faces' vertices are updated.\r\n	 */\r\n\r\n	mergeVertices: function () {\r\n\r\n		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n		var unique = [], changes = [];\r\n\r\n		var v, key;\r\n		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n		var precision = Math.pow( 10, precisionPoints );\r\n		var i, il, face;\r\n		var indices, j, jl;\r\n\r\n		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n			v = this.vertices[ i ];\r\n			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n			if ( verticesMap[ key ] === undefined ) {\r\n\r\n				verticesMap[ key ] = i;\r\n				unique.push( this.vertices[ i ] );\r\n				changes[ i ] = unique.length - 1;\r\n\r\n			} else {\r\n\r\n				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n				changes[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n		// if faces are completely degenerate after merging vertices, we\r\n		// have to remove them from the geometry.\r\n		var faceIndicesToRemove = [];\r\n\r\n		for ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n			face = this.faces[ i ];\r\n\r\n			face.a = changes[ face.a ];\r\n			face.b = changes[ face.b ];\r\n			face.c = changes[ face.c ];\r\n\r\n			indices = [ face.a, face.b, face.c ];\r\n\r\n			var dupIndex = - 1;\r\n\r\n			// if any duplicate vertices are found in a Face3\r\n			// we have to remove the face as nothing can be saved\r\n			for ( var n = 0; n < 3; n ++ ) {\r\n\r\n				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n					dupIndex = n;\r\n					faceIndicesToRemove.push( i );\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n			var idx = faceIndicesToRemove[ i ];\r\n\r\n			this.faces.splice( idx, 1 );\r\n\r\n			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n				this.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Use unique set of vertices\r\n\r\n		var diff = this.vertices.length - unique.length;\r\n		this.vertices = unique;\r\n		return diff;\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var data = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'Geometry',\r\n				generator: 'Geometry.toJSON'\r\n			}\r\n		};\r\n\r\n		// standard Geometry serialization\r\n\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n		if ( this.name !== '' ) data.name = this.name;\r\n\r\n		if ( this.parameters !== undefined ) {\r\n\r\n			var parameters = this.parameters;\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n			}\r\n\r\n			return data;\r\n\r\n		}\r\n\r\n		var vertices = [];\r\n\r\n		for ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n			var vertex = this.vertices[ i ];\r\n			vertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n		}\r\n\r\n		var faces = [];\r\n		var normals = [];\r\n		var normalsHash = {};\r\n		var colors = [];\r\n		var colorsHash = {};\r\n		var uvs = [];\r\n		var uvsHash = {};\r\n\r\n		for ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n			var face = this.faces[ i ];\r\n\r\n			var hasMaterial = false; // face.materialIndex !== undefined;\r\n			var hasFaceUv = false; // deprecated\r\n			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n			var hasFaceNormal = face.normal.length() > 0;\r\n			var hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n			var hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n			var faceType = 0;\r\n\r\n			faceType = setBit( faceType, 0, 0 );\r\n			faceType = setBit( faceType, 1, hasMaterial );\r\n			faceType = setBit( faceType, 2, hasFaceUv );\r\n			faceType = setBit( faceType, 3, hasFaceVertexUv );\r\n			faceType = setBit( faceType, 4, hasFaceNormal );\r\n			faceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n			faceType = setBit( faceType, 6, hasFaceColor );\r\n			faceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n			faces.push( faceType );\r\n			faces.push( face.a, face.b, face.c );\r\n\r\n			if ( hasFaceVertexUv ) {\r\n\r\n				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n				faces.push(\r\n					getUvIndex( faceVertexUvs[ 0 ] ),\r\n					getUvIndex( faceVertexUvs[ 1 ] ),\r\n					getUvIndex( faceVertexUvs[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n			if ( hasFaceNormal ) {\r\n\r\n				faces.push( getNormalIndex( face.normal ) );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexNormal ) {\r\n\r\n				var vertexNormals = face.vertexNormals;\r\n\r\n				faces.push(\r\n					getNormalIndex( vertexNormals[ 0 ] ),\r\n					getNormalIndex( vertexNormals[ 1 ] ),\r\n					getNormalIndex( vertexNormals[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n			if ( hasFaceColor ) {\r\n\r\n				faces.push( getColorIndex( face.color ) );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexColor ) {\r\n\r\n				var vertexColors = face.vertexColors;\r\n\r\n				faces.push(\r\n					getColorIndex( vertexColors[ 0 ] ),\r\n					getColorIndex( vertexColors[ 1 ] ),\r\n					getColorIndex( vertexColors[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function setBit( value, position, enabled ) {\r\n\r\n			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n		}\r\n\r\n		function getNormalIndex( normal ) {\r\n\r\n			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n			if ( normalsHash[ hash ] !== undefined ) {\r\n\r\n				return normalsHash[ hash ];\r\n\r\n			}\r\n\r\n			normalsHash[ hash ] = normals.length / 3;\r\n			normals.push( normal.x, normal.y, normal.z );\r\n\r\n			return normalsHash[ hash ];\r\n\r\n		}\r\n\r\n		function getColorIndex( color ) {\r\n\r\n			var hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n			if ( colorsHash[ hash ] !== undefined ) {\r\n\r\n				return colorsHash[ hash ];\r\n\r\n			}\r\n\r\n			colorsHash[ hash ] = colors.length;\r\n			colors.push( color.getHex() );\r\n\r\n			return colorsHash[ hash ];\r\n\r\n		}\r\n\r\n		function getUvIndex( uv ) {\r\n\r\n			var hash = uv.x.toString() + uv.y.toString();\r\n\r\n			if ( uvsHash[ hash ] !== undefined ) {\r\n\r\n				return uvsHash[ hash ];\r\n\r\n			}\r\n\r\n			uvsHash[ hash ] = uvs.length / 2;\r\n			uvs.push( uv.x, uv.y );\r\n\r\n			return uvsHash[ hash ];\r\n\r\n		}\r\n\r\n		data.data = {};\r\n\r\n		data.data.vertices = vertices;\r\n		data.data.normals = normals;\r\n		if ( colors.length > 0 ) data.data.colors = colors;\r\n		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n		data.data.faces = faces;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.vertices = [];\r\n		this.faces = [];\r\n		this.faceVertexUvs = [ [] ];\r\n\r\n		var vertices = source.vertices;\r\n\r\n		for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n			this.vertices.push( vertices[ i ].clone() );\r\n\r\n		}\r\n\r\n		var faces = source.faces;\r\n\r\n		for ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n			this.faces.push( faces[ i ].clone() );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n			var faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n			if ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n				this.faceVertexUvs[ i ] = [];\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n				var uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n					var uv = uvs[ k ];\r\n\r\n					uvsCopy.push( uv.clone() );\r\n\r\n				}\r\n\r\n				this.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/core/DirectGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectGeometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'DirectGeometry';\r\n\r\n	this.indices = [];\r\n	this.vertices = [];\r\n	this.normals = [];\r\n	this.colors = [];\r\n	this.uvs = [];\r\n	this.uvs2 = [];\r\n\r\n	this.groups = [];\r\n\r\n	this.morphTargets = {};\r\n\r\n	this.skinWeights = [];\r\n	this.skinIndices = [];\r\n\r\n	// this.lineDistances = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	// update flags\r\n\r\n	this.verticesNeedUpdate = false;\r\n	this.normalsNeedUpdate = false;\r\n	this.colorsNeedUpdate = false;\r\n	this.uvsNeedUpdate = false;\r\n	this.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.DirectGeometry.prototype = {\r\n\r\n	constructor: THREE.DirectGeometry,\r\n\r\n	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\r\n	},\r\n\r\n	computeVertexNormals: function () {\r\n\r\n		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\r\n	},\r\n\r\n	computeGroups: function ( geometry ) {\r\n\r\n		var group;\r\n		var groups = [];\r\n		var materialIndex;\r\n\r\n		var faces = geometry.faces;\r\n\r\n		for ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			// materials\r\n\r\n			if ( face.materialIndex !== materialIndex ) {\r\n\r\n				materialIndex = face.materialIndex;\r\n\r\n				if ( group !== undefined ) {\r\n\r\n					group.count = ( i * 3 ) - group.start;\r\n					groups.push( group );\r\n\r\n				}\r\n\r\n				group = {\r\n					start: i * 3,\r\n					materialIndex: materialIndex\r\n				};\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( group !== undefined ) {\r\n\r\n			group.count = ( i * 3 ) - group.start;\r\n			groups.push( group );\r\n\r\n		}\r\n\r\n		this.groups = groups;\r\n\r\n	},\r\n\r\n	fromGeometry: function ( geometry ) {\r\n\r\n		var faces = geometry.faces;\r\n		var vertices = geometry.vertices;\r\n		var faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n		// morphs\r\n\r\n		var morphTargets = geometry.morphTargets;\r\n		var morphTargetsLength = morphTargets.length;\r\n\r\n		if ( morphTargetsLength > 0 ) {\r\n\r\n			var morphTargetsPosition = [];\r\n\r\n			for ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n				morphTargetsPosition[ i ] = [];\r\n\r\n			}\r\n\r\n			this.morphTargets.position = morphTargetsPosition;\r\n\r\n		}\r\n\r\n		var morphNormals = geometry.morphNormals;\r\n		var morphNormalsLength = morphNormals.length;\r\n\r\n		if ( morphNormalsLength > 0 ) {\r\n\r\n			var morphTargetsNormal = [];\r\n\r\n			for ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n				morphTargetsNormal[ i ] = [];\r\n\r\n			}\r\n\r\n			this.morphTargets.normal = morphTargetsNormal;\r\n\r\n		}\r\n\r\n		// skins\r\n\r\n		var skinIndices = geometry.skinIndices;\r\n		var skinWeights = geometry.skinWeights;\r\n\r\n		var hasSkinIndices = skinIndices.length === vertices.length;\r\n		var hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n		//\r\n\r\n		for ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n			var vertexNormals = face.vertexNormals;\r\n\r\n			if ( vertexNormals.length === 3 ) {\r\n\r\n				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n			} else {\r\n\r\n				var normal = face.normal;\r\n\r\n				this.normals.push( normal, normal, normal );\r\n\r\n			}\r\n\r\n			var vertexColors = face.vertexColors;\r\n\r\n			if ( vertexColors.length === 3 ) {\r\n\r\n				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n			} else {\r\n\r\n				var color = face.color;\r\n\r\n				this.colors.push( color, color, color );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexUv === true ) {\r\n\r\n				var vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n				if ( vertexUvs !== undefined ) {\r\n\r\n					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n				} else {\r\n\r\n					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n					this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexUv2 === true ) {\r\n\r\n				var vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n				if ( vertexUvs !== undefined ) {\r\n\r\n					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n				} else {\r\n\r\n					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n					this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// morphs\r\n\r\n			for ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n				var morphTarget = morphTargets[ j ].vertices;\r\n\r\n				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n			}\r\n\r\n			for ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n				var morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n			}\r\n\r\n			// skins\r\n\r\n			if ( hasSkinIndices ) {\r\n\r\n				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n			}\r\n\r\n			if ( hasSkinWeights ) {\r\n\r\n				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.computeGroups( geometry );\r\n\r\n		this.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n		this.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n		this.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n		this.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n		this.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'BufferGeometry';\r\n\r\n	this.index = null;\r\n	this.attributes = {};\r\n\r\n	this.morphAttributes = {};\r\n\r\n	this.groups = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	this.drawRange = { start: 0, count: Infinity };\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n	constructor: THREE.BufferGeometry,\r\n\r\n	addIndex: function ( index ) {\r\n\r\n		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n		this.setIndex( index );\r\n\r\n	},\r\n\r\n	getIndex: function () {\r\n\r\n		return this.index;\r\n\r\n	},\r\n\r\n	setIndex: function ( index ) {\r\n\r\n		this.index = index;\r\n\r\n	},\r\n\r\n	addAttribute: function ( name, attribute ) {\r\n\r\n		if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n			this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		if ( name === 'index' ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n			this.setIndex( attribute );\r\n\r\n		}\r\n\r\n		this.attributes[ name ] = attribute;\r\n\r\n	},\r\n\r\n	getAttribute: function ( name ) {\r\n\r\n		return this.attributes[ name ];\r\n\r\n	},\r\n\r\n	removeAttribute: function ( name ) {\r\n\r\n		delete this.attributes[ name ];\r\n\r\n	},\r\n\r\n	get drawcalls() {\r\n\r\n		console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n		return this.groups;\r\n\r\n	},\r\n\r\n	get offsets() {\r\n\r\n		console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n		return this.groups;\r\n\r\n	},\r\n\r\n	addDrawCall: function ( start, count, indexOffset ) {\r\n\r\n		if ( indexOffset !== undefined ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\r\n		}\r\n\r\n		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n		this.addGroup( start, count );\r\n\r\n	},\r\n\r\n	clearDrawCalls: function () {\r\n\r\n		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n		this.clearGroups();\r\n\r\n	},\r\n\r\n	addGroup: function ( start, count, materialIndex ) {\r\n\r\n		this.groups.push( {\r\n\r\n			start: start,\r\n			count: count,\r\n			materialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n		} );\r\n\r\n	},\r\n\r\n	clearGroups: function () {\r\n\r\n		this.groups = [];\r\n\r\n	},\r\n\r\n	setDrawRange: function ( start, count ) {\r\n\r\n		this.drawRange.start = start;\r\n		this.drawRange.count = count;\r\n\r\n	},\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		var position = this.attributes.position;\r\n\r\n		if ( position !== undefined ) {\r\n\r\n			matrix.applyToVector3Array( position.array );\r\n			position.needsUpdate = true;\r\n\r\n		}\r\n\r\n		var normal = this.attributes.normal;\r\n\r\n		if ( normal !== undefined ) {\r\n\r\n			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n			normalMatrix.applyToVector3Array( normal.array );\r\n			normal.needsUpdate = true;\r\n\r\n		}\r\n\r\n		if ( this.boundingBox !== null ) {\r\n\r\n			this.computeBoundingBox();\r\n\r\n		}\r\n\r\n		if ( this.boundingSphere !== null ) {\r\n\r\n			this.computeBoundingSphere();\r\n\r\n		}\r\n\r\n	},\r\n\r\n	rotateX: function () {\r\n\r\n		// rotate geometry around world x-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateX( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationX( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		// rotate geometry around world y-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateY( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationY( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		// rotate geometry around world z-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateZ( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationZ( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function () {\r\n\r\n		// translate geometry\r\n\r\n		var m1;\r\n\r\n		return function translate( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeTranslation( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	scale: function () {\r\n\r\n		// scale geometry\r\n\r\n		var m1;\r\n\r\n		return function scale( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeScale( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		var obj;\r\n\r\n		return function lookAt( vector ) {\r\n\r\n			if ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n			obj.lookAt( vector );\r\n\r\n			obj.updateMatrix();\r\n\r\n			this.applyMatrix( obj.matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	center: function () {\r\n\r\n		this.computeBoundingBox();\r\n\r\n		var offset = this.boundingBox.center().negate();\r\n\r\n		this.translate( offset.x, offset.y, offset.z );\r\n\r\n		return offset;\r\n\r\n	},\r\n\r\n	setFromObject: function ( object ) {\r\n\r\n		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\r\n			var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n			var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\r\n			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n				var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\r\n				this.addAttribute( 'lineDistance',  lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n			}\r\n\r\n			if ( geometry.boundingSphere !== null ) {\r\n\r\n				this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n			}\r\n\r\n			if ( geometry.boundingBox !== null ) {\r\n\r\n				this.boundingBox = geometry.boundingBox.clone();\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.Mesh ) {\r\n\r\n			if ( geometry instanceof THREE.Geometry ) {\r\n\r\n				this.fromGeometry( geometry );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	updateFromObject: function ( object ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( object instanceof THREE.Mesh ) {\r\n\r\n			var direct = geometry.__directGeometry;\r\n\r\n			if ( direct === undefined ) {\r\n\r\n				return this.fromGeometry( geometry );\r\n\r\n			}\r\n\r\n			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n			geometry.normalsNeedUpdate = false;\r\n			geometry.colorsNeedUpdate = false;\r\n			geometry.uvsNeedUpdate = false;\r\n			geometry.groupsNeedUpdate = false;\r\n\r\n			geometry = direct;\r\n\r\n		}\r\n\r\n		if ( geometry.verticesNeedUpdate === true ) {\r\n\r\n			var attribute = this.attributes.position;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyVector3sArray( geometry.vertices );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.normalsNeedUpdate === true ) {\r\n\r\n			var attribute = this.attributes.normal;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyVector3sArray( geometry.normals );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.normalsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.colorsNeedUpdate === true ) {\r\n\r\n			var attribute = this.attributes.color;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyColorsArray( geometry.colors );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.colorsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n			var attribute = this.attributes.lineDistance;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyArray( geometry.lineDistances );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.lineDistancesNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.groupsNeedUpdate ) {\r\n\r\n			geometry.computeGroups( object.geometry );\r\n			this.groups = geometry.groups;\r\n\r\n			geometry.groupsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	fromGeometry: function ( geometry ) {\r\n\r\n		geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\r\n		return this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n	},\r\n\r\n	fromDirectGeometry: function ( geometry ) {\r\n\r\n		var positions = new Float32Array( geometry.vertices.length * 3 );\r\n		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n		if ( geometry.normals.length > 0 ) {\r\n\r\n			var normals = new Float32Array( geometry.normals.length * 3 );\r\n			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n		}\r\n\r\n		if ( geometry.colors.length > 0 ) {\r\n\r\n			var colors = new Float32Array( geometry.colors.length * 3 );\r\n			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n		}\r\n\r\n		if ( geometry.uvs.length > 0 ) {\r\n\r\n			var uvs = new Float32Array( geometry.uvs.length * 2 );\r\n			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n		}\r\n\r\n		if ( geometry.uvs2.length > 0 ) {\r\n\r\n			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n			this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n		}\r\n\r\n		if ( geometry.indices.length > 0 ) {\r\n\r\n			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n			var indices = new TypeArray( geometry.indices.length * 3 );\r\n			this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\r\n		}\r\n\r\n		// groups\r\n\r\n		this.groups = geometry.groups;\r\n\r\n		// morphs\r\n\r\n		for ( var name in geometry.morphTargets ) {\r\n\r\n			var array = [];\r\n			var morphTargets = geometry.morphTargets[ name ];\r\n\r\n			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n				var morphTarget = morphTargets[ i ];\r\n\r\n				var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\r\n				array.push( attribute.copyVector3sArray( morphTarget ) );\r\n\r\n			}\r\n\r\n			this.morphAttributes[ name ] = array;\r\n\r\n		}\r\n\r\n		// skinning\r\n\r\n		if ( geometry.skinIndices.length > 0 ) {\r\n\r\n			var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n		}\r\n\r\n		if ( geometry.skinWeights.length > 0 ) {\r\n\r\n			var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( geometry.boundingSphere !== null ) {\r\n\r\n			this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n		}\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			this.boundingBox = geometry.boundingBox.clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	computeBoundingBox: function () {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			if ( this.boundingBox === null ) {\r\n\r\n				this.boundingBox = new THREE.Box3();\r\n\r\n			}\r\n\r\n			var positions = this.attributes.position.array;\r\n\r\n			if ( positions ) {\r\n\r\n				var bb = this.boundingBox;\r\n				bb.makeEmpty();\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.fromArray( positions, i );\r\n					bb.expandByPoint( vector );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( positions === undefined || positions.length === 0 ) {\r\n\r\n				this.boundingBox.min.set( 0, 0, 0 );\r\n				this.boundingBox.max.set( 0, 0, 0 );\r\n\r\n			}\r\n\r\n			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n			}\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	computeBoundingSphere: function () {\r\n\r\n		var box = new THREE.Box3();\r\n		var vector = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			if ( this.boundingSphere === null ) {\r\n\r\n				this.boundingSphere = new THREE.Sphere();\r\n\r\n			}\r\n\r\n			var positions = this.attributes.position.array;\r\n\r\n			if ( positions ) {\r\n\r\n				box.makeEmpty();\r\n\r\n				var center = this.boundingSphere.center;\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.fromArray( positions, i );\r\n					box.expandByPoint( vector );\r\n\r\n				}\r\n\r\n				box.center( center );\r\n\r\n				// hoping to find a boundingSphere with a radius smaller than the\r\n				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n				var maxRadiusSq = 0;\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.fromArray( positions, i );\r\n					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n				}\r\n\r\n				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n				if ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		// backwards compatibility\r\n\r\n	},\r\n\r\n	computeVertexNormals: function () {\r\n\r\n		var index = this.index;\r\n		var attributes = this.attributes;\r\n		var groups = this.groups;\r\n\r\n		if ( attributes.position ) {\r\n\r\n			var positions = attributes.position.array;\r\n\r\n			if ( attributes.normal === undefined ) {\r\n\r\n				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n			} else {\r\n\r\n				// reset existing normals to zero\r\n\r\n				var normals = attributes.normal.array;\r\n\r\n				for ( var i = 0, il = normals.length; i < il; i ++ ) {\r\n\r\n					normals[ i ] = 0;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var normals = attributes.normal.array;\r\n\r\n			var vA, vB, vC,\r\n\r\n			pA = new THREE.Vector3(),\r\n			pB = new THREE.Vector3(),\r\n			pC = new THREE.Vector3(),\r\n\r\n			cb = new THREE.Vector3(),\r\n			ab = new THREE.Vector3();\r\n\r\n			// indexed elements\r\n\r\n			if ( index ) {\r\n\r\n				var indices = index.array;\r\n\r\n				if ( groups.length === 0 ) {\r\n\r\n					this.addGroup( 0, indices.length );\r\n\r\n				}\r\n\r\n				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\r\n					var group = groups[ j ];\r\n\r\n					var start = group.start;\r\n					var count = group.count;\r\n\r\n					for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n						vA = indices[ i + 0 ] * 3;\r\n						vB = indices[ i + 1 ] * 3;\r\n						vC = indices[ i + 2 ] * 3;\r\n\r\n						pA.fromArray( positions, vA );\r\n						pB.fromArray( positions, vB );\r\n						pC.fromArray( positions, vC );\r\n\r\n						cb.subVectors( pC, pB );\r\n						ab.subVectors( pA, pB );\r\n						cb.cross( ab );\r\n\r\n						normals[ vA ] += cb.x;\r\n						normals[ vA + 1 ] += cb.y;\r\n						normals[ vA + 2 ] += cb.z;\r\n\r\n						normals[ vB ] += cb.x;\r\n						normals[ vB + 1 ] += cb.y;\r\n						normals[ vB + 2 ] += cb.z;\r\n\r\n						normals[ vC ] += cb.x;\r\n						normals[ vC + 1 ] += cb.y;\r\n						normals[ vC + 2 ] += cb.z;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// non-indexed elements (unconnected triangle soup)\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n					pA.fromArray( positions, i );\r\n					pB.fromArray( positions, i + 3 );\r\n					pC.fromArray( positions, i + 6 );\r\n\r\n					cb.subVectors( pC, pB );\r\n					ab.subVectors( pA, pB );\r\n					cb.cross( ab );\r\n\r\n					normals[ i ] = cb.x;\r\n					normals[ i + 1 ] = cb.y;\r\n					normals[ i + 2 ] = cb.z;\r\n\r\n					normals[ i + 3 ] = cb.x;\r\n					normals[ i + 4 ] = cb.y;\r\n					normals[ i + 5 ] = cb.z;\r\n\r\n					normals[ i + 6 ] = cb.x;\r\n					normals[ i + 7 ] = cb.y;\r\n					normals[ i + 8 ] = cb.z;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.normalizeNormals();\r\n\r\n			attributes.normal.needsUpdate = true;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeTangents: function () {\r\n\r\n		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\r\n	},\r\n\r\n	computeOffsets: function ( size ) {\r\n\r\n		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')\r\n\r\n	},\r\n\r\n	merge: function ( geometry, offset ) {\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n			return;\r\n\r\n		}\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		var attributes = this.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			if ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n			var attribute1 = attributes[ key ];\r\n			var attributeArray1 = attribute1.array;\r\n\r\n			var attribute2 = geometry.attributes[ key ];\r\n			var attributeArray2 = attribute2.array;\r\n\r\n			var attributeSize = attribute2.itemSize;\r\n\r\n			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n				attributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	normalizeNormals: function () {\r\n\r\n		var normals = this.attributes.normal.array;\r\n\r\n		var x, y, z, n;\r\n\r\n		for ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n			x = normals[ i ];\r\n			y = normals[ i + 1 ];\r\n			z = normals[ i + 2 ];\r\n\r\n			n = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n			normals[ i ] *= n;\r\n			normals[ i + 1 ] *= n;\r\n			normals[ i + 2 ] *= n;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var data = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'BufferGeometry',\r\n				generator: 'BufferGeometry.toJSON'\r\n			}\r\n		};\r\n\r\n		// standard BufferGeometry serialization\r\n\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n		if ( this.name !== '' ) data.name = this.name;\r\n\r\n		if ( this.parameters !== undefined ) {\r\n\r\n			var parameters = this.parameters;\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n			}\r\n\r\n			return data;\r\n\r\n		}\r\n\r\n		data.data = { attributes: {} };\r\n\r\n		var index = this.index;\r\n\r\n		if ( index !== null ) {\r\n\r\n			var array = Array.prototype.slice.call( index.array );\r\n\r\n			data.data.index = {\r\n				type: index.array.constructor.name,\r\n				array: array\r\n			};\r\n\r\n		}\r\n\r\n		var attributes = this.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			var attribute = attributes[ key ];\r\n\r\n			var array = Array.prototype.slice.call( attribute.array );\r\n\r\n			data.data.attributes[ key ] = {\r\n				itemSize: attribute.itemSize,\r\n				type: attribute.array.constructor.name,\r\n				array: array\r\n			};\r\n\r\n		}\r\n\r\n		var groups = this.groups;\r\n\r\n		if ( groups.length > 0 ) {\r\n\r\n			data.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n		}\r\n\r\n		var boundingSphere = this.boundingSphere;\r\n\r\n		if ( boundingSphere !== null ) {\r\n\r\n			data.data.boundingSphere = {\r\n				center: boundingSphere.center.toArray(),\r\n				radius: boundingSphere.radius\r\n			};\r\n\r\n		}\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		var index = source.index;\r\n\r\n		if ( index !== null ) {\r\n\r\n			this.setIndex( index.clone() );\r\n\r\n		}\r\n\r\n		var attributes = source.attributes;\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			var attribute = attributes[ name ];\r\n			this.addAttribute( name, attribute.clone() );\r\n\r\n		}\r\n\r\n		var groups = source.groups;\r\n\r\n		for ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n			var group = groups[ i ];\r\n			this.addGroup( group.start, group.count );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\nTHREE.BufferGeometry.MaxIndex = 65535;\r\n\r\n// File:src/core/InstancedBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferGeometry = function () {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'InstancedBufferGeometry';\r\n	this.maxInstancedCount = undefined;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\r\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\r\n	this.groups.push( {\r\n\r\n		start: start,\r\n		count: count,\r\n		instances: instances\r\n\r\n	} );\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\r\n	var index = source.index;\r\n\r\n	if ( index !== null ) {\r\n\r\n		this.setIndex( index.clone() );\r\n\r\n	}\r\n\r\n	var attributes = source.attributes;\r\n\r\n	for ( var name in attributes ) {\r\n\r\n		var attribute = attributes[ name ];\r\n		this.addAttribute( name, attribute.clone() );\r\n\r\n	}\r\n\r\n	var groups = source.groups;\r\n\r\n	for ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n		var group = groups[ i ];\r\n		this.addGroup( group.start, group.count, group.instances );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Camera';\r\n\r\n	this.matrixWorldInverse = new THREE.Matrix4();\r\n	this.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n	var quaternion = new THREE.Quaternion();\r\n\r\n	return function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		this.getWorldQuaternion( quaternion );\r\n\r\n		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n	// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n	var m1 = new THREE.Matrix4();\r\n\r\n	return function ( vector ) {\r\n\r\n		m1.lookAt( this.position, vector, this.up );\r\n\r\n		this.quaternion.setFromRotationMatrix( m1 );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function () {\r\n\r\n	return new this.constructor().copy( this );\r\n\r\n};\r\n\r\nTHREE.Camera.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	this.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n	this.projectionMatrix.copy( source.projectionMatrix );\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *	- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'CubeCamera';\r\n\r\n	var fov = 90, aspect = 1;\r\n\r\n	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPX.up.set( 0, - 1, 0 );\r\n	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n	this.add( cameraPX );\r\n\r\n	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNX.up.set( 0, - 1, 0 );\r\n	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n	this.add( cameraNX );\r\n\r\n	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPY.up.set( 0, 0, 1 );\r\n	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n	this.add( cameraPY );\r\n\r\n	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNY.up.set( 0, 0, - 1 );\r\n	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n	this.add( cameraNY );\r\n\r\n	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPZ.up.set( 0, - 1, 0 );\r\n	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n	this.add( cameraPZ );\r\n\r\n	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNZ.up.set( 0, - 1, 0 );\r\n	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n	this.add( cameraNZ );\r\n\r\n	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n	this.updateCubeMap = function ( renderer, scene ) {\r\n\r\n		if ( this.parent === null ) this.updateMatrixWorld();\r\n\r\n		var renderTarget = this.renderTarget;\r\n		var generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n		renderTarget.generateMipmaps = false;\r\n\r\n		renderTarget.activeCubeFace = 0;\r\n		renderer.render( scene, cameraPX, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 1;\r\n		renderer.render( scene, cameraNX, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 2;\r\n		renderer.render( scene, cameraPY, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 3;\r\n		renderer.render( scene, cameraNY, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 4;\r\n		renderer.render( scene, cameraPZ, renderTarget );\r\n\r\n		renderTarget.generateMipmaps = generateMipmaps;\r\n\r\n		renderTarget.activeCubeFace = 5;\r\n		renderer.render( scene, cameraNZ, renderTarget );\r\n\r\n		renderer.setRenderTarget( null );\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n	THREE.Camera.call( this );\r\n\r\n	this.type = 'OrthographicCamera';\r\n\r\n	this.zoom = 1;\r\n\r\n	this.left = left;\r\n	this.right = right;\r\n	this.top = top;\r\n	this.bottom = bottom;\r\n\r\n	this.near = ( near !== undefined ) ? near : 0.1;\r\n	this.far = ( far !== undefined ) ? far : 2000;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n	var dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n	var cx = ( this.right + this.left ) / 2;\r\n	var cy = ( this.top + this.bottom ) / 2;\r\n\r\n	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.copy = function ( source ) {\r\n	\r\n	THREE.Camera.prototype.copy.call( this, source );\r\n	\r\n	this.left = source.left;\r\n	this.right = source.right;\r\n	this.top = source.top;\r\n	this.bottom = source.bottom;\r\n	this.near = source.near;\r\n	this.far = source.far;\r\n	\r\n	this.zoom = source.zoom;\r\n	\r\n	return this;\r\n		\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.zoom = this.zoom;\r\n	data.object.left = this.left;\r\n	data.object.right = this.right;\r\n	data.object.top = this.top;\r\n	data.object.bottom = this.bottom;\r\n	data.object.near = this.near;\r\n	data.object.far = this.far;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n	THREE.Camera.call( this );\r\n\r\n	this.type = 'PerspectiveCamera';\r\n\r\n	this.zoom = 1;\r\n\r\n	this.fov = fov !== undefined ? fov : 50;\r\n	this.aspect = aspect !== undefined ? aspect : 1;\r\n	this.near = near !== undefined ? near : 0.1;\r\n	this.far = far !== undefined ? far : 2000;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (full-frame) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n	if ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n	this.fullWidth = fullWidth;\r\n	this.fullHeight = fullHeight;\r\n	this.x = x;\r\n	this.y = y;\r\n	this.width = width;\r\n	this.height = height;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\r\n	if ( this.fullWidth ) {\r\n\r\n		var aspect = this.fullWidth / this.fullHeight;\r\n		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n		var bottom = - top;\r\n		var left = aspect * bottom;\r\n		var right = aspect * top;\r\n		var width = Math.abs( right - left );\r\n		var height = Math.abs( top - bottom );\r\n\r\n		this.projectionMatrix.makeFrustum(\r\n			left + this.x * width / this.fullWidth,\r\n			left + ( this.x + this.width ) * width / this.fullWidth,\r\n			top - ( this.y + this.height ) * height / this.fullHeight,\r\n			top - this.y * height / this.fullHeight,\r\n			this.near,\r\n			this.far\r\n		);\r\n\r\n	} else {\r\n\r\n		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.copy = function ( source ) {\r\n	\r\n	THREE.Camera.prototype.copy.call( this, source );\r\n	\r\n	this.fov = source.fov;\r\n	this.aspect = source.aspect;\r\n	this.near = source.near;\r\n	this.far = source.far;\r\n	\r\n	this.zoom = source.zoom;\r\n	\r\n	return this;\r\n		\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.zoom = this.zoom;\r\n	data.object.fov = this.fov;\r\n	data.object.aspect = this.aspect;\r\n	data.object.near = this.near;\r\n	data.object.far = this.far;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Light';\r\n\r\n	this.color = new THREE.Color( color );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.copy = function ( source ) {\r\n	\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n	\r\n	this.color.copy( source.color );\r\n	\r\n	return this;\r\n\r\n};\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'AmbientLight';\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\nTHREE.AmbientLight.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.color = this.color.getHex();\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'DirectionalLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.updateMatrix();\r\n\r\n	this.target = new THREE.Object3D();\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n	this.castShadow = false;\r\n	this.onlyShadow = false;\r\n\r\n	this.shadowCameraNear = 50;\r\n	this.shadowCameraFar = 5000;\r\n\r\n	this.shadowCameraLeft = - 500;\r\n	this.shadowCameraRight = 500;\r\n	this.shadowCameraTop = 500;\r\n	this.shadowCameraBottom = - 500;\r\n\r\n	this.shadowCameraVisible = false;\r\n\r\n	this.shadowBias = 0;\r\n	this.shadowDarkness = 0.5;\r\n\r\n	this.shadowMapWidth = 512;\r\n	this.shadowMapHeight = 512;\r\n\r\n	this.shadowMap = null;\r\n	this.shadowMapSize = null;\r\n	this.shadowCamera = null;\r\n	this.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.intensity = source.intensity;\r\n	this.target = source.target.clone();\r\n\r\n	this.castShadow = source.castShadow;\r\n	this.onlyShadow = source.onlyShadow;\r\n\r\n	this.shadowCameraNear = source.shadowCameraNear;\r\n	this.shadowCameraFar = source.shadowCameraFar;\r\n\r\n	this.shadowCameraLeft = source.shadowCameraLeft;\r\n	this.shadowCameraRight = source.shadowCameraRight;\r\n	this.shadowCameraTop = source.shadowCameraTop;\r\n	this.shadowCameraBottom = source.shadowCameraBottom;\r\n\r\n	this.shadowCameraVisible = source.shadowCameraVisible;\r\n\r\n	this.shadowBias = source.shadowBias;\r\n	this.shadowDarkness = source.shadowDarkness;\r\n\r\n	this.shadowMapWidth = source.shadowMapWidth;\r\n	this.shadowMapHeight = source.shadowMapHeight;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.color = this.color.getHex();\r\n	data.object.intensity = this.intensity;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n	THREE.Light.call( this, skyColor );\r\n\r\n	this.type = 'HemisphereLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.updateMatrix();\r\n\r\n	this.groundColor = new THREE.Color( groundColor );\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.groundColor.copy( source.groundColor );\r\n	this.intensity = source.intensity;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.color = this.color.getHex();\r\n	data.object.groundColor = this.groundColor.getHex();\r\n	data.object.intensity = this.intensity;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'PointLight';\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n	this.distance = ( distance !== undefined ) ? distance : 0;\r\n	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nTHREE.PointLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.intensity = source.intensity;\r\n	this.distance = source.distance;\r\n	this.decay = source.decay;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.color = this.color.getHex();\r\n	data.object.intensity = this.intensity;\r\n	data.object.distance = this.distance;\r\n	data.object.decay = this.decay;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'SpotLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.updateMatrix();\r\n\r\n	this.target = new THREE.Object3D();\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n	this.distance = ( distance !== undefined ) ? distance : 0;\r\n	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n	this.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.\r\n\r\n	this.castShadow = false;\r\n	this.onlyShadow = false;\r\n\r\n	this.shadowCameraNear = 50;\r\n	this.shadowCameraFar = 5000;\r\n	this.shadowCameraFov = 50;\r\n\r\n	this.shadowCameraVisible = false;\r\n\r\n	this.shadowBias = 0;\r\n	this.shadowDarkness = 0.5;\r\n\r\n	this.shadowMapWidth = 512;\r\n	this.shadowMapHeight = 512;\r\n\r\n	this.shadowMap = null;\r\n	this.shadowMapSize = null;\r\n	this.shadowCamera = null;\r\n	this.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nTHREE.SpotLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.intensity = source.intensity;\r\n	this.distance = source.distance;\r\n	this.angle = source.angle;\r\n	this.exponent = source.exponent;\r\n	this.decay = source.decay;\r\n\r\n	this.target = source.target.clone();\r\n\r\n	this.castShadow = source.castShadow;\r\n	this.onlyShadow = source.onlyShadow;\r\n\r\n	this.shadowCameraNear = source.shadowCameraNear;\r\n	this.shadowCameraFar = source.shadowCameraFar;\r\n	this.shadowCameraFov = source.shadowCameraFov;\r\n\r\n	this.shadowCameraVisible = source.shadowCameraVisible;\r\n\r\n	this.shadowBias = source.shadowBias;\r\n	this.shadowDarkness = source.shadowDarkness;\r\n\r\n	this.shadowMapWidth = source.shadowMapWidth;\r\n	this.shadowMapHeight = source.shadowMapHeight;\r\n\r\n	return this;\r\n}\r\n\r\nTHREE.SpotLight.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.color = this.color.getHex();\r\n	data.object.intensity = this.intensity;\r\n	data.object.distance = this.distance;\r\n	data.object.angle = this.angle;\r\n	data.object.exponent = this.exponent;\r\n	data.object.decay = this.decay;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n	enabled: false,\r\n\r\n	files: {},\r\n\r\n	add: function ( key, file ) {\r\n\r\n		if ( this.enabled === false ) return;\r\n\r\n		// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n		this.files[ key ] = file;\r\n\r\n	},\r\n\r\n	get: function ( key ) {\r\n\r\n		if ( this.enabled === false ) return;\r\n\r\n		// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n		return this.files[ key ];\r\n\r\n	},\r\n\r\n	remove: function ( key ) {\r\n\r\n		delete this.files[ key ];\r\n\r\n	},\r\n\r\n	clear: function () {\r\n\r\n		this.files = {};\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function () {\r\n\r\n	this.onLoadStart = function () {};\r\n	this.onLoadProgress = function () {};\r\n	this.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n	constructor: THREE.Loader,\r\n\r\n	crossOrigin: undefined,\r\n\r\n	extractUrlBase: function ( url ) {\r\n\r\n		var parts = url.split( '/' );\r\n\r\n		if ( parts.length === 1 ) return './';\r\n\r\n		parts.pop();\r\n\r\n		return parts.join( '/' ) + '/';\r\n\r\n	},\r\n\r\n	initMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\r\n		var array = [];\r\n\r\n		for ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\r\n		}\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	createMaterial: ( function () {\r\n\r\n		var imageLoader;\r\n\r\n		return function createMaterial( m, texturePath, crossOrigin ) {\r\n\r\n			var scope = this;\r\n\r\n			if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;\r\n\r\n			if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();\r\n\r\n			function nearest_pow2( n ) {\r\n\r\n				var l = Math.log( n ) / Math.LN2;\r\n				return Math.pow( 2, Math.round(  l ) );\r\n\r\n			}\r\n\r\n			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n				var fullPath = texturePath + sourceFile;\r\n\r\n				var texture;\r\n\r\n				var loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n				if ( loader !== null ) {\r\n\r\n					texture = loader.load( fullPath );\r\n\r\n				} else {\r\n\r\n					texture = new THREE.Texture();\r\n\r\n					loader = imageLoader;\r\n					loader.setCrossOrigin( crossOrigin );\r\n					loader.load( fullPath, function ( image ) {\r\n\r\n						if ( THREE.Math.isPowerOfTwo( image.width ) === false ||\r\n							THREE.Math.isPowerOfTwo( image.height ) === false ) {\r\n\r\n							var width = nearest_pow2( image.width );\r\n							var height = nearest_pow2( image.height );\r\n\r\n							var canvas = document.createElement( 'canvas' );\r\n							canvas.width = width;\r\n							canvas.height = height;\r\n\r\n							var context = canvas.getContext( '2d' );\r\n							context.drawImage( image, 0, 0, width, height );\r\n\r\n							texture.image = canvas;\r\n\r\n						} else {\r\n\r\n							texture.image = image;\r\n\r\n						}\r\n\r\n						texture.needsUpdate = true;\r\n\r\n					} );\r\n\r\n				}\r\n\r\n				texture.sourceFile = sourceFile;\r\n\r\n				if ( repeat ) {\r\n\r\n					texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n				}\r\n\r\n				if ( offset ) {\r\n\r\n					texture.offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n				}\r\n\r\n				if ( wrap ) {\r\n\r\n					var wrapMap = {\r\n						'repeat': THREE.RepeatWrapping,\r\n						'mirror': THREE.MirroredRepeatWrapping\r\n					};\r\n\r\n					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];\r\n					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n				}\r\n\r\n				if ( anisotropy ) {\r\n\r\n					texture.anisotropy = anisotropy;\r\n\r\n				}\r\n\r\n				where[ name ] = texture;\r\n\r\n			}\r\n\r\n			function rgb2hex( rgb ) {\r\n\r\n				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n			}\r\n\r\n			// defaults\r\n\r\n			var mtype = 'MeshLambertMaterial';\r\n			var mpars = {};\r\n\r\n			// parameters from model file\r\n\r\n			if ( m.shading ) {\r\n\r\n				var shading = m.shading.toLowerCase();\r\n\r\n				if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';\r\n				else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';\r\n\r\n			}\r\n\r\n			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n				mpars.blending = THREE[ m.blending ];\r\n\r\n			}\r\n\r\n			if ( m.transparent !== undefined ) {\r\n\r\n				mpars.transparent = m.transparent;\r\n\r\n			}\r\n\r\n			if ( m.opacity !== undefined && m.opacity < 1.0 ) {\r\n\r\n				mpars.transparent = true;\r\n\r\n			}\r\n\r\n			if ( m.depthTest !== undefined ) {\r\n\r\n				mpars.depthTest = m.depthTest;\r\n\r\n			}\r\n\r\n			if ( m.depthWrite !== undefined ) {\r\n\r\n				mpars.depthWrite = m.depthWrite;\r\n\r\n			}\r\n\r\n			if ( m.visible !== undefined ) {\r\n\r\n				mpars.visible = m.visible;\r\n\r\n			}\r\n\r\n			if ( m.flipSided !== undefined ) {\r\n\r\n				mpars.side = THREE.BackSide;\r\n\r\n			}\r\n\r\n			if ( m.doubleSided !== undefined ) {\r\n\r\n				mpars.side = THREE.DoubleSide;\r\n\r\n			}\r\n\r\n			if ( m.wireframe !== undefined ) {\r\n\r\n				mpars.wireframe = m.wireframe;\r\n\r\n			}\r\n\r\n			if ( m.vertexColors !== undefined ) {\r\n\r\n				if ( m.vertexColors === 'face' ) {\r\n\r\n					mpars.vertexColors = THREE.FaceColors;\r\n\r\n				} else if ( m.vertexColors ) {\r\n\r\n					mpars.vertexColors = THREE.VertexColors;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// colors\r\n\r\n			if ( m.colorDiffuse ) {\r\n\r\n				mpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n			} else if ( m.DbgColor ) {\r\n\r\n				mpars.color = m.DbgColor;\r\n\r\n			}\r\n\r\n			if ( m.colorEmissive ) {\r\n\r\n				mpars.emissive = rgb2hex( m.colorEmissive );\r\n\r\n			}\r\n\r\n			if ( mtype === 'MeshPhongMaterial' ) {\r\n\r\n				if ( m.colorSpecular ) {\r\n\r\n					mpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n				}\r\n\r\n				if ( m.specularCoef ) {\r\n\r\n					mpars.shininess = m.specularCoef;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// modifiers\r\n\r\n			if ( m.transparency !== undefined ) {\r\n\r\n				console.warn( 'THREE.Loader: transparency has been renamed to opacity' );\r\n				m.opacity = m.transparency;\r\n\r\n			}\r\n\r\n			if ( m.opacity !== undefined ) {\r\n\r\n				mpars.opacity = m.opacity;\r\n\r\n			}\r\n\r\n			// textures\r\n\r\n			if ( texturePath ) {\r\n\r\n				if ( m.mapDiffuse ) {\r\n\r\n					create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n				}\r\n\r\n				if ( m.mapLight ) {\r\n\r\n					create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n				}\r\n\r\n				if ( m.mapAO ) {\r\n\r\n					create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\r\n				}\r\n\r\n				if ( m.mapBump ) {\r\n\r\n					create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n				}\r\n\r\n				if ( m.mapNormal ) {\r\n\r\n					create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n				}\r\n\r\n				if ( m.mapSpecular ) {\r\n\r\n					create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n				}\r\n\r\n				if ( m.mapAlpha ) {\r\n\r\n					create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			//\r\n\r\n			if ( m.mapBumpScale ) {\r\n\r\n				mpars.bumpScale = m.mapBumpScale;\r\n\r\n			}\r\n\r\n			if ( m.mapNormalFactor ) {\r\n\r\n				mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n			}\r\n\r\n			var material = new THREE[ mtype ]( mpars );\r\n\r\n			if ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n			return material;\r\n\r\n		};\r\n\r\n	} )()\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n	handlers: [],\r\n\r\n	add: function ( regex, loader ) {\r\n\r\n		this.handlers.push( regex, loader );\r\n\r\n	},\r\n\r\n	get: function ( file ) {\r\n\r\n		for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\r\n			var regex = this.handlers[ i ];\r\n			var loader  = this.handlers[ i + 1 ];\r\n\r\n			if ( regex.test( file ) ) {\r\n\r\n				return loader;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return null;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n	constructor: THREE.XHRLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var cached = THREE.Cache.get( url );\r\n\r\n		if ( cached !== undefined ) {\r\n\r\n			if ( onLoad ) {\r\n\r\n				setTimeout( function () {\r\n\r\n					onLoad( cached );\r\n\r\n				}, 0 );\r\n\r\n			}\r\n\r\n			return cached;\r\n\r\n		}\r\n\r\n		var request = new XMLHttpRequest();\r\n		request.open( 'GET', url, true );\r\n\r\n		request.addEventListener( 'load', function ( event ) {\r\n\r\n			THREE.Cache.add( url, this.response );\r\n\r\n			if ( onLoad ) onLoad( this.response );\r\n\r\n			scope.manager.itemEnd( url );\r\n\r\n		}, false );\r\n\r\n		if ( onProgress !== undefined ) {\r\n\r\n			request.addEventListener( 'progress', function ( event ) {\r\n\r\n				onProgress( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		request.addEventListener( 'error', function ( event ) {\r\n\r\n			if ( onError ) onError( event );\r\n\r\n			scope.manager.itemError( url );\r\n\r\n		}, false );\r\n\r\n		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n		if ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\r\n		request.send( null );\r\n\r\n		scope.manager.itemStart( url );\r\n\r\n		return request;\r\n\r\n	},\r\n\r\n	setResponseType: function ( value ) {\r\n\r\n		this.responseType = value;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	setWithCredentials: function ( value ) {\r\n\r\n		this.withCredentials = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n	constructor: THREE.ImageLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var cached = THREE.Cache.get( url );\r\n\r\n		if ( cached !== undefined ) {\r\n\r\n			if ( onLoad ) {\r\n\r\n				setTimeout( function () {\r\n\r\n					onLoad( cached );\r\n\r\n				}, 0 );\r\n\r\n			}\r\n\r\n			return cached;\r\n\r\n		}\r\n\r\n		var image = document.createElement( 'img' );\r\n\r\n		image.addEventListener( 'load', function ( event ) {\r\n\r\n			THREE.Cache.add( url, this );\r\n\r\n			if ( onLoad ) onLoad( this );\r\n\r\n			scope.manager.itemEnd( url );\r\n\r\n		}, false );\r\n\r\n		if ( onProgress !== undefined ) {\r\n\r\n			image.addEventListener( 'progress', function ( event ) {\r\n\r\n				onProgress( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		image.addEventListener( 'error', function ( event ) {\r\n\r\n			if ( onError ) onError( event );\r\n\r\n			scope.manager.itemError( url );\r\n\r\n		}, false );\r\n\r\n		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n		scope.manager.itemStart( url );\r\n\r\n		image.src = url;\r\n\r\n		return image;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( manager ) {\r\n\r\n	if ( typeof manager === 'boolean' ) {\r\n\r\n		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n		manager = undefined;\r\n\r\n	}\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n	this.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = {\r\n\r\n	constructor: THREE.JSONLoader,\r\n\r\n	// Deprecated\r\n	\r\n	get statusDomElement () {\r\n\r\n		if ( this._statusDomElement === undefined ) {\r\n\r\n			this._statusDomElement = document.createElement( 'div' );\r\n\r\n		}\r\n\r\n		console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n		return this._statusDomElement;\r\n\r\n	},\r\n\r\n	load: function( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.setWithCredentials( this.withCredentials );\r\n		loader.load( url, function ( text ) {\r\n\r\n			var json = JSON.parse( text );\r\n			var metadata = json.metadata;\r\n\r\n			if ( metadata !== undefined ) {\r\n\r\n				if ( metadata.type === 'object' ) {\r\n\r\n					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n					return;\r\n\r\n				}\r\n\r\n				if ( metadata.type === 'scene' ) {\r\n\r\n					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n					return;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var object = scope.parse( json, texturePath );\r\n			onLoad( object.geometry, object.materials );\r\n\r\n		} );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	setTexturePath: function ( value ) {\r\n\r\n		this.texturePath = value;\r\n\r\n	},\r\n\r\n	parse: function ( json, texturePath ) {\r\n\r\n		var geometry = new THREE.Geometry(),\r\n		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n		parseModel( scale );\r\n\r\n		parseSkin();\r\n		parseMorphing( scale );\r\n\r\n		geometry.computeFaceNormals();\r\n		geometry.computeBoundingSphere();\r\n\r\n		function parseModel( scale ) {\r\n\r\n			function isBitSet( value, position ) {\r\n\r\n				return value & ( 1 << position );\r\n\r\n			}\r\n\r\n			var i, j, fi,\r\n\r\n			offset, zLength,\r\n\r\n		colorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n			type,\r\n			isQuad,\r\n			hasMaterial,\r\n			hasFaceVertexUv,\r\n			hasFaceNormal, hasFaceVertexNormal,\r\n			hasFaceColor, hasFaceVertexColor,\r\n\r\n		vertex, face, faceA, faceB, hex, normal,\r\n\r\n			uvLayer, uv, u, v,\r\n\r\n			faces = json.faces,\r\n			vertices = json.vertices,\r\n			normals = json.normals,\r\n			colors = json.colors,\r\n\r\n			nUvLayers = 0;\r\n\r\n			if ( json.uvs !== undefined ) {\r\n\r\n				// disregard empty arrays\r\n\r\n				for ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n					if ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n				}\r\n\r\n				for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n					geometry.faceVertexUvs[ i ] = [];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			offset = 0;\r\n			zLength = vertices.length;\r\n\r\n			while ( offset < zLength ) {\r\n\r\n				vertex = new THREE.Vector3();\r\n\r\n				vertex.x = vertices[ offset ++ ] * scale;\r\n				vertex.y = vertices[ offset ++ ] * scale;\r\n				vertex.z = vertices[ offset ++ ] * scale;\r\n\r\n				geometry.vertices.push( vertex );\r\n\r\n			}\r\n\r\n			offset = 0;\r\n			zLength = faces.length;\r\n\r\n			while ( offset < zLength ) {\r\n\r\n				type = faces[ offset ++ ];\r\n\r\n\r\n				isQuad              = isBitSet( type, 0 );\r\n				hasMaterial         = isBitSet( type, 1 );\r\n				hasFaceVertexUv     = isBitSet( type, 3 );\r\n				hasFaceNormal       = isBitSet( type, 4 );\r\n				hasFaceVertexNormal = isBitSet( type, 5 );\r\n				hasFaceColor	     = isBitSet( type, 6 );\r\n				hasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n				// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n				if ( isQuad ) {\r\n\r\n					faceA = new THREE.Face3();\r\n					faceA.a = faces[ offset ];\r\n					faceA.b = faces[ offset + 1 ];\r\n					faceA.c = faces[ offset + 3 ];\r\n\r\n					faceB = new THREE.Face3();\r\n					faceB.a = faces[ offset + 1 ];\r\n					faceB.b = faces[ offset + 2 ];\r\n					faceB.c = faces[ offset + 3 ];\r\n\r\n					offset += 4;\r\n\r\n					if ( hasMaterial ) {\r\n\r\n						materialIndex = faces[ offset ++ ];\r\n						faceA.materialIndex = materialIndex;\r\n						faceB.materialIndex = materialIndex;\r\n\r\n					}\r\n\r\n					// to get face <=> uv index correspondence\r\n\r\n					fi = geometry.faces.length;\r\n\r\n					if ( hasFaceVertexUv ) {\r\n\r\n						for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n							uvLayer = json.uvs[ i ];\r\n\r\n							geometry.faceVertexUvs[ i ][ fi ] = [];\r\n							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\r\n							for ( j = 0; j < 4; j ++ ) {\r\n\r\n								uvIndex = faces[ offset ++ ];\r\n\r\n								u = uvLayer[ uvIndex * 2 ];\r\n								v = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n								uv = new THREE.Vector2( u, v );\r\n\r\n								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n					if ( hasFaceNormal ) {\r\n\r\n						normalIndex = faces[ offset ++ ] * 3;\r\n\r\n						faceA.normal.set(\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ]\r\n						);\r\n\r\n						faceB.normal.copy( faceA.normal );\r\n\r\n					}\r\n\r\n					if ( hasFaceVertexNormal ) {\r\n\r\n						for ( i = 0; i < 4; i ++ ) {\r\n\r\n							normalIndex = faces[ offset ++ ] * 3;\r\n\r\n							normal = new THREE.Vector3(\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ]\r\n							);\r\n\r\n\r\n							if ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n							if ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n						}\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceColor ) {\r\n\r\n						colorIndex = faces[ offset ++ ];\r\n						hex = colors[ colorIndex ];\r\n\r\n						faceA.color.setHex( hex );\r\n						faceB.color.setHex( hex );\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceVertexColor ) {\r\n\r\n						for ( i = 0; i < 4; i ++ ) {\r\n\r\n							colorIndex = faces[ offset ++ ];\r\n							hex = colors[ colorIndex ];\r\n\r\n							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					geometry.faces.push( faceA );\r\n					geometry.faces.push( faceB );\r\n\r\n				} else {\r\n\r\n					face = new THREE.Face3();\r\n					face.a = faces[ offset ++ ];\r\n					face.b = faces[ offset ++ ];\r\n					face.c = faces[ offset ++ ];\r\n\r\n					if ( hasMaterial ) {\r\n\r\n						materialIndex = faces[ offset ++ ];\r\n						face.materialIndex = materialIndex;\r\n\r\n					}\r\n\r\n					// to get face <=> uv index correspondence\r\n\r\n					fi = geometry.faces.length;\r\n\r\n					if ( hasFaceVertexUv ) {\r\n\r\n						for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n							uvLayer = json.uvs[ i ];\r\n\r\n							geometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n							for ( j = 0; j < 3; j ++ ) {\r\n\r\n								uvIndex = faces[ offset ++ ];\r\n\r\n								u = uvLayer[ uvIndex * 2 ];\r\n								v = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n								uv = new THREE.Vector2( u, v );\r\n\r\n								geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n					if ( hasFaceNormal ) {\r\n\r\n						normalIndex = faces[ offset ++ ] * 3;\r\n\r\n						face.normal.set(\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ]\r\n						);\r\n\r\n					}\r\n\r\n					if ( hasFaceVertexNormal ) {\r\n\r\n						for ( i = 0; i < 3; i ++ ) {\r\n\r\n							normalIndex = faces[ offset ++ ] * 3;\r\n\r\n							normal = new THREE.Vector3(\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ]\r\n							);\r\n\r\n							face.vertexNormals.push( normal );\r\n\r\n						}\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceColor ) {\r\n\r\n						colorIndex = faces[ offset ++ ];\r\n						face.color.setHex( colors[ colorIndex ] );\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceVertexColor ) {\r\n\r\n						for ( i = 0; i < 3; i ++ ) {\r\n\r\n							colorIndex = faces[ offset ++ ];\r\n							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					geometry.faces.push( face );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		};\r\n\r\n		function parseSkin() {\r\n\r\n			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n			if ( json.skinWeights ) {\r\n\r\n				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n					var x =                               json.skinWeights[ i ];\r\n					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( json.skinIndices ) {\r\n\r\n				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n					var a =                               json.skinIndices[ i ];\r\n					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			geometry.bones = json.bones;\r\n\r\n			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n			}\r\n\r\n\r\n			// could change this to json.animations[0] or remove completely\r\n\r\n			geometry.animation = json.animation;\r\n			geometry.animations = json.animations;\r\n\r\n		};\r\n\r\n		function parseMorphing( scale ) {\r\n\r\n			if ( json.morphTargets !== undefined ) {\r\n\r\n				var i, l, v, vl, dstVertices, srcVertices;\r\n\r\n				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n					geometry.morphTargets[ i ] = {};\r\n					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n					geometry.morphTargets[ i ].vertices = [];\r\n\r\n					dstVertices = geometry.morphTargets[ i ].vertices;\r\n					srcVertices = json.morphTargets[ i ].vertices;\r\n\r\n					for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n						var vertex = new THREE.Vector3();\r\n						vertex.x = srcVertices[ v ] * scale;\r\n						vertex.y = srcVertices[ v + 1 ] * scale;\r\n						vertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n						dstVertices.push( vertex );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( json.morphColors !== undefined ) {\r\n\r\n				var i, l, c, cl, dstColors, srcColors, color;\r\n\r\n				for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {\r\n\r\n					geometry.morphColors[ i ] = {};\r\n					geometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n					geometry.morphColors[ i ].colors = [];\r\n\r\n					dstColors = geometry.morphColors[ i ].colors;\r\n					srcColors = json.morphColors[ i ].colors;\r\n\r\n					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n						color = new THREE.Color( 0xffaa00 );\r\n						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n						dstColors.push( color );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		};\r\n\r\n		if ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n			return { geometry: geometry };\r\n\r\n		} else {\r\n\r\n			var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\r\n			return { geometry: geometry, materials: materials };\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n	var scope = this;\r\n\r\n	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\r\n	this.onStart = undefined;\r\n	this.onLoad = onLoad;\r\n	this.onProgress = onProgress;\r\n	this.onError = onError;\r\n\r\n	this.itemStart = function ( url ) {\r\n\r\n		itemsTotal ++;\r\n\r\n		if ( isLoading === false ) {\r\n\r\n			if ( scope.onStart !== undefined ) {\r\n\r\n				scope.onStart( url, itemsLoaded, itemsTotal );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		isLoading = true;\r\n\r\n	};\r\n\r\n	this.itemEnd = function ( url ) {\r\n\r\n		itemsLoaded ++;\r\n\r\n		if ( scope.onProgress !== undefined ) {\r\n\r\n			scope.onProgress( url, itemsLoaded, itemsTotal );\r\n\r\n		}\r\n\r\n		if ( itemsLoaded === itemsTotal ) {\r\n\r\n			isLoading = false;\r\n\r\n			if ( scope.onLoad !== undefined ) {\r\n\r\n				scope.onLoad();\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.itemError = function ( url ) {\r\n\r\n		if ( scope.onError !== undefined ) {\r\n\r\n			scope.onError( url );\r\n\r\n		}\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n	constructor: THREE.BufferGeometryLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var geometry = new THREE.BufferGeometry();\r\n\r\n		var index = json.data.index;\r\n\r\n		if ( index !== undefined ) {\r\n\r\n			var typedArray = new self[ index.type ]( index.array );\r\n			geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\r\n		}\r\n\r\n		var attributes = json.data.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			var attribute = attributes[ key ];\r\n			var typedArray = new self[ attribute.type ]( attribute.array );\r\n\r\n			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\r\n		}\r\n\r\n		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n		if ( groups !== undefined ) {\r\n\r\n			for ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n				var group = groups[ i ];\r\n\r\n				geometry.addGroup( group.start, group.count );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var boundingSphere = json.data.boundingSphere;\r\n\r\n		if ( boundingSphere !== undefined ) {\r\n\r\n			var center = new THREE.Vector3();\r\n\r\n			if ( boundingSphere.center !== undefined ) {\r\n\r\n				center.fromArray( boundingSphere.center );\r\n\r\n			}\r\n\r\n			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n	this.textures = {};\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n	constructor: THREE.MaterialLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	setTextures: function ( value ) {\r\n\r\n		this.textures = value;\r\n\r\n	},\r\n\r\n	getTexture: function ( name ) {\r\n\r\n		var textures = this.textures;\r\n\r\n		if ( textures[ name ] === undefined ) {\r\n\r\n			console.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\r\n		}\r\n\r\n		return textures[ name ];\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var material = new THREE[ json.type ];\r\n		material.uuid = json.uuid;\r\n\r\n		if ( json.name !== undefined ) material.name = json.name;\r\n		if ( json.color !== undefined ) material.color.setHex( json.color );\r\n		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n		if ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n		if ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n		if ( json.shading !== undefined ) material.shading = json.shading;\r\n		if ( json.blending !== undefined ) material.blending = json.blending;\r\n		if ( json.side !== undefined ) material.side = json.side;\r\n		if ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n		if ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\r\n		// for PointsMaterial\r\n		if ( json.size !== undefined ) material.size = json.size;\r\n		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n		// maps\r\n\r\n		if ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\r\n		if ( json.alphaMap !== undefined ) {\r\n\r\n			material.alphaMap = this.getTexture( json.alphaMap );\r\n			material.transparent = true;\r\n\r\n		}\r\n\r\n		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\r\n		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n		if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );\r\n\r\n		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\r\n		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\r\n		if ( json.envMap !== undefined ) {\r\n\r\n			material.envMap = this.getTexture( json.envMap );\r\n			material.combine = THREE.MultiplyOperation;\r\n\r\n		}\r\n\r\n		if ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\r\n		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\r\n		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\r\n		// MeshFaceMaterial\r\n\r\n		if ( json.materials !== undefined ) {\r\n\r\n			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n				material.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n	this.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n	constructor: THREE.ObjectLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		if ( this.texturePath === '' ) {\r\n\r\n			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n		}\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( text ) {\r\n\r\n			scope.parse( JSON.parse( text ), onLoad );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setTexturePath: function ( value ) {\r\n\r\n		this.texturePath = value;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	parse: function ( json, onLoad ) {\r\n\r\n		var geometries = this.parseGeometries( json.geometries );\r\n\r\n		var images = this.parseImages( json.images, function () {\r\n\r\n			if ( onLoad !== undefined ) onLoad( object );\r\n\r\n		} );\r\n\r\n		var textures  = this.parseTextures( json.textures, images );\r\n		var materials = this.parseMaterials( json.materials, textures );\r\n		var object = this.parseObject( json.object, geometries, materials );\r\n\r\n		if ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n			if ( onLoad !== undefined ) onLoad( object );\r\n\r\n		}\r\n\r\n		return object;\r\n\r\n	},\r\n\r\n	parseGeometries: function ( json ) {\r\n\r\n		var geometries = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			var geometryLoader = new THREE.JSONLoader();\r\n			var bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var geometry;\r\n				var data = json[ i ];\r\n\r\n				switch ( data.type ) {\r\n\r\n					case 'PlaneGeometry':\r\n					case 'PlaneBufferGeometry':\r\n\r\n						geometry = new THREE[ data.type ](\r\n							data.width,\r\n							data.height,\r\n							data.widthSegments,\r\n							data.heightSegments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'BoxGeometry':\r\n					case 'CubeGeometry': // backwards compatible\r\n\r\n						geometry = new THREE.BoxGeometry(\r\n							data.width,\r\n							data.height,\r\n							data.depth,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.depthSegments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CircleBufferGeometry':\r\n\r\n						geometry = new THREE.CircleBufferGeometry(\r\n							data.radius,\r\n							data.segments,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CircleGeometry':\r\n\r\n						geometry = new THREE.CircleGeometry(\r\n							data.radius,\r\n							data.segments,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CylinderGeometry':\r\n\r\n						geometry = new THREE.CylinderGeometry(\r\n							data.radiusTop,\r\n							data.radiusBottom,\r\n							data.height,\r\n							data.radialSegments,\r\n							data.heightSegments,\r\n							data.openEnded,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'SphereGeometry':\r\n\r\n						geometry = new THREE.SphereGeometry(\r\n							data.radius,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.phiStart,\r\n							data.phiLength,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'SphereBufferGeometry':\r\n\r\n						geometry = new THREE.SphereBufferGeometry(\r\n							data.radius,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.phiStart,\r\n							data.phiLength,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'DodecahedronGeometry':\r\n\r\n						geometry = new THREE.DodecahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'IcosahedronGeometry':\r\n\r\n						geometry = new THREE.IcosahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'OctahedronGeometry':\r\n\r\n						geometry = new THREE.OctahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TetrahedronGeometry':\r\n\r\n						geometry = new THREE.TetrahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'RingGeometry':\r\n\r\n						geometry = new THREE.RingGeometry(\r\n							data.innerRadius,\r\n							data.outerRadius,\r\n							data.thetaSegments,\r\n							data.phiSegments,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TorusGeometry':\r\n\r\n						geometry = new THREE.TorusGeometry(\r\n							data.radius,\r\n							data.tube,\r\n							data.radialSegments,\r\n							data.tubularSegments,\r\n							data.arc\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TorusKnotGeometry':\r\n\r\n						geometry = new THREE.TorusKnotGeometry(\r\n							data.radius,\r\n							data.tube,\r\n							data.radialSegments,\r\n							data.tubularSegments,\r\n							data.p,\r\n							data.q,\r\n							data.heightScale\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TextGeometry':\r\n\r\n						geometry = new THREE.TextGeometry(\r\n							data.text,\r\n							data.data\r\n						);\r\n\r\n						break;\r\n\r\n					case 'BufferGeometry':\r\n\r\n						geometry = bufferGeometryLoader.parse( data );\r\n\r\n						break;\r\n\r\n					case 'Geometry':\r\n\r\n						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\r\n						break;\r\n\r\n					default:\r\n\r\n						console.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\r\n						continue;\r\n\r\n				}\r\n\r\n				geometry.uuid = data.uuid;\r\n\r\n				if ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n				geometries[ data.uuid ] = geometry;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return geometries;\r\n\r\n	},\r\n\r\n	parseMaterials: function ( json, textures ) {\r\n\r\n		var materials = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			var loader = new THREE.MaterialLoader();\r\n			loader.setTextures( textures );\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var material = loader.parse( json[ i ] );\r\n				materials[ material.uuid ] = material;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return materials;\r\n\r\n	},\r\n\r\n	parseImages: function ( json, onLoad ) {\r\n\r\n		var scope = this;\r\n		var images = {};\r\n\r\n		function loadImage( url ) {\r\n\r\n			scope.manager.itemStart( url );\r\n\r\n			return loader.load( url, function () {\r\n\r\n				scope.manager.itemEnd( url );\r\n\r\n			} );\r\n\r\n		}\r\n\r\n		if ( json !== undefined && json.length > 0 ) {\r\n\r\n			var manager = new THREE.LoadingManager( onLoad );\r\n\r\n			var loader = new THREE.ImageLoader( manager );\r\n			loader.setCrossOrigin( this.crossOrigin );\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var image = json[ i ];\r\n				var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n				images[ image.uuid ] = loadImage( path );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return images;\r\n\r\n	},\r\n\r\n	parseTextures: function ( json, images ) {\r\n\r\n		function parseConstant( value ) {\r\n\r\n			if ( typeof( value ) === 'number' ) return value;\r\n\r\n			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n			return THREE[ value ];\r\n\r\n		}\r\n\r\n		var textures = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var data = json[ i ];\r\n\r\n				if ( data.image === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n				}\r\n\r\n				if ( images[ data.image ] === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n				}\r\n\r\n				var texture = new THREE.Texture( images[ data.image ] );\r\n				texture.needsUpdate = true;\r\n\r\n				texture.uuid = data.uuid;\r\n\r\n				if ( data.name !== undefined ) texture.name = data.name;\r\n				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n				if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n				if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n				if ( Array.isArray( data.wrap ) ) {\r\n\r\n					texture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n					texture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\r\n				}\r\n\r\n				textures[ data.uuid ] = texture;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return textures;\r\n\r\n	},\r\n\r\n	parseObject: function () {\r\n\r\n		var matrix = new THREE.Matrix4();\r\n\r\n		return function ( data, geometries, materials ) {\r\n\r\n			var object;\r\n\r\n			var getGeometry = function ( name ) {\r\n\r\n				if ( geometries[ name ] === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n				}\r\n\r\n				return geometries[ name ];\r\n\r\n			};\r\n\r\n			var getMaterial = function ( name ) {\r\n\r\n				if ( materials[ name ] === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n				}\r\n\r\n				return materials[ name ];\r\n\r\n			};\r\n\r\n			switch ( data.type ) {\r\n\r\n				case 'Scene':\r\n\r\n					object = new THREE.Scene();\r\n\r\n					break;\r\n\r\n				case 'PerspectiveCamera':\r\n\r\n					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n					break;\r\n\r\n				case 'OrthographicCamera':\r\n\r\n					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n					break;\r\n\r\n				case 'AmbientLight':\r\n\r\n					object = new THREE.AmbientLight( data.color );\r\n\r\n					break;\r\n\r\n				case 'DirectionalLight':\r\n\r\n					object = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'PointLight':\r\n\r\n					object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n					break;\r\n\r\n				case 'SpotLight':\r\n\r\n					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );\r\n\r\n					break;\r\n\r\n				case 'HemisphereLight':\r\n\r\n					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'Mesh':\r\n\r\n					object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n					break;\r\n\r\n				case 'LOD':\r\n\r\n					object = new THREE.LOD();\r\n\r\n					break;\r\n\r\n				case 'Line':\r\n\r\n					object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n					break;\r\n\r\n				case 'PointCloud':\r\n				case 'Points':\r\n\r\n					object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n					break;\r\n\r\n				case 'Sprite':\r\n\r\n					object = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n					break;\r\n\r\n				case 'Group':\r\n\r\n					object = new THREE.Group();\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					object = new THREE.Object3D();\r\n\r\n			}\r\n\r\n			object.uuid = data.uuid;\r\n\r\n			if ( data.name !== undefined ) object.name = data.name;\r\n			if ( data.matrix !== undefined ) {\r\n\r\n				matrix.fromArray( data.matrix );\r\n				matrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n			} else {\r\n\r\n				if ( data.position !== undefined ) object.position.fromArray( data.position );\r\n				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n			}\r\n\r\n			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\r\n			if ( data.visible !== undefined ) object.visible = data.visible;\r\n			if ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n			if ( data.children !== undefined ) {\r\n\r\n				for ( var child in data.children ) {\r\n\r\n					object.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( data.type === 'LOD' ) {\r\n\r\n				var levels = data.levels;\r\n\r\n				for ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n					var level = levels[ l ];\r\n					var child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n					if ( child !== undefined ) {\r\n\r\n						object.addLevel( child, level.distance );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return object;\r\n\r\n		}\r\n\r\n	}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n	constructor: THREE.TextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.ImageLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( image ) {\r\n\r\n			var texture = new THREE.Texture( image );\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad !== undefined ) {\r\n\r\n				onLoad( texture );\r\n\r\n			}\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n	// override in sub classes\r\n	this._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n	constructor: THREE.BinaryTextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var texture = new THREE.DataTexture();\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.setResponseType( 'arraybuffer' );\r\n\r\n		loader.load( url, function ( buffer ) {\r\n\r\n			var texData = scope._parser( buffer );\r\n\r\n			if ( ! texData ) return;\r\n\r\n			if ( undefined !== texData.image ) {\r\n\r\n				texture.image = texData.image;\r\n\r\n			} else if ( undefined !== texData.data ) {\r\n\r\n				texture.image.width = texData.width;\r\n				texture.image.height = texData.height;\r\n				texture.image.data = texData.data;\r\n\r\n			}\r\n\r\n			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n			if ( undefined !== texData.format ) {\r\n\r\n				texture.format = texData.format;\r\n\r\n			}\r\n			if ( undefined !== texData.type ) {\r\n\r\n				texture.type = texData.type;\r\n\r\n			}\r\n\r\n			if ( undefined !== texData.mipmaps ) {\r\n\r\n				texture.mipmaps = texData.mipmaps;\r\n\r\n			}\r\n\r\n			if ( 1 === texData.mipmapCount ) {\r\n\r\n				texture.minFilter = THREE.LinearFilter;\r\n\r\n			}\r\n\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad ) onLoad( texture, texData );\r\n\r\n		}, onProgress, onError );\r\n\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n	// override in sub classes\r\n	this._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n	constructor: THREE.CompressedTextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var images = [];\r\n\r\n		var texture = new THREE.CompressedTexture();\r\n		texture.image = images;\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.setResponseType( 'arraybuffer' );\r\n\r\n		if ( Array.isArray( url ) ) {\r\n\r\n			var loaded = 0;\r\n\r\n			var loadTexture = function ( i ) {\r\n\r\n				loader.load( url[ i ], function ( buffer ) {\r\n\r\n					var texDatas = scope._parser( buffer, true );\r\n\r\n					images[ i ] = {\r\n						width: texDatas.width,\r\n						height: texDatas.height,\r\n						format: texDatas.format,\r\n						mipmaps: texDatas.mipmaps\r\n					};\r\n\r\n					loaded += 1;\r\n\r\n					if ( loaded === 6 ) {\r\n\r\n						if ( texDatas.mipmapCount === 1 )\r\n 							texture.minFilter = THREE.LinearFilter;\r\n\r\n						texture.format = texDatas.format;\r\n						texture.needsUpdate = true;\r\n\r\n						if ( onLoad ) onLoad( texture );\r\n\r\n					}\r\n\r\n				}, onProgress, onError );\r\n\r\n			};\r\n\r\n			for ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n				loadTexture( i );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// compressed cubemap texture stored in a single DDS file\r\n\r\n			loader.load( url, function ( buffer ) {\r\n\r\n				var texDatas = scope._parser( buffer, true );\r\n\r\n				if ( texDatas.isCubemap ) {\r\n\r\n					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n					for ( var f = 0; f < faces; f ++ ) {\r\n\r\n						images[ f ] = { mipmaps : [] };\r\n\r\n						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n							images[ f ].format = texDatas.format;\r\n							images[ f ].width = texDatas.width;\r\n							images[ f ].height = texDatas.height;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					texture.image.width = texDatas.width;\r\n					texture.image.height = texDatas.height;\r\n					texture.mipmaps = texDatas.mipmaps;\r\n\r\n				}\r\n\r\n				if ( texDatas.mipmapCount === 1 ) {\r\n\r\n					texture.minFilter = THREE.LinearFilter;\r\n\r\n				}\r\n\r\n				texture.format = texDatas.format;\r\n				texture.needsUpdate = true;\r\n\r\n				if ( onLoad ) onLoad( texture );\r\n\r\n			}, onProgress, onError );\r\n\r\n		}\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Material';\r\n\r\n	this.side = THREE.FrontSide;\r\n\r\n	this.opacity = 1;\r\n	this.transparent = false;\r\n\r\n	this.blending = THREE.NormalBlending;\r\n\r\n	this.blendSrc = THREE.SrcAlphaFactor;\r\n	this.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n	this.blendEquation = THREE.AddEquation;\r\n	this.blendSrcAlpha = null;\r\n	this.blendDstAlpha = null;\r\n	this.blendEquationAlpha = null;\r\n\r\n	this.depthFunc = THREE.LessEqualDepth;\r\n	this.depthTest = true;\r\n	this.depthWrite = true;\r\n\r\n	this.colorWrite = true;\r\n\r\n	this.precision = null; // override the renderer's default precision for this material\r\n\r\n	this.polygonOffset = false;\r\n	this.polygonOffsetFactor = 0;\r\n	this.polygonOffsetUnits = 0;\r\n\r\n	this.alphaTest = 0;\r\n\r\n	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n	this.visible = true;\r\n\r\n	this._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n	constructor: THREE.Material,\r\n\r\n	get needsUpdate () {\r\n\r\n		return this._needsUpdate;\r\n\r\n	},\r\n\r\n	set needsUpdate ( value ) {\r\n\r\n		if ( value === true ) this.update();\r\n\r\n		this._needsUpdate = value;\r\n\r\n	},\r\n\r\n	setValues: function ( values ) {\r\n\r\n		if ( values === undefined ) return;\r\n\r\n		for ( var key in values ) {\r\n\r\n			var newValue = values[ key ];\r\n\r\n			if ( newValue === undefined ) {\r\n\r\n				console.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n				continue;\r\n\r\n			}\r\n\r\n			var currentValue = this[ key ];\r\n\r\n			if ( currentValue === undefined ) {\r\n\r\n				console.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n				continue;\r\n\r\n			}\r\n\r\n			if ( currentValue instanceof THREE.Color ) {\r\n\r\n				currentValue.set( newValue );\r\n\r\n			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n				currentValue.copy( newValue );\r\n\r\n			} else if ( key === 'overdraw' ) {\r\n\r\n				// ensure overdraw is backwards-compatible with legacy boolean type\r\n				this[ key ] = Number( newValue );\r\n\r\n			} else {\r\n\r\n				this[ key ] = newValue;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		var data = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'Material',\r\n				generator: 'Material.toJSON'\r\n			}\r\n		};\r\n\r\n		// standard Material serialization\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n		if ( this.name !== '' ) data.name = this.name;\r\n\r\n		if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n		if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n		if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n		if ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\r\n		if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n		if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n		if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n		if ( this.bumpMap instanceof THREE.Texture ) {\r\n\r\n			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n			data.bumpScale = this.bumpScale;\r\n\r\n		}\r\n		if ( this.normalMap instanceof THREE.Texture ) {\r\n\r\n			data.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n			data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js\r\n\r\n		}\r\n		if ( this.displacementMap instanceof THREE.Texture ) {\r\n\r\n			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n			data.displacementScale = this.displacementScale;\r\n			data.displacementBias = this.displacementBias;\r\n\r\n		}\r\n		if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n		if ( this.envMap instanceof THREE.Texture ) {\r\n\r\n			data.envMap = this.envMap.toJSON( meta ).uuid;\r\n			data.reflectivity = this.reflectivity; // Scale behind envMap\r\n\r\n		}\r\n\r\n		if ( this.size !== undefined ) data.size = this.size;\r\n		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\r\n		if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n		if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n		if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n		if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;\r\n\r\n		if ( this.opacity < 1 ) data.opacity = this.opacity;\r\n		if ( this.transparent === true ) data.transparent = this.transparent;\r\n		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n		if ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.name = source.name;\r\n\r\n		this.side = source.side;\r\n\r\n		this.opacity = source.opacity;\r\n		this.transparent = source.transparent;\r\n\r\n		this.blending = source.blending;\r\n\r\n		this.blendSrc = source.blendSrc;\r\n		this.blendDst = source.blendDst;\r\n		this.blendEquation = source.blendEquation;\r\n		this.blendSrcAlpha = source.blendSrcAlpha;\r\n		this.blendDstAlpha = source.blendDstAlpha;\r\n		this.blendEquationAlpha = source.blendEquationAlpha;\r\n\r\n		this.depthFunc = source.depthFunc;\r\n		this.depthTest = source.depthTest;\r\n		this.depthWrite = source.depthWrite;\r\n\r\n		this.precision = source.precision;\r\n\r\n		this.polygonOffset = source.polygonOffset;\r\n		this.polygonOffsetFactor = source.polygonOffsetFactor;\r\n		this.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\r\n		this.alphaTest = source.alphaTest;\r\n\r\n		this.overdraw = source.overdraw;\r\n\r\n		this.visible = source.visible;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	update: function () {\r\n\r\n		this.dispatchEvent( { type: 'update' } );\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	},\r\n\r\n	// Deprecated\r\n\r\n	get wrapAround () {\r\n\r\n		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\r\n	},\r\n\r\n	set wrapAround ( boolean ) {\r\n\r\n		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\r\n	},\r\n\r\n	get wrapRGB () {\r\n\r\n		console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n		return new THREE.Color();\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'LineBasicMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.linewidth = 1;\r\n	this.linecap = 'round';\r\n	this.linejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.linewidth = source.linewidth;\r\n	this.linecap = source.linecap;\r\n	this.linejoin = source.linejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'LineDashedMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.linewidth = 1;\r\n\r\n	this.scale = 1;\r\n	this.dashSize = 3;\r\n	this.gapSize = 1;\r\n\r\n	this.vertexColors = false;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	\r\n	this.linewidth = source.linewidth;\r\n\r\n	this.scale = source.scale;\r\n	this.dashSize = source.dashSize;\r\n	this.gapSize = source.gapSize;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshBasicMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n	this.map = null;\r\n\r\n	this.aoMap = null;\r\n	this.aoMapIntensity = 1.0;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n	\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.map = source.map;\r\n\r\n	this.aoMap = source.aoMap;\r\n	this.aoMapIntensity = source.aoMapIntensity;\r\n\r\n	this.specularMap = source.specularMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.combine = source.combine;\r\n	this.reflectivity = source.reflectivity;\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n	\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshLambertMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n\r\n	this.map = null;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.emissive.copy( source.emissive );\r\n\r\n	this.map = source.map;\r\n\r\n	this.specularMap = source.specularMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.combine = source.combine;\r\n	this.reflectivity = source.reflectivity;\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshPhongMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n	this.specular = new THREE.Color( 0x111111 );\r\n	this.shininess = 30;\r\n\r\n	this.metal = false;\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n	this.lightMapIntensity = 1.0;\r\n\r\n	this.aoMap = null;\r\n	this.aoMapIntensity = 1.0;\r\n\r\n	this.emissiveMap = null;\r\n\r\n	this.bumpMap = null;\r\n	this.bumpScale = 1;\r\n\r\n	this.normalMap = null;\r\n	this.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n	this.displacementMap = null;\r\n	this.displacementScale = 1;\r\n	this.displacementBias = 0;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.emissive.copy( source.emissive );\r\n	this.specular.copy( source.specular );\r\n	this.shininess = source.shininess;\r\n\r\n	this.metal = source.metal;\r\n\r\n	this.map = source.map;\r\n\r\n	this.lightMap = source.lightMap;\r\n	this.lightMapIntensity = source.lightMapIntensity;\r\n\r\n	this.aoMap = source.aoMap;\r\n	this.aoMapIntensity = source.aoMapIntensity;\r\n\r\n	this.emissiveMap = source.emissiveMap;\r\n\r\n	this.bumpMap = source.bumpMap;\r\n	this.bumpScale = source.bumpScale;\r\n\r\n	this.normalMap = source.normalMap;\r\n	this.normalScale.copy( source.normalScale );\r\n\r\n	this.displacementMap = source.displacementMap;\r\n	this.displacementScale = source.displacementScale;\r\n	this.displacementBias = source.displacementBias;\r\n\r\n	this.specularMap = source.specularMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.combine = source.combine;\r\n	this.reflectivity = source.reflectivity;\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshDepthMaterial';\r\n\r\n	this.morphTargets = false;\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this, parameters );\r\n\r\n	this.type = 'MeshNormalMaterial';\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.morphTargets = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MultiMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MultiMaterial = function ( materials ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.type = 'MultiMaterial';\r\n\r\n	this.materials = materials instanceof Array ? materials : [];\r\n\r\n	this.visible = true;\r\n\r\n};\r\n\r\nTHREE.MultiMaterial.prototype = {\r\n\r\n	constructor: THREE.MultiMaterial,\r\n\r\n	toJSON: function () {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.2,\r\n				type: 'material',\r\n				generator: 'MaterialExporter'\r\n			},\r\n			uuid: this.uuid,\r\n			type: this.type,\r\n			materials: []\r\n		};\r\n\r\n		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {\r\n\r\n			output.materials.push( this.materials[ i ].toJSON() );\r\n\r\n		}\r\n\r\n		output.visible = this.visible;\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		var material = new this.constructor();\r\n\r\n		for ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n			material.materials.push( this.materials[ i ].clone() );\r\n\r\n		}\r\n\r\n		material.visible = this.visible;\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.MeshFaceMaterial = THREE.MultiMaterial;\r\n\r\n// File:src/materials/PointsMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointsMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'PointsMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.map = null;\r\n\r\n	this.size = 1;\r\n	this.sizeAttenuation = true;\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\r\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.map = source.map;\r\n\r\n	this.size = source.size;\r\n	this.sizeAttenuation = source.sizeAttenuation;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.PointCloudMaterial = function ( parameters ) {\r\n\r\n	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n	return new THREE.PointsMaterial( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\r\n	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n	return new THREE.PointsMaterial( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\r\n	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n	return new THREE.PointsMaterial( parameters );\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'ShaderMaterial';\r\n\r\n	this.defines = {};\r\n	this.uniforms = {};\r\n\r\n	this.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n	this.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.linewidth = 1;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.fog = false; // set to use scene fog\r\n\r\n	this.lights = false; // set to use scene lights\r\n\r\n	this.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n	this.skinning = false; // set to use skinning attribute streams\r\n\r\n	this.morphTargets = false; // set to use morph targets\r\n	this.morphNormals = false; // set to use morph normals\r\n\r\n	this.derivatives = false; // set to use derivatives\r\n\r\n	// When rendered geometry doesn't include these attributes but the material does,\r\n	// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n	this.defaultAttributeValues = {\r\n		'color': [ 1, 1, 1 ],\r\n		'uv': [ 0, 0 ],\r\n		'uv2': [ 0, 0 ]\r\n	};\r\n\r\n	this.index0AttributeName = undefined;\r\n\r\n	if ( parameters !== undefined ) {\r\n\r\n		if ( parameters.attributes !== undefined ) {\r\n\r\n			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\r\n		}\r\n\r\n		this.setValues( parameters );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.fragmentShader = source.fragmentShader;\r\n	this.vertexShader = source.vertexShader;\r\n\r\n	this.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\r\n	this.attributes = source.attributes;\r\n	this.defines = source.defines;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.lights = source.lights;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	this.derivatives = source.derivatives;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\r\n	data.uniforms = this.uniforms;\r\n	data.attributes = this.attributes;\r\n	data.vertexShader = this.vertexShader;\r\n	data.fragmentShader = this.fragmentShader;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n	THREE.ShaderMaterial.call( this, parameters );\r\n\r\n	this.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *	uvOffset: new THREE.Vector2(),\r\n *	uvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'SpriteMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n	this.map = null;\r\n\r\n	this.rotation = 0;\r\n\r\n	this.fog = false;\r\n\r\n	// set parameters\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.map = source.map;\r\n\r\n	this.rotation = source.rotation;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.sourceFile = '';\r\n\r\n	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n	this.mipmaps = [];\r\n\r\n	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n	this.format = format !== undefined ? format : THREE.RGBAFormat;\r\n	this.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n	this.offset = new THREE.Vector2( 0, 0 );\r\n	this.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n	this.generateMipmaps = true;\r\n	this.premultiplyAlpha = false;\r\n	this.flipY = true;\r\n	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n	this.version = 0;\r\n	this.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n	constructor: THREE.Texture,\r\n\r\n	set needsUpdate ( value ) {\r\n\r\n		if ( value === true ) this.version ++;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.image = source.image;\r\n		this.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n		this.mapping = source.mapping;\r\n\r\n		this.wrapS = source.wrapS;\r\n		this.wrapT = source.wrapT;\r\n\r\n		this.magFilter = source.magFilter;\r\n		this.minFilter = source.minFilter;\r\n\r\n		this.anisotropy = source.anisotropy;\r\n\r\n		this.format = source.format;\r\n		this.type = source.type;\r\n\r\n		this.offset.copy( source.offset );\r\n		this.repeat.copy( source.repeat );\r\n\r\n		this.generateMipmaps = source.generateMipmaps;\r\n		this.premultiplyAlpha = source.premultiplyAlpha;\r\n		this.flipY = source.flipY;\r\n		this.unpackAlignment = source.unpackAlignment;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		if ( meta.textures[ this.uuid ] !== undefined ) {\r\n\r\n			return meta.textures[ this.uuid ];\r\n\r\n		}\r\n\r\n		function getDataURL( image ) {\r\n\r\n			var canvas;\r\n\r\n			if ( image.toDataURL !== undefined ) {\r\n\r\n				canvas = image;\r\n\r\n			} else {\r\n\r\n				canvas = document.createElement( 'canvas' );\r\n				canvas.width = image.width;\r\n				canvas.height = image.height;\r\n\r\n				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\r\n			}\r\n\r\n			if ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\r\n				return canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\r\n			} else {\r\n\r\n				return canvas.toDataURL( 'image/png' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'Texture',\r\n				generator: 'Texture.toJSON'\r\n			},\r\n\r\n			uuid: this.uuid,\r\n			name: this.name,\r\n\r\n			mapping: this.mapping,\r\n\r\n			repeat: [ this.repeat.x, this.repeat.y ],\r\n			offset: [ this.offset.x, this.offset.y ],\r\n			wrap: [ this.wrapS, this.wrapT ],\r\n\r\n			minFilter: this.minFilter,\r\n			magFilter: this.magFilter,\r\n			anisotropy: this.anisotropy\r\n		};\r\n\r\n		if ( this.image !== undefined ) {\r\n\r\n			// TODO: Move to THREE.Image\r\n\r\n			var image = this.image;\r\n\r\n			if ( image.uuid === undefined ) {\r\n\r\n				image.uuid = THREE.Math.generateUUID(); // UGH\r\n\r\n			}\r\n\r\n			if ( meta.images[ image.uuid ] === undefined ) {\r\n\r\n				meta.images[ image.uuid ] = {\r\n					uuid: image.uuid,\r\n					url: getDataURL( image )\r\n				};\r\n\r\n			}\r\n\r\n			output.image = image.uuid;\r\n\r\n		}\r\n\r\n		meta.textures[ this.uuid ] = output;\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	},\r\n\r\n	transformUv: function ( uv ) {\r\n\r\n		if ( this.mapping !== THREE.UVMapping )  return;\r\n\r\n		uv.multiply( this.repeat );\r\n		uv.add( this.offset );\r\n\r\n		if ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n			switch ( this.wrapS ) {\r\n\r\n				case THREE.RepeatWrapping:\r\n\r\n					uv.x = uv.x - Math.floor( uv.x );\r\n					break;\r\n\r\n				case THREE.ClampToEdgeWrapping:\r\n\r\n					uv.x = uv.x < 0 ? 0 : 1;\r\n					break;\r\n\r\n				case THREE.MirroredRepeatWrapping:\r\n\r\n					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n						uv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n					} else {\r\n\r\n						uv.x = uv.x - Math.floor( uv.x );\r\n\r\n					}\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n			switch ( this.wrapT ) {\r\n\r\n				case THREE.RepeatWrapping:\r\n\r\n					uv.y = uv.y - Math.floor( uv.y );\r\n					break;\r\n\r\n				case THREE.ClampToEdgeWrapping:\r\n\r\n					uv.y = uv.y < 0 ? 0 : 1;\r\n					break;\r\n\r\n				case THREE.MirroredRepeatWrapping:\r\n\r\n					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n						uv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n					} else {\r\n\r\n						uv.y = uv.y - Math.floor( uv.y );\r\n\r\n					}\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( this.flipY ) {\r\n\r\n			uv.y = 1 - uv.y;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/CanvasTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\r\n	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.images = images;\r\n	this.flipY = false;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nTHREE.CubeTexture.prototype.copy = function ( source ) {\r\n\r\n	THREE.Texture.prototype.copy.call( this, source );\r\n	\r\n	this.images = source.images;\r\n	\r\n	return this;\r\n\r\n};\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.image = { width: width, height: height };\r\n	this.mipmaps = mipmaps;\r\n\r\n	// no flipping for cube textures\r\n	// (also flipping doesn't work for compressed textures )\r\n\r\n	this.flipY = false;\r\n\r\n	// can't generate mipmaps for compressed textures\r\n	// mips must be embedded in DDS files\r\n\r\n	this.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.image = { data: data, width: width, height: height };\r\n\r\n	this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n	this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n	\r\n	this.flipY = false;\r\n	this.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.generateMipmaps = false;\r\n\r\n	var scope = this;\r\n\r\n	var update = function () {\r\n\r\n		requestAnimationFrame( update );\r\n\r\n		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\r\n			scope.needsUpdate = true;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	update();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n// File:src/objects/Points.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Points = function ( geometry, material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Points';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Points.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Points.prototype.constructor = THREE.Points;\r\n\r\nTHREE.Points.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		var object = this;\r\n		var geometry = object.geometry;\r\n		var threshold = raycaster.params.Points.threshold;\r\n\r\n		inverseMatrix.getInverse( this.matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n				return;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n		var localThresholdSq = localThreshold * localThreshold;\r\n		var position = new THREE.Vector3();\r\n\r\n		function testPoint( point, index ) {\r\n\r\n			var rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\r\n			if ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n				var intersectPoint = ray.closestPointToPoint( point );\r\n				intersectPoint.applyMatrix4( object.matrixWorld );\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n				if ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					distanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n					point: intersectPoint.clone(),\r\n					index: index,\r\n					face: null,\r\n					object: object\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var index = geometry.index;\r\n			var attributes = geometry.attributes;\r\n			var positions = attributes.position.array;\r\n\r\n			if ( index !== null ) {\r\n\r\n				var indices = index.array;\r\n\r\n				for ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\r\n					var a = indices[ i ];\r\n\r\n					position.fromArray( positions, a * 3 );\r\n\r\n					testPoint( position, a );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\r\n					position.fromArray( positions, i * 3 );\r\n\r\n					testPoint( position, i );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			var vertices = geometry.vertices;\r\n\r\n			for ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n				testPoint( vertices[ i ], i );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Points.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\nTHREE.Points.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	// only serialize if not in meta geometries cache\r\n	if ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n		meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();\r\n\r\n	}\r\n\r\n	// only serialize if not in meta materials cache\r\n	if ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n		meta.materials[ this.material.uuid ] = this.material.toJSON();\r\n\r\n	}\r\n\r\n	data.object.geometry = this.geometry.uuid;\r\n	data.object.material = this.material.uuid;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.PointCloud = function ( geometry, material ) {\r\n\r\n	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n	return new THREE.Points( geometry, material );\r\n\r\n};\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n	return new THREE.Points( geometry, material );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n	if ( mode === 1 ) {\r\n\r\n		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n		return new THREE.LineSegments( geometry, material );\r\n\r\n	}\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Line';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		var precision = raycaster.linePrecision;\r\n		var precisionSq = precision * precision;\r\n\r\n		var geometry = this.geometry;\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( this.matrixWorld );\r\n\r\n		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		inverseMatrix.getInverse( this.matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		var vStart = new THREE.Vector3();\r\n		var vEnd = new THREE.Vector3();\r\n		var interSegment = new THREE.Vector3();\r\n		var interRay = new THREE.Vector3();\r\n		var step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var index = geometry.index;\r\n			var attributes = geometry.attributes;\r\n\r\n			if ( index !== null ) {\r\n\r\n				var indices = index.array;\r\n				var positions = attributes.position.array;\r\n\r\n				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\r\n					var a = indices[ i ];\r\n					var b = indices[ i + 1 ];\r\n\r\n					vStart.fromArray( positions, a * 3 );\r\n					vEnd.fromArray( positions, b * 3 );\r\n\r\n					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n					if ( distSq > precisionSq ) continue;\r\n\r\n					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						// What do we want? intersection point on the ray or on the segment??\r\n						// point: raycaster.ray.at( distance ),\r\n						point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n						index: i,\r\n						face: null,\r\n						faceIndex: null,\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				var positions = attributes.position.array;\r\n\r\n				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\r\n					vStart.fromArray( positions, 3 * i );\r\n					vEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n					if ( distSq > precisionSq ) continue;\r\n\r\n					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						// What do we want? intersection point on the ray or on the segment??\r\n						// point: raycaster.ray.at( distance ),\r\n						point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n						index: i,\r\n						face: null,\r\n						faceIndex: null,\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			var vertices = geometry.vertices;\r\n			var nbVertices = vertices.length;\r\n\r\n			for ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n				if ( distSq > precisionSq ) continue;\r\n\r\n				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n				if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					// What do we want? intersection point on the ray or on the segment??\r\n					// point: raycaster.ray.at( distance ),\r\n					point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n					index: i,\r\n					face: null,\r\n					faceIndex: null,\r\n					object: this\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\nTHREE.Line.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	// only serialize if not in meta geometries cache\r\n	if ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n		meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();\r\n\r\n	}\r\n\r\n	// only serialize if not in meta materials cache\r\n	if ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n		meta.materials[ this.material.uuid ] = this.material.toJSON();\r\n\r\n	}\r\n\r\n	data.object.geometry = this.geometry.uuid;\r\n	data.object.material = this.material.uuid;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// DEPRECATED\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\n// File:src/objects/LineSegments.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LineSegments = function ( geometry, material ) {\r\n\r\n	THREE.Line.call( this, geometry, material );\r\n\r\n	this.type = 'LineSegments';\r\n\r\n};\r\n\r\nTHREE.LineSegments.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.LineSegments.prototype.constructor = THREE.LineSegments;\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Mesh';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n	this.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n		this.morphTargetBase = - 1;\r\n		this.morphTargetInfluences = [];\r\n		this.morphTargetDictionary = {};\r\n\r\n		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n			this.morphTargetInfluences.push( 0 );\r\n			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n	if ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n		return this.morphTargetDictionary[ name ];\r\n\r\n	}\r\n\r\n	console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n	return 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	var vA = new THREE.Vector3();\r\n	var vB = new THREE.Vector3();\r\n	var vC = new THREE.Vector3();\r\n\r\n	var tempA = new THREE.Vector3();\r\n	var tempB = new THREE.Vector3();\r\n	var tempC = new THREE.Vector3();\r\n\r\n	var uvA = new THREE.Vector2();\r\n	var uvB = new THREE.Vector2();\r\n	var uvC = new THREE.Vector2();\r\n\r\n	var barycoord = new THREE.Vector3();\r\n\r\n	var intersectionPoint = new THREE.Vector3();\r\n	var intersectionPointWorld = new THREE.Vector3();\r\n\r\n	function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\r\n		THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\r\n		uv1.multiplyScalar( barycoord.x );\r\n		uv2.multiplyScalar( barycoord.y );\r\n		uv3.multiplyScalar( barycoord.z );\r\n\r\n		uv1.add( uv2 ).add( uv3 );\r\n\r\n		return uv1.clone();\r\n\r\n	}\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		var geometry = this.geometry;\r\n		var material = this.material;\r\n\r\n		if ( material === undefined ) return;\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( this.matrixWorld );\r\n\r\n		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		// Check boundingBox before continuing\r\n\r\n		inverseMatrix.getInverse( this.matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n				return;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var a, b, c;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var index = geometry.index;\r\n			var attributes = geometry.attributes;\r\n\r\n			if ( index !== null ) {\r\n\r\n				var indices = index.array;\r\n				var positions = attributes.position.array;\r\n\r\n				for ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n					a = indices[ i ];\r\n					b = indices[ i + 1 ];\r\n					c = indices[ i + 2 ];\r\n\r\n					vA.fromArray( positions, a * 3 );\r\n					vB.fromArray( positions, b * 3 );\r\n					vC.fromArray( positions, c * 3 );\r\n\r\n					if ( material.side === THREE.BackSide ) {\r\n\r\n						if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;\r\n\r\n					} else {\r\n\r\n						if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;\r\n\r\n					}\r\n\r\n					intersectionPointWorld.copy( intersectionPoint );\r\n					intersectionPointWorld.applyMatrix4( this.matrixWorld );\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					var uv;\r\n\r\n					if ( attributes.uv !== undefined ) {\r\n\r\n						var uvs = attributes.uv.array;\r\n						uvA.fromArray( uvs, a * 2 );\r\n						uvB.fromArray( uvs, b * 2 );\r\n						uvC.fromArray( uvs, c * 2 );\r\n						uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\r\n\r\n					}\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						point: intersectionPointWorld.clone(),\r\n						uv: uv,\r\n						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n						faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				var positions = attributes.position.array;\r\n\r\n				for ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\r\n					vA.fromArray( positions, i );\r\n					vB.fromArray( positions, i + 3 );\r\n					vC.fromArray( positions, i + 6 );\r\n\r\n					if ( material.side === THREE.BackSide ) {\r\n\r\n						if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;\r\n\r\n					} else {\r\n\r\n						if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;\r\n\r\n					}\r\n\r\n					intersectionPointWorld.copy( intersectionPoint );\r\n					intersectionPointWorld.applyMatrix4( this.matrixWorld );\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					var uv;\r\n\r\n					if ( attributes.uv !== undefined ) {\r\n\r\n						var uvs = attributes.uv.array;\r\n						uvA.fromArray( uvs, i );\r\n						uvB.fromArray( uvs, i + 2 );\r\n						uvC.fromArray( uvs, i + 4 );\r\n						uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\r\n\r\n					}\r\n\r\n					a = i / 3;\r\n					b = a + 1;\r\n					c = a + 2;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						point: intersectionPointWorld.clone(),\r\n						uv: uv,\r\n						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n						index: a, // triangle number in positions buffer semantics\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\r\n			var materials = isFaceMaterial === true ? material.materials : null;\r\n\r\n			var vertices = geometry.vertices;\r\n			var faces = geometry.faces;\r\n\r\n			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n				var face = faces[ f ];\r\n				var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\r\n				if ( faceMaterial === undefined ) continue;\r\n\r\n				a = vertices[ face.a ];\r\n				b = vertices[ face.b ];\r\n				c = vertices[ face.c ];\r\n\r\n				if ( faceMaterial.morphTargets === true ) {\r\n\r\n					var morphTargets = geometry.morphTargets;\r\n					var morphInfluences = this.morphTargetInfluences;\r\n\r\n					vA.set( 0, 0, 0 );\r\n					vB.set( 0, 0, 0 );\r\n					vC.set( 0, 0, 0 );\r\n\r\n					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n						var influence = morphInfluences[ t ];\r\n\r\n						if ( influence === 0 ) continue;\r\n\r\n						var targets = morphTargets[ t ].vertices;\r\n\r\n						vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );\r\n						vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );\r\n						vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );\r\n\r\n					}\r\n\r\n					vA.add( a );\r\n					vB.add( b );\r\n					vC.add( c );\r\n\r\n					a = vA;\r\n					b = vB;\r\n					c = vC;\r\n\r\n				}\r\n\r\n				if ( faceMaterial.side === THREE.BackSide ) {\r\n\r\n					if ( ray.intersectTriangle( c, b, a, true, intersectionPoint ) === null ) continue;\r\n\r\n				} else {\r\n\r\n					if ( ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;\r\n\r\n				}\r\n\r\n				intersectionPointWorld.copy( intersectionPoint );\r\n				intersectionPointWorld.applyMatrix4( this.matrixWorld );\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n				if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n				var uv;\r\n\r\n				if ( geometry.faceVertexUvs[ 0 ].length > 0 ) {\r\n\r\n					var uvs = geometry.faceVertexUvs[ 0 ][ f ];\r\n					uvA.copy( uvs[ 0 ] );\r\n					uvB.copy( uvs[ 1 ] );\r\n					uvC.copy( uvs[ 2 ] );\r\n					uv = uvIntersection( intersectionPoint, a, b, c, uvA, uvB, uvC );\r\n\r\n				}\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					point: intersectionPointWorld.clone(),\r\n					uv: uv,\r\n					face: face,\r\n					faceIndex: f,\r\n					object: this\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	// only serialize if not in meta geometries cache\r\n	if ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n		meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\r\n	}\r\n\r\n	// only serialize if not in meta materials cache\r\n	if ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n		meta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\r\n	}\r\n\r\n	data.object.geometry = this.geometry.uuid;\r\n	data.object.material = this.material.uuid;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Bone';\r\n\r\n	this.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\nTHREE.Bone.prototype.copy = function ( source ) {\r\n	\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n	\r\n	this.skin = source.skin;\r\n	\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n	this.identityMatrix = new THREE.Matrix4();\r\n\r\n	// copy the bone array\r\n\r\n	bones = bones || [];\r\n\r\n	this.bones = bones.slice( 0 );\r\n\r\n	// create a bone texture or an array of floats\r\n\r\n	if ( this.useVertexTexture ) {\r\n\r\n		// layout (1 matrix = 4 pixels)\r\n		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n		\r\n		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n		size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n		size = Math.max( size, 4 );\r\n\r\n		this.boneTextureWidth = size;\r\n		this.boneTextureHeight = size;\r\n\r\n		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\r\n	} else {\r\n\r\n		this.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n	}\r\n\r\n	// use the supplied bone inverses or calculate the inverses\r\n\r\n	if ( boneInverses === undefined ) {\r\n\r\n		this.calculateInverses();\r\n\r\n	} else {\r\n\r\n		if ( this.bones.length === boneInverses.length ) {\r\n\r\n			this.boneInverses = boneInverses.slice( 0 );\r\n\r\n		} else {\r\n\r\n			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n			this.boneInverses = [];\r\n\r\n			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n				this.boneInverses.push( new THREE.Matrix4() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n	this.boneInverses = [];\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		var inverse = new THREE.Matrix4();\r\n\r\n		if ( this.bones[ b ] ) {\r\n\r\n			inverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n		}\r\n\r\n		this.boneInverses.push( inverse );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n	var bone;\r\n\r\n	// recover the bind-time world matrices\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		bone = this.bones[ b ];\r\n\r\n		if ( bone ) {\r\n\r\n			bone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// compute the local matrices, positions, rotations and scales\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		bone = this.bones[ b ];\r\n\r\n		if ( bone ) {\r\n\r\n			if ( bone.parent ) {\r\n\r\n				bone.matrix.getInverse( bone.parent.matrixWorld );\r\n				bone.matrix.multiply( bone.matrixWorld );\r\n\r\n			} else {\r\n\r\n				bone.matrix.copy( bone.matrixWorld );\r\n\r\n			}\r\n\r\n			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n	var offsetMatrix = new THREE.Matrix4();\r\n\r\n	return function update() {\r\n\r\n		// flatten bone matrices to array\r\n\r\n		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n			// compute the offset between the current and the original transform\r\n\r\n			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n		}\r\n\r\n		if ( this.useVertexTexture ) {\r\n\r\n			this.boneTexture.needsUpdate = true;\r\n\r\n		}\r\n\r\n	};\r\n\r\n} )();\r\n\r\nTHREE.Skeleton.prototype.clone = function () {\r\n\r\n	return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\r\n};\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.type = 'SkinnedMesh';\r\n\r\n	this.bindMode = \"attached\";\r\n	this.bindMatrix = new THREE.Matrix4();\r\n	this.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n	// init bones\r\n\r\n	// TODO: remove bone creation as there is no reason (other than\r\n	// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n	var bones = [];\r\n\r\n	if ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n		var bone, gbone;\r\n\r\n		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n			gbone = this.geometry.bones[ b ];\r\n\r\n			bone = new THREE.Bone( this );\r\n			bones.push( bone );\r\n\r\n			bone.name = gbone.name;\r\n			bone.position.fromArray( gbone.pos );\r\n			bone.quaternion.fromArray( gbone.rotq );\r\n			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\r\n		}\r\n\r\n		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n			gbone = this.geometry.bones[ b ];\r\n\r\n			if ( gbone.parent !== - 1 ) {\r\n\r\n				bones[ gbone.parent ].add( bones[ b ] );\r\n\r\n			} else {\r\n\r\n				this.add( bones[ b ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.normalizeSkinWeights();\r\n\r\n	this.updateMatrixWorld( true );\r\n	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n	this.skeleton = skeleton;\r\n\r\n	if ( bindMatrix === undefined ) {\r\n\r\n		this.updateMatrixWorld( true );\r\n		\r\n		this.skeleton.calculateInverses();\r\n\r\n		bindMatrix = this.matrixWorld;\r\n\r\n	}\r\n\r\n	this.bindMatrix.copy( bindMatrix );\r\n	this.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n	this.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n	if ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n			var sw = this.geometry.skinWeights[ i ];\r\n\r\n			var scale = 1.0 / sw.lengthManhattan();\r\n\r\n			if ( scale !== Infinity ) {\r\n\r\n				sw.multiplyScalar( scale );\r\n\r\n			} else {\r\n\r\n				sw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n			}\r\n\r\n		}\r\n\r\n	} else {\r\n\r\n		// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n	if ( this.bindMode === \"attached\" ) {\r\n\r\n		this.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n	} else if ( this.bindMode === \"detached\" ) {\r\n\r\n		this.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n	} else {\r\n\r\n		console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function() {\r\n\r\n	return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/MorphAnimMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.type = 'MorphAnimMesh';\r\n\r\n	// API\r\n\r\n	this.duration = 1000; // milliseconds\r\n	this.mirroredLoop = false;\r\n	this.time = 0;\r\n\r\n	// internals\r\n\r\n	this.lastKeyframe = 0;\r\n	this.currentKeyframe = 0;\r\n\r\n	this.direction = 1;\r\n	this.directionBackwards = false;\r\n\r\n	this.setFrameRange( 0, geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n	this.startKeyframe = start;\r\n	this.endKeyframe = end;\r\n\r\n	this.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n	this.direction = 1;\r\n	this.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n	this.direction = - 1;\r\n	this.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n	var geometry = this.geometry;\r\n\r\n	if ( ! geometry.animations ) geometry.animations = {};\r\n\r\n	var firstAnimation, animations = geometry.animations;\r\n\r\n	var pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n		var morph = geometry.morphTargets[ i ];\r\n		var parts = morph.name.match( pattern );\r\n\r\n		if ( parts && parts.length > 1 ) {\r\n\r\n			var label = parts[ 1 ];\r\n\r\n			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };\r\n\r\n			var animation = animations[ label ];\r\n\r\n			if ( i < animation.start ) animation.start = i;\r\n			if ( i > animation.end ) animation.end = i;\r\n\r\n			if ( ! firstAnimation ) firstAnimation = label;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n	if ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n	this.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n	var animation = this.geometry.animations[ label ];\r\n\r\n	if ( animation ) {\r\n\r\n		this.setFrameRange( animation.start, animation.end );\r\n		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n		this.time = 0;\r\n\r\n	} else {\r\n\r\n		console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n	var frameTime = this.duration / this.length;\r\n\r\n	this.time += this.direction * delta;\r\n\r\n	if ( this.mirroredLoop ) {\r\n\r\n		if ( this.time > this.duration || this.time < 0 ) {\r\n\r\n			this.direction *= - 1;\r\n\r\n			if ( this.time > this.duration ) {\r\n\r\n				this.time = this.duration;\r\n				this.directionBackwards = true;\r\n\r\n			}\r\n\r\n			if ( this.time < 0 ) {\r\n\r\n				this.time = 0;\r\n				this.directionBackwards = false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	} else {\r\n\r\n		this.time = this.time % this.duration;\r\n\r\n		if ( this.time < 0 ) this.time += this.duration;\r\n\r\n	}\r\n\r\n	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n	var influences = this.morphTargetInfluences;\r\n\r\n	if ( keyframe !== this.currentKeyframe ) {\r\n\r\n		influences[ this.lastKeyframe ] = 0;\r\n		influences[ this.currentKeyframe ] = 1;\r\n		influences[ keyframe ] = 0;\r\n\r\n		this.lastKeyframe = this.currentKeyframe;\r\n		this.currentKeyframe = keyframe;\r\n\r\n	}\r\n\r\n	var mix = ( this.time % frameTime ) / frameTime;\r\n\r\n	if ( this.directionBackwards ) {\r\n\r\n		mix = 1 - mix;\r\n\r\n	}\r\n\r\n	influences[ this.currentKeyframe ] = mix;\r\n	influences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {\r\n\r\n	var influences = this.morphTargetInfluences;\r\n\r\n	for ( var i = 0, l = influences.length; i < l; i ++ ) {\r\n\r\n		influences[ i ] = 0;\r\n\r\n	}\r\n\r\n	if ( a > - 1 ) influences[ a ] = 1 - t;\r\n	if ( b > - 1 ) influences[ b ] = t;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.copy = function ( source ) {\r\n\r\n	THREE.Mesh.prototype.copy.call( this, source );\r\n\r\n	this.duration = source.duration;\r\n	this.mirroredLoop = source.mirroredLoop;\r\n	this.time = source.time;\r\n\r\n	this.lastKeyframe = source.lastKeyframe;\r\n	this.currentKeyframe = source.currentKeyframe;\r\n\r\n	this.direction = source.direction;\r\n	this.directionBackwards = source.directionBackwards;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'LOD';\r\n\r\n	Object.defineProperties( this, {\r\n		levels: {\r\n			enumerable: true,\r\n			value: []\r\n		},\r\n		objects: {\r\n			get: function () {\r\n\r\n				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n				return this.levels;\r\n\r\n			}\r\n		}\r\n	} );\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n	if ( distance === undefined ) distance = 0;\r\n\r\n	distance = Math.abs( distance );\r\n\r\n	var levels = this.levels;\r\n\r\n	for ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n		if ( distance < levels[ l ].distance ) {\r\n\r\n			break;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	levels.splice( l, 0, { distance: distance, object: object } );\r\n\r\n	this.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n	var levels = this.levels;\r\n\r\n	for ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n		if ( distance < levels[ i ].distance ) {\r\n\r\n			break;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return levels[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n	var matrixPosition = new THREE.Vector3();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		matrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		var distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n		this.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n\r\n	return function update( camera ) {\r\n\r\n		var levels = this.levels;\r\n\r\n		if ( levels.length > 1 ) {\r\n\r\n			v1.setFromMatrixPosition( camera.matrixWorld );\r\n			v2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n			var distance = v1.distanceTo( v2 );\r\n\r\n			levels[ 0 ].object.visible = true;\r\n\r\n			for ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n				if ( distance >= levels[ i ].distance ) {\r\n\r\n					levels[ i - 1 ].object.visible = false;\r\n					levels[ i ].object.visible = true;\r\n\r\n				} else {\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			for ( ; i < l; i ++ ) {\r\n\r\n				levels[ i ].object.visible = false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source, false );\r\n\r\n	var levels = source.levels;\r\n\r\n	for ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n		var level = levels[ i ];\r\n\r\n		this.addLevel( level.object.clone(), level.distance );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.levels = [];\r\n\r\n	var levels = this.levels;\r\n\r\n	for ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n		var level = levels[ i ];\r\n\r\n		data.object.levels.push( {\r\n			object: level.object.uuid,\r\n			distance: level.distance\r\n		} );\r\n\r\n	}\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n	return function Sprite( material ) {\r\n\r\n		THREE.Object3D.call( this );\r\n\r\n		this.type = 'Sprite';\r\n\r\n		this.geometry = geometry;\r\n		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n	};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n	var matrixPosition = new THREE.Vector3();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		matrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n		var guessSizeSq = this.scale.x * this.scale.y;\r\n\r\n		if ( distanceSq > guessSizeSq ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		intersects.push( {\r\n\r\n			distance: Math.sqrt( distanceSq ),\r\n			point: this.position,\r\n			face: null,\r\n			object: this\r\n\r\n		} );\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.material ).copy( this );\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	// only serialize if not in meta materials cache\r\n	if ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n		meta.materials[ this.material.uuid ] = this.material.toJSON();\r\n\r\n	}\r\n\r\n	data.object.material = this.material.uuid;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.lensFlares = [];\r\n\r\n	this.positionScreen = new THREE.Vector3();\r\n	this.customUpdateCallback = undefined;\r\n\r\n	if ( texture !== undefined ) {\r\n\r\n		this.add( texture, size, distance, blending, color );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n	if ( size === undefined ) size = - 1;\r\n	if ( distance === undefined ) distance = 0;\r\n	if ( opacity === undefined ) opacity = 1;\r\n	if ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n	if ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n	distance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n	this.lensFlares.push( {\r\n		texture: texture,	// THREE.Texture\r\n		size: size, 		// size in pixels (-1 = use texture.width)\r\n		distance: distance, 	// distance (0-1) from light source (0=at light source)\r\n		x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n		scale: 1, 		// scale\r\n		rotation: 0, 		// rotation\r\n		opacity: opacity,	// opacity\r\n		color: color,		// color\r\n		blending: blending	// blending\r\n	} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n	var f, fl = this.lensFlares.length;\r\n	var flare;\r\n	var vecX = - this.positionScreen.x * 2;\r\n	var vecY = - this.positionScreen.y * 2;\r\n\r\n	for ( f = 0; f < fl; f ++ ) {\r\n\r\n		flare = this.lensFlares[ f ];\r\n\r\n		flare.x = this.positionScreen.x + vecX * flare.distance;\r\n		flare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n		flare.wantedRotation = flare.x * Math.PI * 0.25;\r\n		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	this.positionScreen.copy( source.positionScreen );\r\n	this.customUpdateCallback = source.customUpdateCallback;\r\n\r\n	for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\r\n		this.lensFlares.push( source.lensFlares[ i ] );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Scene';\r\n\r\n	this.fog = null;\r\n	this.overrideMaterial = null;\r\n\r\n	this.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	if ( source.fog !== null ) this.fog = source.fog.clone();\r\n	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\r\n	this.autoUpdate = source.autoUpdate;\r\n	this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n	this.name = '';\r\n\r\n	this.color = new THREE.Color( color );\r\n\r\n	this.near = ( near !== undefined ) ? near : 1;\r\n	this.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n	return new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n	this.name = '';\r\n\r\n	this.color = new THREE.Color( color );\r\n	this.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n	return new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n	uniform sampler2D alphaMap;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n	if ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_fragment'] = \"#ifdef USE_AOMAP\\n\\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_pars_fragment'] = \"#ifdef USE_AOMAP\\n\\n	uniform sampler2D aoMap;\\n	uniform float aoMapIntensity;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'begin_vertex'] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'beginnormal_vertex'] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n	uniform sampler2D bumpMap;\\n	uniform float bumpScale;\\n\\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n	vec2 dHdxy_fwd() {\\n\\n		vec2 dSTdx = dFdx( vUv );\\n		vec2 dSTdy = dFdy( vUv );\\n\\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n		return vec2( dBx, dBy );\\n\\n	}\\n\\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n		vec3 vSigmaX = dFdx( surf_pos );\\n		vec3 vSigmaY = dFdy( surf_pos );\\n		vec3 vN = surf_norm;		// normalized\\n\\n		vec3 R1 = cross( vSigmaY, vN );\\n		vec3 R2 = cross( vN, vSigmaX );\\n\\n		float fDet = dot( vSigmaX, R1 );\\n\\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n		return normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n	}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment'] = \"#ifdef USE_COLOR\\n\\n	diffuseColor.rgb *= vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n	varying vec3 vColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n	varying vec3 vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex'] = \"#ifdef USE_COLOR\\n\\n	vColor.xyz = color.xyz;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common'] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\n\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n\\n}\\n\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n\\n}\\n\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\n	float distance = dot( planeNormal, point - pointOnPlane );\\n\\n	return - distance * planeNormal + point;\\n\\n}\\n\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\n	return sign( dot( point - pointOnPlane, planeNormal ) );\\n\\n}\\n\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n\\n}\\n\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\\n	if ( decayExponent > 0.0 ) {\\n\\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\n	}\\n\\n	return 1.0;\\n\\n}\\n\\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\\n\\n	// Original approximation by Christophe Schlick '94\\n	//;float fresnel = pow( 1.0 - dotLH, 5.0 );\\n\\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\\n\\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\\n\\n}\\n\\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\\n\\n	// geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\\n\\n	return 0.25;\\n\\n}\\n\\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\\n\\n	// factor of 1/PI in distribution term omitted\\n\\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n\\n}\\n\\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\\n\\n	vec3 halfDir = normalize( lightDir + viewDir );\\n\\n	//float dotNL = saturate( dot( normal, lightDir ) );\\n	//float dotNV = saturate( dot( normal, viewDir ) );\\n	float dotNH = saturate( dot( normal, halfDir ) );\\n	float dotLH = saturate( dot( lightDir, halfDir ) );\\n\\n	vec3 F = F_Schlick( specularColor, dotLH );\\n\\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\\n\\n	float D = D_BlinnPhong( shininess, dotNH );\\n\\n	return F * G * D;\\n\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n\\n	#ifdef GAMMA_INPUT\\n\\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n\\n	#else\\n\\n		return a;\\n\\n	#endif\\n\\n}\\n\\nvec3 linearToOutput( in vec3 a ) {\\n\\n	#ifdef GAMMA_OUTPUT\\n\\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n\\n	#else\\n\\n		return a;\\n\\n	#endif\\n\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex'] = \"#ifdef FLIP_SIDED\\n\\n	objectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_vertex'] = \"#ifdef USE_DISPLACEMENTMAP\\n\\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex'] = \"#ifdef USE_DISPLACEMENTMAP\\n\\n	uniform sampler2D displacementMap;\\n	uniform float displacementScale;\\n	uniform float displacementBias;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_fragment'] = \"#ifdef USE_EMISSIVEMAP\\n\\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\\n\\n	totalEmissiveLight *= emissiveColor.rgb;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment'] = \"#ifdef USE_EMISSIVEMAP\\n\\n	uniform sampler2D emissiveMap;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n		// Transforming Normal Vectors with the Inverse Transformation\\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n		#ifdef ENVMAP_MODE_REFLECTION\\n\\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n		#else\\n\\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n		#endif\\n\\n	#else\\n\\n		vec3 reflectVec = vReflect;\\n\\n	#endif\\n\\n	#ifdef DOUBLE_SIDED\\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n	#else\\n		float flipNormal = 1.0;\\n	#endif\\n\\n	#ifdef ENVMAP_TYPE_CUBE\\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n	#elif defined( ENVMAP_TYPE_EQUIREC )\\n		vec2 sampleUV;\\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n		vec4 envColor = texture2D( envMap, sampleUV );\\n\\n	#elif defined( ENVMAP_TYPE_SPHERE )\\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n	#endif\\n\\n	envColor.xyz = inputToLinear( envColor.xyz );\\n\\n	#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n	#elif defined( ENVMAP_BLENDING_MIX )\\n\\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n	#elif defined( ENVMAP_BLENDING_ADD )\\n\\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n	uniform float reflectivity;\\n	#ifdef ENVMAP_TYPE_CUBE\\n		uniform samplerCube envMap;\\n	#else\\n		uniform sampler2D envMap;\\n	#endif\\n	uniform float flipEnvMap;\\n\\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n		uniform float refractionRatio;\\n\\n	#else\\n\\n		varying vec3 vReflect;\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n	varying vec3 vReflect;\\n\\n	uniform float refractionRatio;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n	#ifdef ENVMAP_MODE_REFLECTION\\n\\n		vReflect = reflect( cameraToVertex, worldNormal );\\n\\n	#else\\n\\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment'] = \"#ifdef USE_FOG\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n	#else\\n\\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n	#endif\\n\\n	#ifdef FOG_EXP2\\n\\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\n	#else\\n\\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n	#endif\\n	\\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n	uniform vec3 fogColor;\\n\\n	#ifdef FOG_EXP2\\n\\n		uniform float fogDensity;\\n\\n	#else\\n\\n		uniform float fogNear;\\n		uniform float fogFar;\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n	uniform sampler2D lightMap;\\n	uniform float lightMapIntensity;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n	vLightBack = vec3( 0.0 );\\n\\n#endif\\n\\nvec3 normal = normalize( transformedNormal );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n		vec3 lightColor = pointLightColor[ i ];\\n\\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\\n		vec3 lightDir = normalize( lVector );\\n\\n		// attenuation\\n\\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n		// diffuse\\n\\n		float dotProduct = dot( normal, lightDir );\\n\\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\\n\\n		#endif\\n\\n	}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n		vec3 lightColor = spotLightColor[ i ];\\n\\n		vec3 lightPosition = spotLightPosition[ i ];\\n		vec3 lVector = lightPosition - mvPosition.xyz;\\n		vec3 lightDir = normalize( lVector );\\n\\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\\n\\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\\n\\n			// attenuation\\n\\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n			attenuation *= spotEffect;\\n\\n			// diffuse\\n\\n			float dotProduct = dot( normal, lightDir );\\n\\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\\n\\n			#ifdef DOUBLE_SIDED\\n\\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\\n\\n			#endif\\n\\n		}\\n\\n	}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n		vec3 lightColor = directionalLightColor[ i ];\\n\\n		vec3 lightDir = directionalLightDirection[ i ];\\n\\n		// diffuse\\n\\n		float dotProduct = dot( normal, lightDir );\\n\\n		vLightFront += lightColor * saturate( dotProduct );\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			vLightBack += lightColor * saturate( - dotProduct );\\n\\n		#endif\\n\\n	}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n		vec3 lightDir = hemisphereLightDirection[ i ];\\n\\n		// diffuse\\n\\n		float dotProduct = dot( normal, lightDir );\\n\\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\\n\\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n		#endif\\n\\n	}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n	vLightBack += ambientLightColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment'] = \"#ifndef FLAT_SHADED\\n\\n	vec3 normal = normalize( vNormal );\\n\\n	#ifdef DOUBLE_SIDED\\n\\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n	#endif\\n\\n#else\\n\\n	vec3 fdx = dFdx( vViewPosition );\\n	vec3 fdy = dFdy( vViewPosition );\\n	vec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\n#ifdef USE_NORMALMAP\\n\\n	normal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 viewDir = normalize( vViewPosition );\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n		vec3 lightColor = pointLightColor[ i ];\\n\\n		vec3 lightPosition = pointLightPosition[ i ];\\n		vec3 lVector = lightPosition + vViewPosition.xyz;\\n		vec3 lightDir = normalize( lVector );\\n\\n		// attenuation\\n\\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n		// diffuse\\n\\n		float cosineTerm = saturate( dot( normal, lightDir ) );\\n\\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\\n\\n		// specular\\n\\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\\n\\n\\n	}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n		vec3 lightColor = spotLightColor[ i ];\\n\\n		vec3 lightPosition = spotLightPosition[ i ];\\n		vec3 lVector = lightPosition + vViewPosition.xyz;\\n		vec3 lightDir = normalize( lVector );\\n\\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\\n\\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\\n\\n			// attenuation\\n\\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n			attenuation *= spotEffect;\\n\\n			// diffuse\\n\\n			float cosineTerm = saturate( dot( normal, lightDir ) );\\n\\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\\n\\n			// specular\\n\\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\\n\\n		}\\n\\n	}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n		vec3 lightColor = directionalLightColor[ i ];\\n\\n		vec3 lightDir = directionalLightDirection[ i ];\\n\\n		// diffuse\\n\\n		float cosineTerm = saturate( dot( normal, lightDir ) );\\n\\n		totalDiffuseLight += lightColor * cosineTerm;\\n\\n		// specular\\n\\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\\n\\n	}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n		vec3 lightDir = hemisphereLightDirection[ i ];\\n\\n		// diffuse\\n\\n		float dotProduct = dot( normal, lightDir );\\n\\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n		totalDiffuseLight += lightColor;\\n\\n		// specular (sky term only)\\n\\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n		totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\\n\\n	}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\\n\\n#else\\n\\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\\n\\n	varying vec3 vWorldPosition;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n	varying vec3 vNormal;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\\n\\n	varying vec3 vWorldPosition;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\\n\\n	vWorldPosition = worldPosition.xyz;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'linear_to_gamma_fragment'] = \"\\n	outgoingLight = linearToOutput( outgoingLight );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n	uniform float logDepthBufFC;\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		varying float vFragDepth;\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		varying float vFragDepth;\\n\\n	#endif\\n\\n	uniform float logDepthBufFC;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		vFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment'] = \"#ifdef USE_MAP\\n\\n	vec4 texelColor = texture2D( map, vUv );\\n\\n	texelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n	diffuseColor *= texelColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment'] = \"#ifdef USE_MAP\\n\\n	uniform sampler2D map;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n	uniform vec4 offsetRepeat;\\n	uniform sampler2D map;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n	#ifndef USE_MORPHNORMALS\\n\\n	uniform float morphTargetInfluences[ 8 ];\\n\\n	#else\\n\\n	uniform float morphTargetInfluences[ 4 ];\\n\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n	#ifndef USE_MORPHNORMALS\\n\\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n	uniform sampler2D normalMap;\\n	uniform vec2 normalScale;\\n\\n	// Per-Pixel Tangent Space Normal Mapping\\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n		vec3 q0 = dFdx( eye_pos.xyz );\\n		vec3 q1 = dFdy( eye_pos.xyz );\\n		vec2 st0 = dFdx( vUv.st );\\n		vec2 st1 = dFdy( vUv.st );\\n\\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n		vec3 N = normalize( surf_norm );\\n\\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n		mapN.xy = normalScale * mapN.xy;\\n		mat3 tsn = mat3( S, T, N );\\n		return normalize( tsn * mapN );\\n\\n	}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'project_vertex'] = \"#ifdef USE_SKINNING\\n\\n	vec4 mvPosition = modelViewMatrix * skinned;\\n\\n#else\\n\\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n	#ifdef SHADOWMAP_DEBUG\\n\\n		vec3 frustumColors[3];\\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n	#endif\\n\\n	float fDepth;\\n	vec3 shadowColor = vec3( 1.0 );\\n\\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n				// if ( something && something ) breaks ATI OpenGL shader compiler\\n				// if ( all( something, something ) ) using this instead\\n\\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n		bool inFrustum = all( inFrustumVec );\\n\\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n		bool frustumTest = all( frustumTestVec );\\n\\n		if ( frustumTest ) {\\n\\n			shadowCoord.z += shadowBias[ i ];\\n\\n			#if defined( SHADOWMAP_TYPE_PCF )\\n\\n						// Percentage-close filtering\\n						// (9 pixel kernel)\\n						// http://fabiensanglard.net/shadowmappingPCF/\\n\\n				float shadow = 0.0;\\n\\n		/*\\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n						// must enroll loop manually\\n\\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n						float fDepth = unpackDepth( rgbaDepth );\\n\\n						if ( fDepth < shadowCoord.z )\\n							shadow += 1.0;\\n\\n				}\\n\\n				shadow /= 9.0;\\n\\n		*/\\n\\n				const float shadowDelta = 1.0 / 9.0;\\n\\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n				float dx0 = -1.25 * xPixelOffset;\\n				float dy0 = -1.25 * yPixelOffset;\\n				float dx1 = 1.25 * xPixelOffset;\\n				float dy1 = 1.25 * yPixelOffset;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n						// Percentage-close filtering\\n						// (9 pixel kernel)\\n						// http://fabiensanglard.net/shadowmappingPCF/\\n\\n				float shadow = 0.0;\\n\\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n				float dx0 = -1.0 * xPixelOffset;\\n				float dy0 = -1.0 * yPixelOffset;\\n				float dx1 = 1.0 * xPixelOffset;\\n				float dy1 = 1.0 * yPixelOffset;\\n\\n				mat3 shadowKernel;\\n				mat3 depthKernel;\\n\\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n				vec3 shadowZ = vec3( shadowCoord.z );\\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n				shadowKernel[0] *= vec3(0.25);\\n\\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n				shadowKernel[1] *= vec3(0.25);\\n\\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n				shadowKernel[2] *= vec3(0.25);\\n\\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n				vec4 shadowValues;\\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n				shadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n			#else\\n\\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n				float fDepth = unpackDepth( rgbaDepth );\\n\\n				if ( fDepth < shadowCoord.z )\\n\\n		// spot with multiple shadows is darker\\n\\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n		// spot with multiple shadows has the same color as single shadow spot\\n\\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n			#endif\\n\\n		}\\n\\n\\n		#ifdef SHADOWMAP_DEBUG\\n\\n			if ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n		#endif\\n\\n	}\\n\\n	outgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n	uniform float shadowDarkness[ MAX_SHADOWS ];\\n	uniform float shadowBias[ MAX_SHADOWS ];\\n\\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n	float unpackDepth( const in vec4 rgba_depth ) {\\n\\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n		float depth = dot( rgba_depth, bit_shift );\\n		return depth;\\n\\n	}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n	}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n	uniform mat4 bindMatrix;\\n	uniform mat4 bindMatrixInverse;\\n\\n	#ifdef BONE_TEXTURE\\n\\n		uniform sampler2D boneTexture;\\n		uniform int boneTextureWidth;\\n		uniform int boneTextureHeight;\\n\\n		mat4 getBoneMatrix( const in float i ) {\\n\\n			float j = i * 4.0;\\n			float x = mod( j, float( boneTextureWidth ) );\\n			float y = floor( j / float( boneTextureWidth ) );\\n\\n			float dx = 1.0 / float( boneTextureWidth );\\n			float dy = 1.0 / float( boneTextureHeight );\\n\\n			y = dy * ( y + 0.5 );\\n\\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n			mat4 bone = mat4( v1, v2, v3, v4 );\\n\\n			return bone;\\n\\n		}\\n\\n	#else\\n\\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n		mat4 getBoneMatrix( const in float i ) {\\n\\n			mat4 bone = boneGlobalMatrices[ int(i) ];\\n			return bone;\\n\\n		}\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\n	vec4 skinned = vec4( 0.0 );\\n	skinned += boneMatX * skinVertex * skinWeight.x;\\n	skinned += boneMatY * skinVertex * skinWeight.y;\\n	skinned += boneMatZ * skinVertex * skinWeight.z;\\n	skinned += boneMatW * skinVertex * skinWeight.w;\\n	skinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n	mat4 skinMatrix = mat4( 0.0 );\\n	skinMatrix += skinWeight.x * boneMatX;\\n	skinMatrix += skinWeight.y * boneMatY;\\n	skinMatrix += skinWeight.z * boneMatZ;\\n	skinMatrix += skinWeight.w * boneMatW;\\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n	vec4 texelSpecular = texture2D( specularMap, vUv );\\n	specularStrength = texelSpecular.r;\\n\\n#else\\n\\n	specularStrength = 1.0;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n	uniform sampler2D specularMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_fragment'] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\n	varying vec2 vUv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_vertex'] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\n	attribute vec2 uv2;\\n	varying vec2 vUv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_vertex'] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\n	vUv2 = uv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\\n\\n	varying vec2 vUv;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\\n\\n	varying vec2 vUv;\\n	uniform vec4 offsetRepeat;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\\n\\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n	#ifdef USE_SKINNING\\n\\n		vec4 worldPosition = modelMatrix * skinned;\\n\\n	#else\\n\\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n	merge: function ( uniforms ) {\r\n\r\n		var merged = {};\r\n\r\n		for ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n			var tmp = this.clone( uniforms[ u ] );\r\n\r\n			for ( var p in tmp ) {\r\n\r\n				merged[ p ] = tmp[ p ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return merged;\r\n\r\n	},\r\n\r\n	clone: function ( uniforms_src ) {\r\n\r\n		var uniforms_dst = {};\r\n\r\n		for ( var u in uniforms_src ) {\r\n\r\n			uniforms_dst[ u ] = {};\r\n\r\n			for ( var p in uniforms_src[ u ] ) {\r\n\r\n				var parameter_src = uniforms_src[ u ][ p ];\r\n\r\n				if ( parameter_src instanceof THREE.Color ||\r\n					 parameter_src instanceof THREE.Vector2 ||\r\n					 parameter_src instanceof THREE.Vector3 ||\r\n					 parameter_src instanceof THREE.Vector4 ||\r\n					 parameter_src instanceof THREE.Matrix3 ||\r\n					 parameter_src instanceof THREE.Matrix4 ||\r\n					 parameter_src instanceof THREE.Texture ) {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n				} else if ( Array.isArray( parameter_src ) ) {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n				} else {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return uniforms_dst;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n	common: {\r\n\r\n		\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n		\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n		\"map\" : { type: \"t\", value: null },\r\n		\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n		\"specularMap\" : { type: \"t\", value: null },\r\n		\"alphaMap\" : { type: \"t\", value: null },\r\n\r\n		\"envMap\" : { type: \"t\", value: null },\r\n		\"flipEnvMap\" : { type: \"f\", value: - 1 },\r\n		\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n		\"refractionRatio\" : { type: \"f\", value: 0.98 }\r\n\r\n	},\r\n\r\n	aomap: {\r\n\r\n		\"aoMap\" : { type: \"t\", value: null },\r\n		\"aoMapIntensity\" : { type: \"f\", value: 1 },\r\n\r\n	},\r\n\r\n	lightmap: {\r\n\r\n		\"lightMap\" : { type: \"t\", value: null },\r\n		\"lightMapIntensity\" : { type: \"f\", value: 1 },\r\n\r\n	},\r\n\r\n	emissivemap: {\r\n\r\n		\"emissiveMap\" : { type: \"t\", value: null },\r\n\r\n	},\r\n\r\n	bumpmap: {\r\n\r\n		\"bumpMap\" : { type: \"t\", value: null },\r\n		\"bumpScale\" : { type: \"f\", value: 1 }\r\n\r\n	},\r\n\r\n	normalmap: {\r\n\r\n		\"normalMap\" : { type: \"t\", value: null },\r\n		\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\r\n	},\r\n\r\n	displacementmap: {\r\n\r\n		\"displacementMap\" : { type: \"t\", value: null },\r\n		\"displacementScale\" : { type: \"f\", value: 1 },\r\n		\"displacementBias\" : { type: \"f\", value: 0 }\r\n\r\n	},\r\n\r\n	fog : {\r\n\r\n		\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n		\"fogNear\" : { type: \"f\", value: 1 },\r\n		\"fogFar\" : { type: \"f\", value: 2000 },\r\n		\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n	},\r\n\r\n	lights: {\r\n\r\n		\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n		\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n		\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n		\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n		\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n		\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n		\"pointLightColor\" : { type: \"fv\", value: [] },\r\n		\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n		\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n		\"pointLightDecay\" : { type: \"fv1\", value: [] },\r\n\r\n		\"spotLightColor\" : { type: \"fv\", value: [] },\r\n		\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n		\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n		\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n		\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n		\"spotLightExponent\" : { type: \"fv1\", value: [] },\r\n		\"spotLightDecay\" : { type: \"fv1\", value: [] }\r\n\r\n	},\r\n\r\n	points: {\r\n\r\n		\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n		\"opacity\" : { type: \"f\", value: 1.0 },\r\n		\"size\" : { type: \"f\", value: 1.0 },\r\n		\"scale\" : { type: \"f\", value: 1.0 },\r\n		\"map\" : { type: \"t\", value: null },\r\n		\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n		\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n		\"fogNear\" : { type: \"f\", value: 1 },\r\n		\"fogFar\" : { type: \"f\", value: 2000 },\r\n		\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n	},\r\n\r\n	shadowmap: {\r\n\r\n		\"shadowMap\": { type: \"tv\", value: [] },\r\n		\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n		\"shadowBias\" : { type: \"fv1\", value: [] },\r\n		\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n		\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n	'basic': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"aomap\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n			\"	#ifdef USE_ENVMAP\",\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"	#endif\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n			\"	vec3 totalAmbientLight = vec3( 1.0 );\", // hardwired\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"aomap_fragment\" ],\r\n\r\n			\"	outgoingLight = diffuseColor.rgb * totalAmbientLight;\", // simple shader\r\n\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'lambert': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n			{\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define LAMBERT\",\r\n\r\n			\"varying vec3 vLightFront;\",\r\n\r\n			\"#ifdef DOUBLE_SIDED\",\r\n\r\n			\"	varying vec3 vLightBack;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform vec3 emissive;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"varying vec3 vLightFront;\",\r\n\r\n			\"#ifdef DOUBLE_SIDED\",\r\n\r\n			\"	varying vec3 vLightBack;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",	// outgoing light does not have an alpha, the surface does\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n			\"	#ifdef DOUBLE_SIDED\",\r\n\r\n			\"		if ( gl_FrontFacing )\",\r\n			\"			outgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n			\"		else\",\r\n			\"			outgoingLight += diffuseColor.rgb * vLightBack + emissive;\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		outgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\r\n			\"	#endif\",\r\n\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'phong': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"aomap\" ],\r\n			THREE.UniformsLib[ \"lightmap\" ],\r\n			THREE.UniformsLib[ \"emissivemap\" ],\r\n			THREE.UniformsLib[ \"bumpmap\" ],\r\n			THREE.UniformsLib[ \"normalmap\" ],\r\n			THREE.UniformsLib[ \"displacementmap\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n			{\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n				\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n				\"shininess\": { type: \"f\", value: 30 }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define PHONG\",\r\n\r\n			\"varying vec3 vViewPosition;\",\r\n\r\n			\"#ifndef FLAT_SHADED\",\r\n\r\n			\"	varying vec3 vNormal;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"displacementmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\r\n			\"	vNormal = normalize( transformedNormal );\",\r\n\r\n			\"#endif\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"displacementmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"	vViewPosition = - mvPosition.xyz;\",\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"#define PHONG\",\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform vec3 emissive;\",\r\n			\"uniform vec3 specular;\",\r\n			\"uniform float shininess;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"emissivemap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n			\"	vec3 totalAmbientLight = ambientLightColor;\",\r\n			\"	vec3 totalEmissiveLight = emissive;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"aomap_fragment\" ],\r\n				THREE.ShaderChunk[ \"emissivemap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'points': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"points\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"uniform float size;\",\r\n			\"uniform float scale;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n			\"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n			\"	#ifdef USE_SIZEATTENUATION\",\r\n			\"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n			\"	#else\",\r\n			\"		gl_PointSize = size;\",\r\n			\"	#endif\",\r\n\r\n			\"	gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 psColor;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",\r\n			\"	vec4 diffuseColor = vec4( psColor, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\r\n			\"	outgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'dashed': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n\r\n			{\r\n				\"scale\"    : { type: \"f\", value: 1 },\r\n				\"dashSize\" : { type: \"f\", value: 1 },\r\n				\"totalSize\": { type: \"f\", value: 2 }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"uniform float scale;\",\r\n			\"attribute float lineDistance;\",\r\n\r\n			\"varying float vLineDistance;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n			\"	vLineDistance = scale * lineDistance;\",\r\n\r\n			\"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n			\"	gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"uniform float dashSize;\",\r\n			\"uniform float totalSize;\",\r\n\r\n			\"varying float vLineDistance;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n			\"		discard;\",\r\n\r\n			\"	}\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n\r\n			\"	outgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'depth': {\r\n\r\n		uniforms: {\r\n\r\n			\"mNear\": { type: \"f\", value: 1.0 },\r\n			\"mFar\" : { type: \"f\", value: 2000.0 },\r\n			\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float mNear;\",\r\n			\"uniform float mFar;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"	#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n			\"		float depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n			\"	#endif\",\r\n\r\n			\"	float color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n			\"	gl_FragColor = vec4( vec3( color ), opacity );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'normal': {\r\n\r\n		uniforms: {\r\n\r\n			\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vNormal = normalize( normalMatrix * normal );\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float opacity;\",\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	/* -------------------------------------------------------------------------\r\n	//	Cube map shader\r\n	 ------------------------------------------------------------------------- */\r\n\r\n	'cube': {\r\n\r\n		uniforms: { \"tCube\": { type: \"t\", value: null },\r\n					\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n			\"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform samplerCube tCube;\",\r\n			\"uniform float tFlip;\",\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	/* -------------------------------------------------------------------------\r\n	//	Cube map shader\r\n	 ------------------------------------------------------------------------- */\r\n\r\n	'equirect': {\r\n\r\n		uniforms: { \"tEquirect\": { type: \"t\", value: null },\r\n					\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n			\"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform sampler2D tEquirect;\",\r\n			\"uniform float tFlip;\",\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				// \"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n				\"vec3 direction = normalize( vWorldPosition );\",\r\n				\"vec2 sampleUV;\",\r\n				\"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\",\r\n				\"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n				\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	/* Depth encoding into RGBA texture\r\n	 *\r\n	 * based on SpiderGL shadow map example\r\n	 * http://spidergl.org/example.php?id=6\r\n	 *\r\n	 * originally from\r\n	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n	 *\r\n	 * see also\r\n	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n	 */\r\n\r\n	'depthRGBA': {\r\n\r\n		uniforms: {},\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n			\"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n			\"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n			\"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"	vec4 res = fract( depth * bit_shift );\",\r\n			\"	res -= res.xxyz * bit_mask;\",\r\n			\"	return res;\",\r\n\r\n			\"}\",\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"	#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n			\"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n			\"	#endif\",\r\n\r\n				//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n				//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n				//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n				//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n	console.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n	parameters = parameters || {};\r\n\r\n	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n	_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n	_width = _canvas.width,\r\n	_height = _canvas.height,\r\n\r\n	pixelRatio = 1,\r\n\r\n	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n	_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\r\n	_clearColor = new THREE.Color( 0x000000 ),\r\n	_clearAlpha = 0;\r\n\r\n	var lights = [];\r\n\r\n	var opaqueObjects = [];\r\n	var opaqueObjectsLastIndex = -1;\r\n	var transparentObjects = [];\r\n	var transparentObjectsLastIndex = -1;\r\n\r\n	var opaqueImmediateObjects = [];\r\n	var opaqueImmediateObjectsLastIndex = -1;\r\n	var transparentImmediateObjects = [];\r\n	var transparentImmediateObjectsLastIndex = -1;\r\n\r\n	var morphInfluences = new Float32Array( 8 );\r\n\r\n\r\n	var sprites = [];\r\n	var lensFlares = [];\r\n\r\n	// public properties\r\n\r\n	this.domElement = _canvas;\r\n	this.context = null;\r\n\r\n	// clearing\r\n\r\n	this.autoClear = true;\r\n	this.autoClearColor = true;\r\n	this.autoClearDepth = true;\r\n	this.autoClearStencil = true;\r\n\r\n	// scene graph\r\n\r\n	this.sortObjects = true;\r\n\r\n	// physically based shading\r\n\r\n	this.gammaFactor = 2.0;	// for backwards compatibility\r\n	this.gammaInput = false;\r\n	this.gammaOutput = false;\r\n\r\n	// morphs\r\n\r\n	this.maxMorphTargets = 8;\r\n	this.maxMorphNormals = 4;\r\n\r\n	// flags\r\n\r\n	this.autoScaleCubemaps = true;\r\n\r\n	// internal properties\r\n\r\n	var _this = this,\r\n\r\n	// internal state cache\r\n\r\n	_currentProgram = null,\r\n	_currentFramebuffer = null,\r\n	_currentMaterialId = - 1,\r\n	_currentGeometryProgram = '',\r\n	_currentCamera = null,\r\n\r\n	_usedTextureUnits = 0,\r\n\r\n	_viewportX = 0,\r\n	_viewportY = 0,\r\n	_viewportWidth = _canvas.width,\r\n	_viewportHeight = _canvas.height,\r\n	_currentWidth = 0,\r\n	_currentHeight = 0,\r\n\r\n	// frustum\r\n\r\n	_frustum = new THREE.Frustum(),\r\n\r\n	 // camera matrices cache\r\n\r\n	_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n	_vector3 = new THREE.Vector3(),\r\n\r\n	// light arrays cache\r\n\r\n	_direction = new THREE.Vector3(),\r\n\r\n	_lightsNeedUpdate = true,\r\n\r\n	_lights = {\r\n\r\n		ambient: [ 0, 0, 0 ],\r\n		directional: { length: 0, colors: [], positions: [] },\r\n		point: { length: 0, colors: [], positions: [], distances: [], decays: [] },\r\n		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },\r\n		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }\r\n\r\n	},\r\n\r\n	// info\r\n\r\n	_infoMemory = {\r\n\r\n		geometries: 0,\r\n		textures: 0\r\n\r\n	},\r\n\r\n	_infoRender = {\r\n\r\n		calls: 0,\r\n		vertices: 0,\r\n		faces: 0,\r\n		points: 0\r\n\r\n	};\r\n\r\n	this.info = {\r\n\r\n		render: _infoRender,\r\n		memory: _infoMemory,\r\n		programs: null\r\n\r\n	};\r\n\r\n\r\n	// initialize\r\n\r\n	var _gl;\r\n\r\n	try {\r\n\r\n		var attributes = {\r\n			alpha: _alpha,\r\n			depth: _depth,\r\n			stencil: _stencil,\r\n			antialias: _antialias,\r\n			premultipliedAlpha: _premultipliedAlpha,\r\n			preserveDrawingBuffer: _preserveDrawingBuffer\r\n		};\r\n\r\n		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n		if ( _gl === null ) {\r\n\r\n			if ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\r\n				throw 'Error creating WebGL context with your selected attributes.';\r\n\r\n			} else {\r\n\r\n				throw 'Error creating WebGL context.';\r\n\r\n			}\r\n\r\n		}\r\n\r\n		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n	} catch ( error ) {\r\n\r\n		console.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n	}\r\n\r\n	var extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n	extensions.get( 'OES_texture_float' );\r\n	extensions.get( 'OES_texture_float_linear' );\r\n	extensions.get( 'OES_texture_half_float' );\r\n	extensions.get( 'OES_texture_half_float_linear' );\r\n	extensions.get( 'OES_standard_derivatives' );\r\n	extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n	if ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n		THREE.BufferGeometry.MaxIndex = 4294967296;\r\n\r\n	}\r\n\r\n	var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n	var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n	var properties = new THREE.WebGLProperties();\r\n	var objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n	var programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\r\n	this.info.programs = programCache.programs;\r\n\r\n	var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n	var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\r\n	//\r\n\r\n	function glClearColor( r, g, b, a ) {\r\n\r\n		if ( _premultipliedAlpha === true ) {\r\n\r\n			r *= a; g *= a; b *= a;\r\n\r\n		}\r\n\r\n		_gl.clearColor( r, g, b, a );\r\n\r\n	}\r\n\r\n	function setDefaultGLState() {\r\n\r\n		state.init();\r\n\r\n		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	}\r\n\r\n	function resetGLState() {\r\n\r\n		_currentProgram = null;\r\n		_currentCamera = null;\r\n\r\n		_currentGeometryProgram = '';\r\n		_currentMaterialId = - 1;\r\n\r\n		_lightsNeedUpdate = true;\r\n\r\n		state.reset();\r\n\r\n	}\r\n\r\n	setDefaultGLState();\r\n\r\n	this.context = _gl;\r\n	this.capabilities = capabilities;\r\n	this.extensions = extensions;\r\n	this.state = state;\r\n\r\n	// shadow map\r\n\r\n	var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );\r\n\r\n	this.shadowMap = shadowMap;\r\n\r\n\r\n	// Plugins\r\n\r\n	var spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n	// API\r\n\r\n	this.getContext = function () {\r\n\r\n		return _gl;\r\n\r\n	};\r\n\r\n	this.getContextAttributes = function () {\r\n\r\n		return _gl.getContextAttributes();\r\n\r\n	};\r\n\r\n	this.forceContextLoss = function () {\r\n\r\n		extensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n	};\r\n\r\n	this.getMaxAnisotropy = ( function () {\r\n\r\n		var value;\r\n\r\n		return function getMaxAnisotropy() {\r\n\r\n			if ( value !== undefined ) return value;\r\n\r\n			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n			if ( extension !== null ) {\r\n\r\n				value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\r\n			} else {\r\n\r\n				value = 0;\r\n\r\n			}\r\n\r\n			return value;\r\n\r\n		}\r\n\r\n	} )();\r\n\r\n	this.getPrecision = function () {\r\n\r\n		return capabilities.precision;\r\n\r\n	};\r\n\r\n	this.getPixelRatio = function () {\r\n\r\n		return pixelRatio;\r\n\r\n	};\r\n\r\n	this.setPixelRatio = function ( value ) {\r\n\r\n		if ( value !== undefined ) pixelRatio = value;\r\n\r\n	};\r\n\r\n	this.getSize = function () {\r\n\r\n		return {\r\n			width: _width,\r\n			height: _height\r\n		};\r\n\r\n	};\r\n\r\n	this.setSize = function ( width, height, updateStyle ) {\r\n\r\n		_width = width;\r\n		_height = height;\r\n\r\n		_canvas.width = width * pixelRatio;\r\n		_canvas.height = height * pixelRatio;\r\n\r\n		if ( updateStyle !== false ) {\r\n\r\n			_canvas.style.width = width + 'px';\r\n			_canvas.style.height = height + 'px';\r\n\r\n		}\r\n\r\n		this.setViewport( 0, 0, width, height );\r\n\r\n	};\r\n\r\n	this.setViewport = function ( x, y, width, height ) {\r\n\r\n		_viewportX = x * pixelRatio;\r\n		_viewportY = y * pixelRatio;\r\n\r\n		_viewportWidth = width * pixelRatio;\r\n		_viewportHeight = height * pixelRatio;\r\n\r\n		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n	};\r\n\r\n	this.setScissor = function ( x, y, width, height ) {\r\n\r\n		_gl.scissor(\r\n			x * pixelRatio,\r\n			y * pixelRatio,\r\n			width * pixelRatio,\r\n			height * pixelRatio\r\n		);\r\n\r\n	};\r\n\r\n	this.enableScissorTest = function ( boolean ) {\r\n\r\n		state.setScissorTest( boolean );\r\n\r\n	};\r\n\r\n	// Clearing\r\n\r\n	this.getClearColor = function () {\r\n\r\n		return _clearColor;\r\n\r\n	};\r\n\r\n	this.setClearColor = function ( color, alpha ) {\r\n\r\n		_clearColor.set( color );\r\n\r\n		_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	this.getClearAlpha = function () {\r\n\r\n		return _clearAlpha;\r\n\r\n	};\r\n\r\n	this.setClearAlpha = function ( alpha ) {\r\n\r\n		_clearAlpha = alpha;\r\n\r\n		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	this.clear = function ( color, depth, stencil ) {\r\n\r\n		var bits = 0;\r\n\r\n		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n		_gl.clear( bits );\r\n\r\n	};\r\n\r\n	this.clearColor = function () {\r\n\r\n		_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\r\n	};\r\n\r\n	this.clearDepth = function () {\r\n\r\n		_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\r\n	};\r\n\r\n	this.clearStencil = function () {\r\n\r\n		_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\r\n	};\r\n\r\n	this.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n		this.setRenderTarget( renderTarget );\r\n		this.clear( color, depth, stencil );\r\n\r\n	};\r\n\r\n	// Reset\r\n\r\n	this.resetGLState = resetGLState;\r\n\r\n	this.dispose = function() {\r\n\r\n		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n	};\r\n\r\n	// Events\r\n\r\n	function onContextLost( event ) {\r\n\r\n		event.preventDefault();\r\n\r\n		resetGLState();\r\n		setDefaultGLState();\r\n\r\n		properties.clear();\r\n\r\n	};\r\n\r\n	function onTextureDispose( event ) {\r\n\r\n		var texture = event.target;\r\n\r\n		texture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n		deallocateTexture( texture );\r\n\r\n		_infoMemory.textures --;\r\n\r\n\r\n	}\r\n\r\n	function onRenderTargetDispose( event ) {\r\n\r\n		var renderTarget = event.target;\r\n\r\n		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n		deallocateRenderTarget( renderTarget );\r\n\r\n		_infoMemory.textures --;\r\n\r\n	}\r\n\r\n	function onMaterialDispose( event ) {\r\n\r\n		var material = event.target;\r\n\r\n		material.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n		deallocateMaterial( material );\r\n\r\n	}\r\n\r\n	// Buffer deallocation\r\n\r\n	function deallocateTexture( texture ) {\r\n\r\n		var textureProperties = properties.get( texture );\r\n\r\n		if ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\r\n			// cube texture\r\n\r\n			_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\r\n		} else {\r\n\r\n			// 2D texture\r\n\r\n			if ( textureProperties.__webglInit === undefined ) return;\r\n\r\n			_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n		}\r\n\r\n		// remove all webgl properties\r\n		properties.delete( texture );\r\n\r\n	}\r\n\r\n	function deallocateRenderTarget( renderTarget ) {\r\n\r\n		var renderTargetProperties = properties.get( renderTarget );\r\n\r\n		if ( ! renderTarget || renderTargetProperties.__webglTexture === undefined ) return;\r\n\r\n		_gl.deleteTexture( renderTargetProperties.__webglTexture );\r\n\r\n		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n			for ( var i = 0; i < 6; i ++ ) {\r\n\r\n				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n			_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );\r\n\r\n		}\r\n\r\n		properties.delete( renderTarget );\r\n\r\n	}\r\n\r\n	function deallocateMaterial( material ) {\r\n\r\n		releaseMaterialProgramReference( material );\r\n\r\n		properties.delete( material );\r\n\r\n	}\r\n\r\n\r\n	function releaseMaterialProgramReference( material ) {\r\n\r\n		var programInfo = properties.get( material ).program;\r\n\r\n		material.program = undefined;\r\n\r\n		if ( programInfo !== undefined ) {\r\n\r\n			programCache.releaseProgram( programInfo );\r\n		}\r\n\r\n	}\r\n\r\n	// Buffer rendering\r\n\r\n	this.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n		state.initAttributes();\r\n\r\n		var buffers = properties.get( object );\r\n\r\n		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\r\n		var attributes = program.getAttributes();\r\n\r\n		if ( object.hasPositions ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.position );\r\n			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasNormals ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\r\n			if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {\r\n\r\n				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\r\n					var array = object.normalArray;\r\n\r\n					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\r\n					array[ i + 0 ] = nx;\r\n					array[ i + 1 ] = ny;\r\n					array[ i + 2 ] = nz;\r\n\r\n					array[ i + 3 ] = nx;\r\n					array[ i + 4 ] = ny;\r\n					array[ i + 5 ] = nz;\r\n\r\n					array[ i + 6 ] = nx;\r\n					array[ i + 7 ] = ny;\r\n					array[ i + 8 ] = nz;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.normal );\r\n\r\n			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasUvs && material.map ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.uv );\r\n\r\n			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.color );\r\n\r\n			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		state.disableUnusedAttributes();\r\n\r\n		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n		object.count = 0;\r\n\r\n	};\r\n\r\n	this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {\r\n\r\n		setMaterial( material );\r\n\r\n		var program = setProgram( camera, lights, fog, material, object );\r\n\r\n		var updateBuffers = false;\r\n		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\r\n		if ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n			_currentGeometryProgram = geometryProgram;\r\n			updateBuffers = true;\r\n\r\n		}\r\n\r\n		// morph targets\r\n\r\n		var morphTargetInfluences = object.morphTargetInfluences;\r\n\r\n		if ( morphTargetInfluences !== undefined ) {\r\n\r\n			var activeInfluences = [];\r\n\r\n			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\r\n				var influence = morphTargetInfluences[ i ];\r\n				activeInfluences.push( [ influence, i ] );\r\n\r\n			}\r\n\r\n			activeInfluences.sort( numericalSort );\r\n\r\n			if ( activeInfluences.length > 8 ) {\r\n\r\n				activeInfluences.length = 8;\r\n\r\n			}\r\n\r\n			var morphAttributes = geometry.morphAttributes;\r\n\r\n			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\r\n				var influence = activeInfluences[ i ];\r\n				morphInfluences[ i ] = influence[ 0 ];\r\n\r\n				if ( influence[ 0 ] !== 0 ) {\r\n\r\n					var index = influence[ 1 ];\r\n\r\n					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\r\n				} else {\r\n\r\n					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var uniforms = program.getUniforms();\r\n\r\n			if ( uniforms.morphTargetInfluences !== null ) {\r\n\r\n				_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );\r\n\r\n			}\r\n\r\n			updateBuffers = true;\r\n\r\n		}\r\n\r\n		//\r\n\r\n		var index = geometry.index;\r\n		var position = geometry.attributes.position;\r\n\r\n		if ( material.wireframe === true ) {\r\n\r\n			index = objects.getWireframeAttribute( geometry );\r\n\r\n		}\r\n\r\n		var renderer;\r\n\r\n		if ( index !== null ) {\r\n\r\n			renderer = indexedBufferRenderer;\r\n			renderer.setIndex( index );\r\n\r\n		} else {\r\n\r\n			renderer = bufferRenderer;\r\n\r\n		}\r\n\r\n		if ( updateBuffers ) {\r\n\r\n			setupVertexAttributes( material, program, geometry );\r\n\r\n			if ( index !== null ) {\r\n\r\n				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( group === undefined ) {\r\n\r\n			var count;\r\n\r\n			if ( index !== null ) {\r\n\r\n				count = index.count;\r\n\r\n			} else if ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n				count = position.data.array.length / 3;\r\n\r\n			} else {\r\n\r\n				count = position.count;\r\n\r\n			}\r\n\r\n			var drawRange = geometry.drawRange;\r\n\r\n			group = {\r\n				start: drawRange.start,\r\n				count: Math.min( drawRange.count, count )\r\n			};\r\n\r\n		}\r\n\r\n		if ( object instanceof THREE.Mesh ) {\r\n\r\n			if ( material.wireframe === true ) {\r\n\r\n				state.setLineWidth( material.wireframeLinewidth * pixelRatio );\r\n				renderer.setMode( _gl.LINES );\r\n\r\n			} else {\r\n\r\n				renderer.setMode( _gl.TRIANGLES );\r\n\r\n			}\r\n\r\n			if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {\r\n\r\n				renderer.renderInstances( geometry );\r\n\r\n			} else {\r\n\r\n				renderer.render( group.start, group.count );\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.Line ) {\r\n\r\n			var lineWidth = material.linewidth;\r\n\r\n			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\r\n			state.setLineWidth( lineWidth * pixelRatio );\r\n\r\n			if ( object instanceof THREE.LineSegments ) {\r\n\r\n				renderer.setMode( _gl.LINES );\r\n\r\n			} else {\r\n\r\n				renderer.setMode( _gl.LINE_STRIP );\r\n\r\n			}\r\n\r\n			renderer.render( group.start, group.count );\r\n\r\n		} else if ( object instanceof THREE.Points ) {\r\n\r\n			renderer.setMode( _gl.POINTS );\r\n			renderer.render( group.start, group.count );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n		var extension;\r\n\r\n		if ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n			extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n			if ( extension === null ) {\r\n\r\n				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n				return;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( startIndex === undefined ) startIndex = 0;\r\n\r\n		state.initAttributes();\r\n\r\n		var geometryAttributes = geometry.attributes;\r\n\r\n		var programAttributes = program.getAttributes();\r\n\r\n		var materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n		for ( var name in programAttributes ) {\r\n\r\n			var programAttribute = programAttributes[ name ];\r\n\r\n			if ( programAttribute >= 0 ) {\r\n\r\n				var geometryAttribute = geometryAttributes[ name ];\r\n\r\n				if ( geometryAttribute !== undefined ) {\r\n\r\n					state.enableAttribute( programAttribute );\r\n\r\n					var size = geometryAttribute.itemSize;\r\n					var buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\r\n					if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n						var data = geometryAttribute.data;\r\n						var stride = data.stride;\r\n						var offset = geometryAttribute.offset;\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\r\n						if ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\r\n							if ( extension === null ) {\r\n\r\n								console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );\r\n								return;\r\n\r\n							}\r\n\r\n							extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );\r\n\r\n							if ( geometry.maxInstancedCount === undefined ) {\r\n\r\n								geometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\r\n							}\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\r\n						if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\r\n							if ( extension === null ) {\r\n\r\n								console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );\r\n								return;\r\n\r\n							}\r\n\r\n							extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );\r\n\r\n							if ( geometry.maxInstancedCount === undefined ) {\r\n\r\n								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n					var value = materialDefaultAttributeValues[ name ];\r\n\r\n					if ( value !== undefined ) {\r\n\r\n						switch ( value.length ) {\r\n\r\n							case 2:\r\n								_gl.vertexAttrib2fv( programAttribute, value );\r\n								break;\r\n\r\n							case 3:\r\n								_gl.vertexAttrib3fv( programAttribute, value );\r\n								break;\r\n\r\n							case 4:\r\n								_gl.vertexAttrib4fv( programAttribute, value );\r\n								break;\r\n\r\n							default:\r\n								_gl.vertexAttrib1fv( programAttribute, value );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		state.disableUnusedAttributes();\r\n\r\n	}\r\n\r\n	// Sorting\r\n\r\n	function numericalSort ( a, b ) {\r\n\r\n		return b[ 0 ] - a[ 0 ];\r\n\r\n	}\r\n\r\n	function painterSortStable ( a, b ) {\r\n\r\n		if ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n			return a.object.renderOrder - b.object.renderOrder;\r\n\r\n		} else if ( a.material.id !== b.material.id ) {\r\n\r\n			return a.material.id - b.material.id;\r\n\r\n		} else if ( a.z !== b.z ) {\r\n\r\n			return a.z - b.z;\r\n\r\n		} else {\r\n\r\n			return a.id - b.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function reversePainterSortStable ( a, b ) {\r\n\r\n		if ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n			return a.object.renderOrder - b.object.renderOrder;\r\n\r\n		} if ( a.z !== b.z ) {\r\n\r\n			return b.z - a.z;\r\n\r\n		} else {\r\n\r\n			return a.id - b.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Rendering\r\n\r\n	this.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n		if ( camera instanceof THREE.Camera === false ) {\r\n\r\n			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var fog = scene.fog;\r\n\r\n		// reset caching for this frame\r\n\r\n		_currentGeometryProgram = '';\r\n		_currentMaterialId = - 1;\r\n		_currentCamera = null;\r\n		_lightsNeedUpdate = true;\r\n\r\n		// update scene graph\r\n\r\n		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n		// update camera matrices and frustum\r\n\r\n		if ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n		camera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n		_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n		lights.length = 0;\r\n\r\n		opaqueObjectsLastIndex = -1;\r\n		transparentObjectsLastIndex = -1;\r\n\r\n		opaqueImmediateObjectsLastIndex = -1;\r\n		transparentImmediateObjectsLastIndex = -1;\r\n\r\n		sprites.length = 0;\r\n		lensFlares.length = 0;\r\n\r\n		projectObject( scene );\r\n\r\n		opaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n		transparentObjects.length = transparentObjectsLastIndex + 1;\r\n\r\n		opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;\r\n		transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;\r\n\r\n		if ( _this.sortObjects === true ) {\r\n\r\n			opaqueObjects.sort( painterSortStable );\r\n			transparentObjects.sort( reversePainterSortStable );\r\n\r\n		}\r\n\r\n		//\r\n\r\n		shadowMap.render( scene, camera );\r\n\r\n		//\r\n\r\n		_infoRender.calls = 0;\r\n		_infoRender.vertices = 0;\r\n		_infoRender.faces = 0;\r\n		_infoRender.points = 0;\r\n\r\n		this.setRenderTarget( renderTarget );\r\n\r\n		if ( this.autoClear || forceClear ) {\r\n\r\n			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( scene.overrideMaterial ) {\r\n\r\n			var overrideMaterial = scene.overrideMaterial;\r\n\r\n			renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );\r\n			renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );\r\n\r\n			renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );\r\n			renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );\r\n\r\n		} else {\r\n\r\n			// opaque pass (front-to-back order)\r\n\r\n			state.setBlending( THREE.NoBlending );\r\n\r\n			renderObjects( opaqueObjects, camera, lights, fog );\r\n			renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );\r\n\r\n			// transparent pass (back-to-front order)\r\n\r\n			renderObjects( transparentObjects, camera, lights, fog );\r\n			renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );\r\n\r\n		}\r\n\r\n		// custom render plugins (post pass)\r\n\r\n		spritePlugin.render( scene, camera );\r\n		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n		// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\r\n			updateRenderTargetMipmap( renderTarget );\r\n\r\n		}\r\n\r\n		// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n		state.setDepthTest( true );\r\n		state.setDepthWrite( true );\r\n		state.setColorWrite( true );\r\n\r\n		// _gl.finish();\r\n\r\n	};\r\n\r\n	function pushImmediateRenderItem( object ) {\r\n\r\n		var array, index;\r\n\r\n		// allocate the next position in the appropriate array\r\n\r\n		if ( object.material.transparent ) {\r\n\r\n			array = transparentImmediateObjects;\r\n			index = ++ transparentImmediateObjectsLastIndex;\r\n\r\n		} else {\r\n\r\n			array = opaqueImmediateObjects;\r\n			index = ++ opaqueImmediateObjectsLastIndex;\r\n\r\n		}\r\n\r\n		// recycle existing position or grow the array\r\n\r\n		if ( index < array.length ) {\r\n\r\n			array[ index ] = object;\r\n\r\n		} else {\r\n\r\n			// assert( index === array.length );\r\n			array.push( object );\r\n\r\n		}\r\n\r\n\r\n	}\r\n\r\n	function pushRenderItem( object, geometry, material, z, group ) {\r\n\r\n		var array, index;\r\n\r\n		// allocate the next position in the appropriate array\r\n\r\n		if ( material.transparent ) {\r\n\r\n			array = transparentObjects;\r\n			index = ++ transparentObjectsLastIndex;\r\n\r\n		} else {\r\n\r\n			array = opaqueObjects;\r\n			index = ++ opaqueObjectsLastIndex;\r\n\r\n		}\r\n\r\n		// recycle existing render item or grow the array\r\n\r\n		var renderItem = array[ index ];\r\n\r\n		if ( renderItem !== undefined ) {\r\n\r\n			renderItem.id = object.id;\r\n			renderItem.object = object;\r\n			renderItem.geometry = geometry;\r\n			renderItem.material = material;\r\n			renderItem.z = _vector3.z;\r\n			renderItem.group = group;\r\n\r\n		} else {\r\n\r\n			renderItem = {\r\n				id: object.id,\r\n				object: object,\r\n				geometry: geometry,\r\n				material: material,\r\n				z: _vector3.z,\r\n				group: group\r\n			};\r\n\r\n			// assert( index === array.length );\r\n			array.push( renderItem );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function projectObject( object ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		if ( object instanceof THREE.Light ) {\r\n\r\n			lights.push( object );\r\n\r\n		} else if ( object instanceof THREE.Sprite ) {\r\n\r\n			sprites.push( object );\r\n\r\n		} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n			lensFlares.push( object );\r\n\r\n		} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n			pushImmediateRenderItem( object );\r\n\r\n		} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\r\n			if ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n				object.skeleton.update();\r\n\r\n			}\r\n\r\n			if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n				var material = object.material;\r\n\r\n				if ( material.visible === true ) {\r\n\r\n					if ( _this.sortObjects === true ) {\r\n\r\n						_vector3.setFromMatrixPosition( object.matrixWorld );\r\n						_vector3.applyProjection( _projScreenMatrix );\r\n\r\n					}\r\n\r\n					var geometry = objects.update( object );\r\n\r\n					if ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n						var groups = geometry.groups;\r\n						var materials = material.materials;\r\n\r\n						for ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n							var group = groups[ i ];\r\n							var groupMaterial = materials[ group.materialIndex ];\r\n\r\n							if ( groupMaterial.visible === true ) {\r\n\r\n								pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						pushRenderItem( object, geometry, material, _vector3.z );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var children = object.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			projectObject( children[ i ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {\r\n\r\n		for ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n			var renderItem = renderList[ i ];\r\n\r\n			var object = renderItem.object;\r\n			var geometry = renderItem.geometry;\r\n			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n			var group = renderItem.group;\r\n\r\n			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n			_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {\r\n\r\n		var material = overrideMaterial;\r\n\r\n		for ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n			var object = renderList[ i ];\r\n\r\n			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n			if ( overrideMaterial === undefined ) material = object.material;\r\n\r\n			setMaterial( material );\r\n\r\n			var program = setProgram( camera, lights, fog, material, object );\r\n\r\n			_currentGeometryProgram = '';\r\n\r\n			object.render( function ( object ) {\r\n\r\n				_this.renderBufferImmediate( object, program, material );\r\n\r\n			} );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function initMaterial( material, lights, fog, object ) {\r\n\r\n		var materialProperties = properties.get( material );\r\n\r\n		var parameters = programCache.getParameters( material, lights, fog, object );\r\n		var code = programCache.getProgramCode( material, parameters );\r\n\r\n		var program = materialProperties.program;\r\n		var programChange = true;\r\n\r\n		if ( program === undefined ) {\r\n\r\n			// new material\r\n			material.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n		} else if ( program.code !== code ) {\r\n\r\n			// changed glsl or parameters\r\n			releaseMaterialProgramReference( material );\r\n\r\n		} else if ( parameters.shaderID !== undefined ) {\r\n\r\n			// same glsl and uniform list\r\n			return;\r\n\r\n		} else {\r\n\r\n			// only rebuild uniform list\r\n			programChange = false;\r\n\r\n		}\r\n\r\n		if ( programChange ) {\r\n\r\n			if ( parameters.shaderID ) {\r\n\r\n				var shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\r\n				materialProperties.__webglShader = {\r\n					name: material.type,\r\n					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n					vertexShader: shader.vertexShader,\r\n					fragmentShader: shader.fragmentShader\r\n				};\r\n\r\n			} else {\r\n\r\n				materialProperties.__webglShader = {\r\n					name: material.type,\r\n					uniforms: material.uniforms,\r\n					vertexShader: material.vertexShader,\r\n					fragmentShader: material.fragmentShader\r\n				};\r\n\r\n			}\r\n\r\n			material.__webglShader = materialProperties.__webglShader;\r\n\r\n			program = programCache.acquireProgram( material, parameters, code );\r\n\r\n			materialProperties.program = program;\r\n			material.program = program;\r\n\r\n		}\r\n\r\n		var attributes = program.getAttributes();\r\n\r\n		if ( material.morphTargets ) {\r\n\r\n			material.numSupportedMorphTargets = 0;\r\n\r\n			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n				if ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\r\n					material.numSupportedMorphTargets ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( material.morphNormals ) {\r\n\r\n			material.numSupportedMorphNormals = 0;\r\n\r\n			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n				if ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\r\n					material.numSupportedMorphNormals ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		materialProperties.uniformsList = [];\r\n\r\n		var uniformLocations = materialProperties.program.getUniforms();\r\n\r\n		for ( var u in materialProperties.__webglShader.uniforms ) {\r\n\r\n			var location = uniformLocations[ u ];\r\n\r\n			if ( location ) {\r\n\r\n				materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setMaterial( material ) {\r\n\r\n		setMaterialFaces( material );\r\n\r\n		if ( material.transparent === true ) {\r\n\r\n			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );\r\n\r\n		} else {\r\n\r\n			state.setBlending( THREE.NoBlending );\r\n\r\n		}\r\n\r\n		state.setDepthFunc( material.depthFunc );\r\n		state.setDepthTest( material.depthTest );\r\n		state.setDepthWrite( material.depthWrite );\r\n		state.setColorWrite( material.colorWrite );\r\n		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n	}\r\n\r\n	function setMaterialFaces( material ) {\r\n\r\n		material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );\r\n		state.setFlipSided( material.side === THREE.BackSide );\r\n\r\n	}\r\n\r\n	function setProgram( camera, lights, fog, material, object ) {\r\n\r\n		_usedTextureUnits = 0;\r\n\r\n		var materialProperties = properties.get( material );\r\n\r\n		if ( material.needsUpdate || ! materialProperties.program ) {\r\n\r\n			initMaterial( material, lights, fog, object );\r\n			material.needsUpdate = false;\r\n\r\n		}\r\n\r\n		var refreshProgram = false;\r\n		var refreshMaterial = false;\r\n		var refreshLights = false;\r\n\r\n		var program = materialProperties.program,\r\n			p_uniforms = program.getUniforms(),\r\n			m_uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n		if ( program.id !== _currentProgram ) {\r\n\r\n			_gl.useProgram( program.program );\r\n			_currentProgram = program.id;\r\n\r\n			refreshProgram = true;\r\n			refreshMaterial = true;\r\n			refreshLights = true;\r\n\r\n		}\r\n\r\n		if ( material.id !== _currentMaterialId ) {\r\n\r\n			if ( _currentMaterialId === - 1 ) refreshLights = true;\r\n			_currentMaterialId = material.id;\r\n\r\n			refreshMaterial = true;\r\n\r\n		}\r\n\r\n		if ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n			if ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n			}\r\n\r\n\r\n			if ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n			// load material specific uniforms\r\n			// (shader material also gets them for the sake of genericity)\r\n\r\n			if ( material instanceof THREE.ShaderMaterial ||\r\n				 material instanceof THREE.MeshPhongMaterial ||\r\n				 material.envMap ) {\r\n\r\n				if ( p_uniforms.cameraPosition !== undefined ) {\r\n\r\n					_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshBasicMaterial ||\r\n				 material instanceof THREE.ShaderMaterial ||\r\n				 material.skinning ) {\r\n\r\n				if ( p_uniforms.viewMatrix !== undefined ) {\r\n\r\n					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// skinning uniforms must be set even if material didn't change\r\n		// auto-setting of texture unit for bone texture must go before other textures\r\n		// not sure why, but otherwise weird things happen\r\n\r\n		if ( material.skinning ) {\r\n\r\n			if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {\r\n\r\n				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\r\n			}\r\n\r\n			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {\r\n\r\n				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\r\n			}\r\n\r\n			if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n				if ( p_uniforms.boneTexture !== undefined ) {\r\n\r\n					var textureUnit = getTextureUnit();\r\n\r\n					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n					_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\r\n				}\r\n\r\n				if ( p_uniforms.boneTextureWidth !== undefined ) {\r\n\r\n					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\r\n				}\r\n\r\n				if ( p_uniforms.boneTextureHeight !== undefined ) {\r\n\r\n					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\r\n				}\r\n\r\n			} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\r\n				if ( p_uniforms.boneGlobalMatrices !== undefined ) {\r\n\r\n					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( refreshMaterial ) {\r\n\r\n			// refresh uniforms common to several materials\r\n\r\n			if ( fog && material.fog ) {\r\n\r\n				refreshUniformsFog( m_uniforms, fog );\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material.lights ) {\r\n\r\n				if ( _lightsNeedUpdate ) {\r\n\r\n					refreshLights = true;\r\n					setupLights( lights, camera );\r\n					_lightsNeedUpdate = false;\r\n\r\n				}\r\n\r\n				if ( refreshLights ) {\r\n\r\n					refreshUniformsLights( m_uniforms, _lights );\r\n					markUniformsLightsNeedsUpdate( m_uniforms, true );\r\n\r\n				} else {\r\n\r\n					markUniformsLightsNeedsUpdate( m_uniforms, false );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshBasicMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n				refreshUniformsCommon( m_uniforms, material );\r\n\r\n			}\r\n\r\n			// refresh single material specific uniforms\r\n\r\n			if ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n				refreshUniformsLine( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n				refreshUniformsLine( m_uniforms, material );\r\n				refreshUniformsDash( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.PointsMaterial ) {\r\n\r\n				refreshUniformsParticle( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n				refreshUniformsPhong( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n				m_uniforms.mNear.value = camera.near;\r\n				m_uniforms.mFar.value = camera.far;\r\n				m_uniforms.opacity.value = material.opacity;\r\n\r\n			} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n				m_uniforms.opacity.value = material.opacity;\r\n\r\n			}\r\n\r\n			if ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n				refreshUniformsShadow( m_uniforms, lights );\r\n\r\n			}\r\n\r\n			// load common uniforms\r\n\r\n			loadUniformsGeneric( materialProperties.uniformsList );\r\n\r\n		}\r\n\r\n		loadUniformsMatrices( p_uniforms, object );\r\n\r\n		if ( p_uniforms.modelMatrix !== undefined ) {\r\n\r\n			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n		}\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n	// Uniforms (refresh uniforms objects)\r\n\r\n	function refreshUniformsCommon ( uniforms, material ) {\r\n\r\n		uniforms.opacity.value = material.opacity;\r\n\r\n		uniforms.diffuse.value = material.color;\r\n\r\n		if ( material.emissive ) {\r\n\r\n			uniforms.emissive.value = material.emissive;\r\n\r\n		}\r\n\r\n		uniforms.map.value = material.map;\r\n		uniforms.specularMap.value = material.specularMap;\r\n		uniforms.alphaMap.value = material.alphaMap;\r\n\r\n		if ( material.aoMap ) {\r\n\r\n			uniforms.aoMap.value = material.aoMap;\r\n			uniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n		}\r\n\r\n		// uv repeat and offset setting priorities\r\n		// 1. color map\r\n		// 2. specular map\r\n		// 3. normal map\r\n		// 4. bump map\r\n		// 5. alpha map\r\n		// 6. emissive map\r\n\r\n		var uvScaleMap;\r\n\r\n		if ( material.map ) {\r\n\r\n			uvScaleMap = material.map;\r\n\r\n		} else if ( material.specularMap ) {\r\n\r\n			uvScaleMap = material.specularMap;\r\n\r\n		} else if ( material.displacementMap ) {\r\n\r\n			uvScaleMap = material.displacementMap;\r\n\r\n		} else if ( material.normalMap ) {\r\n\r\n			uvScaleMap = material.normalMap;\r\n\r\n		} else if ( material.bumpMap ) {\r\n\r\n			uvScaleMap = material.bumpMap;\r\n\r\n		} else if ( material.alphaMap ) {\r\n\r\n			uvScaleMap = material.alphaMap;\r\n\r\n		} else if ( material.emissiveMap ) {\r\n\r\n			uvScaleMap = material.emissiveMap;\r\n\r\n		}\r\n\r\n		if ( uvScaleMap !== undefined ) {\r\n\r\n			var offset = uvScaleMap.offset;\r\n			var repeat = uvScaleMap.repeat;\r\n\r\n			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n		}\r\n\r\n		uniforms.envMap.value = material.envMap;\r\n		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n		uniforms.reflectivity.value = material.reflectivity;\r\n		uniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n	}\r\n\r\n	function refreshUniformsLine ( uniforms, material ) {\r\n\r\n		uniforms.diffuse.value = material.color;\r\n		uniforms.opacity.value = material.opacity;\r\n\r\n	}\r\n\r\n	function refreshUniformsDash ( uniforms, material ) {\r\n\r\n		uniforms.dashSize.value = material.dashSize;\r\n		uniforms.totalSize.value = material.dashSize + material.gapSize;\r\n		uniforms.scale.value = material.scale;\r\n\r\n	}\r\n\r\n	function refreshUniformsParticle ( uniforms, material ) {\r\n\r\n		uniforms.psColor.value = material.color;\r\n		uniforms.opacity.value = material.opacity;\r\n		uniforms.size.value = material.size;\r\n		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n		uniforms.map.value = material.map;\r\n\r\n		if ( material.map !== null ) {\r\n\r\n			var offset = material.map.offset;\r\n			var repeat = material.map.repeat;\r\n\r\n			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsFog ( uniforms, fog ) {\r\n\r\n		uniforms.fogColor.value = fog.color;\r\n\r\n		if ( fog instanceof THREE.Fog ) {\r\n\r\n			uniforms.fogNear.value = fog.near;\r\n			uniforms.fogFar.value = fog.far;\r\n\r\n		} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n			uniforms.fogDensity.value = fog.density;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsPhong ( uniforms, material ) {\r\n\r\n		uniforms.specular.value = material.specular;\r\n		uniforms.shininess.value = material.shininess;\r\n\r\n		if ( material.lightMap ) {\r\n\r\n			uniforms.lightMap.value = material.lightMap;\r\n			uniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n		}\r\n\r\n		if ( material.emissiveMap ) {\r\n\r\n			uniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n		}\r\n\r\n		if ( material.bumpMap ) {\r\n\r\n			uniforms.bumpMap.value = material.bumpMap;\r\n			uniforms.bumpScale.value = material.bumpScale;\r\n\r\n		}\r\n\r\n		if ( material.normalMap ) {\r\n\r\n			uniforms.normalMap.value = material.normalMap;\r\n			uniforms.normalScale.value.copy( material.normalScale );\r\n\r\n		}\r\n\r\n		if ( material.displacementMap ) {\r\n\r\n			uniforms.displacementMap.value = material.displacementMap;\r\n			uniforms.displacementScale.value = material.displacementScale;\r\n			uniforms.displacementBias.value = material.displacementBias;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsLights ( uniforms, lights ) {\r\n\r\n		uniforms.ambientLightColor.value = lights.ambient;\r\n\r\n		uniforms.directionalLightColor.value = lights.directional.colors;\r\n		uniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n		uniforms.pointLightColor.value = lights.point.colors;\r\n		uniforms.pointLightPosition.value = lights.point.positions;\r\n		uniforms.pointLightDistance.value = lights.point.distances;\r\n		uniforms.pointLightDecay.value = lights.point.decays;\r\n\r\n		uniforms.spotLightColor.value = lights.spot.colors;\r\n		uniforms.spotLightPosition.value = lights.spot.positions;\r\n		uniforms.spotLightDistance.value = lights.spot.distances;\r\n		uniforms.spotLightDirection.value = lights.spot.directions;\r\n		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n		uniforms.spotLightExponent.value = lights.spot.exponents;\r\n		uniforms.spotLightDecay.value = lights.spot.decays;\r\n\r\n		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n		uniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n	}\r\n\r\n	// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n	function markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n		uniforms.ambientLightColor.needsUpdate = value;\r\n\r\n		uniforms.directionalLightColor.needsUpdate = value;\r\n		uniforms.directionalLightDirection.needsUpdate = value;\r\n\r\n		uniforms.pointLightColor.needsUpdate = value;\r\n		uniforms.pointLightPosition.needsUpdate = value;\r\n		uniforms.pointLightDistance.needsUpdate = value;\r\n		uniforms.pointLightDecay.needsUpdate = value;\r\n\r\n		uniforms.spotLightColor.needsUpdate = value;\r\n		uniforms.spotLightPosition.needsUpdate = value;\r\n		uniforms.spotLightDistance.needsUpdate = value;\r\n		uniforms.spotLightDirection.needsUpdate = value;\r\n		uniforms.spotLightAngleCos.needsUpdate = value;\r\n		uniforms.spotLightExponent.needsUpdate = value;\r\n		uniforms.spotLightDecay.needsUpdate = value;\r\n\r\n		uniforms.hemisphereLightSkyColor.needsUpdate = value;\r\n		uniforms.hemisphereLightGroundColor.needsUpdate = value;\r\n		uniforms.hemisphereLightDirection.needsUpdate = value;\r\n\r\n	}\r\n\r\n	function refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n		if ( uniforms.shadowMatrix ) {\r\n\r\n			var j = 0;\r\n\r\n			for ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n				var light = lights[ i ];\r\n\r\n				if ( ! light.castShadow ) continue;\r\n\r\n				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {\r\n\r\n					uniforms.shadowMap.value[ j ] = light.shadowMap;\r\n					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n					uniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n					j ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Uniforms (load to GPU)\r\n\r\n	function loadUniformsMatrices ( uniforms, object ) {\r\n\r\n		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );\r\n\r\n		if ( uniforms.normalMatrix ) {\r\n\r\n			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function getTextureUnit() {\r\n\r\n		var textureUnit = _usedTextureUnits;\r\n\r\n		if ( textureUnit >= capabilities.maxTextures ) {\r\n\r\n			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\r\n		}\r\n\r\n		_usedTextureUnits += 1;\r\n\r\n		return textureUnit;\r\n\r\n	}\r\n\r\n	function loadUniformsGeneric ( uniforms ) {\r\n\r\n		var texture, textureUnit;\r\n\r\n		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n			var uniform = uniforms[ j ][ 0 ];\r\n\r\n			// needsUpdate property is not added to all uniforms.\r\n			if ( uniform.needsUpdate === false ) continue;\r\n\r\n			var type = uniform.type;\r\n			var value = uniform.value;\r\n			var location = uniforms[ j ][ 1 ];\r\n\r\n			switch ( type ) {\r\n\r\n				case '1i':\r\n					_gl.uniform1i( location, value );\r\n					break;\r\n\r\n				case '1f':\r\n					_gl.uniform1f( location, value );\r\n					break;\r\n\r\n				case '2f':\r\n					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n					break;\r\n\r\n				case '3f':\r\n					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n					break;\r\n\r\n				case '4f':\r\n					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n					break;\r\n\r\n				case '1iv':\r\n					_gl.uniform1iv( location, value );\r\n					break;\r\n\r\n				case '3iv':\r\n					_gl.uniform3iv( location, value );\r\n					break;\r\n\r\n				case '1fv':\r\n					_gl.uniform1fv( location, value );\r\n					break;\r\n\r\n				case '2fv':\r\n					_gl.uniform2fv( location, value );\r\n					break;\r\n\r\n				case '3fv':\r\n					_gl.uniform3fv( location, value );\r\n					break;\r\n\r\n				case '4fv':\r\n					_gl.uniform4fv( location, value );\r\n					break;\r\n\r\n				case 'Matrix3fv':\r\n					_gl.uniformMatrix3fv( location, false, value );\r\n					break;\r\n\r\n				case 'Matrix4fv':\r\n					_gl.uniformMatrix4fv( location, false, value );\r\n					break;\r\n\r\n				//\r\n\r\n				case 'i':\r\n\r\n					// single integer\r\n					_gl.uniform1i( location, value );\r\n\r\n					break;\r\n\r\n				case 'f':\r\n\r\n					// single float\r\n					_gl.uniform1f( location, value );\r\n\r\n					break;\r\n\r\n				case 'v2':\r\n\r\n					// single THREE.Vector2\r\n					_gl.uniform2f( location, value.x, value.y );\r\n\r\n					break;\r\n\r\n				case 'v3':\r\n\r\n					// single THREE.Vector3\r\n					_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n					break;\r\n\r\n				case 'v4':\r\n\r\n					// single THREE.Vector4\r\n					_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n					break;\r\n\r\n				case 'c':\r\n\r\n					// single THREE.Color\r\n					_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n					break;\r\n\r\n				case 'iv1':\r\n\r\n					// flat array of integers (JS or typed array)\r\n					_gl.uniform1iv( location, value );\r\n\r\n					break;\r\n\r\n				case 'iv':\r\n\r\n					// flat array of integers with 3 x N size (JS or typed array)\r\n					_gl.uniform3iv( location, value );\r\n\r\n					break;\r\n\r\n				case 'fv1':\r\n\r\n					// flat array of floats (JS or typed array)\r\n					_gl.uniform1fv( location, value );\r\n\r\n					break;\r\n\r\n				case 'fv':\r\n\r\n					// flat array of floats with 3 x N size (JS or typed array)\r\n					_gl.uniform3fv( location, value );\r\n\r\n					break;\r\n\r\n				case 'v2v':\r\n\r\n					// array of THREE.Vector2\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 2 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {\r\n\r\n						uniform._array[ i2 + 0 ] = value[ i ].x;\r\n						uniform._array[ i2 + 1 ] = value[ i ].y;\r\n\r\n					}\r\n\r\n					_gl.uniform2fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'v3v':\r\n\r\n					// array of THREE.Vector3\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 3 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {\r\n\r\n						uniform._array[ i3 + 0 ] = value[ i ].x;\r\n						uniform._array[ i3 + 1 ] = value[ i ].y;\r\n						uniform._array[ i3 + 2 ] = value[ i ].z;\r\n\r\n					}\r\n\r\n					_gl.uniform3fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'v4v':\r\n\r\n					// array of THREE.Vector4\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 4 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {\r\n\r\n						uniform._array[ i4 + 0 ] = value[ i ].x;\r\n						uniform._array[ i4 + 1 ] = value[ i ].y;\r\n						uniform._array[ i4 + 2 ] = value[ i ].z;\r\n						uniform._array[ i4 + 3 ] = value[ i ].w;\r\n\r\n					}\r\n\r\n					_gl.uniform4fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'm3':\r\n\r\n					// single THREE.Matrix3\r\n					_gl.uniformMatrix3fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm3v':\r\n\r\n					// array of THREE.Matrix3\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 9 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\r\n					}\r\n\r\n					_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'm4':\r\n\r\n					// single THREE.Matrix4\r\n					_gl.uniformMatrix4fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm4v':\r\n\r\n					// array of THREE.Matrix4\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 16 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n					}\r\n\r\n					_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n					break;\r\n\r\n				case 't':\r\n\r\n					// single THREE.Texture (2d or cube)\r\n\r\n					texture = value;\r\n					textureUnit = getTextureUnit();\r\n\r\n					_gl.uniform1i( location, textureUnit );\r\n\r\n					if ( ! texture ) continue;\r\n\r\n					if ( texture instanceof THREE.CubeTexture ||\r\n						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\r\n						// CompressedTexture can have Array in image :/\r\n\r\n						setCubeTexture( texture, textureUnit );\r\n\r\n					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n						setCubeTextureDynamic( texture, textureUnit );\r\n\r\n					} else {\r\n\r\n						_this.setTexture( texture, textureUnit );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'tv':\r\n\r\n					// array of THREE.Texture (2d)\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = [];\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n						uniform._array[ i ] = getTextureUnit();\r\n\r\n					}\r\n\r\n					_gl.uniform1iv( location, uniform._array );\r\n\r\n					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n						texture = uniform.value[ i ];\r\n						textureUnit = uniform._array[ i ];\r\n\r\n						if ( ! texture ) continue;\r\n\r\n						_this.setTexture( texture, textureUnit );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setColorLinear( array, offset, color, intensity ) {\r\n\r\n		array[ offset + 0 ] = color.r * intensity;\r\n		array[ offset + 1 ] = color.g * intensity;\r\n		array[ offset + 2 ] = color.b * intensity;\r\n\r\n	}\r\n\r\n	function setupLights ( lights, camera ) {\r\n\r\n		var l, ll, light,\r\n		r = 0, g = 0, b = 0,\r\n		color, skyColor, groundColor,\r\n		intensity,\r\n		distance,\r\n\r\n		zlights = _lights,\r\n\r\n		viewMatrix = camera.matrixWorldInverse,\r\n\r\n		dirColors = zlights.directional.colors,\r\n		dirPositions = zlights.directional.positions,\r\n\r\n		pointColors = zlights.point.colors,\r\n		pointPositions = zlights.point.positions,\r\n		pointDistances = zlights.point.distances,\r\n		pointDecays = zlights.point.decays,\r\n\r\n		spotColors = zlights.spot.colors,\r\n		spotPositions = zlights.spot.positions,\r\n		spotDistances = zlights.spot.distances,\r\n		spotDirections = zlights.spot.directions,\r\n		spotAnglesCos = zlights.spot.anglesCos,\r\n		spotExponents = zlights.spot.exponents,\r\n		spotDecays = zlights.spot.decays,\r\n\r\n		hemiSkyColors = zlights.hemi.skyColors,\r\n		hemiGroundColors = zlights.hemi.groundColors,\r\n		hemiPositions = zlights.hemi.positions,\r\n\r\n		dirLength = 0,\r\n		pointLength = 0,\r\n		spotLength = 0,\r\n		hemiLength = 0,\r\n\r\n		dirCount = 0,\r\n		pointCount = 0,\r\n		spotCount = 0,\r\n		hemiCount = 0,\r\n\r\n		dirOffset = 0,\r\n		pointOffset = 0,\r\n		spotOffset = 0,\r\n		hemiOffset = 0;\r\n\r\n		for ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			light = lights[ l ];\r\n\r\n			if ( light.onlyShadow ) continue;\r\n\r\n			color = light.color;\r\n			intensity = light.intensity;\r\n			distance = light.distance;\r\n\r\n			if ( light instanceof THREE.AmbientLight ) {\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				r += color.r;\r\n				g += color.g;\r\n				b += color.b;\r\n\r\n			} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n				dirCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				_direction.setFromMatrixPosition( light.matrixWorld );\r\n				_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n				_direction.sub( _vector3 );\r\n				_direction.transformDirection( viewMatrix );\r\n\r\n				dirOffset = dirLength * 3;\r\n\r\n				dirPositions[ dirOffset + 0 ] = _direction.x;\r\n				dirPositions[ dirOffset + 1 ] = _direction.y;\r\n				dirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n				setColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n				dirLength += 1;\r\n\r\n			} else if ( light instanceof THREE.PointLight ) {\r\n\r\n				pointCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				pointOffset = pointLength * 3;\r\n\r\n				setColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n				_vector3.setFromMatrixPosition( light.matrixWorld );\r\n				_vector3.applyMatrix4( viewMatrix );\r\n\r\n				pointPositions[ pointOffset + 0 ] = _vector3.x;\r\n				pointPositions[ pointOffset + 1 ] = _vector3.y;\r\n				pointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n				// distance is 0 if decay is 0, because there is no attenuation at all.\r\n				pointDistances[ pointLength ] = distance;\r\n				pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n				pointLength += 1;\r\n\r\n			} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n				spotCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				spotOffset = spotLength * 3;\r\n\r\n				setColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n				_direction.setFromMatrixPosition( light.matrixWorld );\r\n				_vector3.copy( _direction ).applyMatrix4( viewMatrix );\r\n\r\n				spotPositions[ spotOffset + 0 ] = _vector3.x;\r\n				spotPositions[ spotOffset + 1 ] = _vector3.y;\r\n				spotPositions[ spotOffset + 2 ] = _vector3.z;\r\n\r\n				spotDistances[ spotLength ] = distance;\r\n\r\n				_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n				_direction.sub( _vector3 );\r\n				_direction.transformDirection( viewMatrix );\r\n\r\n				spotDirections[ spotOffset + 0 ] = _direction.x;\r\n				spotDirections[ spotOffset + 1 ] = _direction.y;\r\n				spotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n				spotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n				spotExponents[ spotLength ] = light.exponent;\r\n				spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n				spotLength += 1;\r\n\r\n			} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n				hemiCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				_direction.setFromMatrixPosition( light.matrixWorld );\r\n				_direction.transformDirection( viewMatrix );\r\n\r\n				hemiOffset = hemiLength * 3;\r\n\r\n				hemiPositions[ hemiOffset + 0 ] = _direction.x;\r\n				hemiPositions[ hemiOffset + 1 ] = _direction.y;\r\n				hemiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n				skyColor = light.color;\r\n				groundColor = light.groundColor;\r\n\r\n				setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n				setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n				hemiLength += 1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// null eventual remains from removed lights\r\n		// (this is to avoid if in shader)\r\n\r\n		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\r\n		zlights.directional.length = dirLength;\r\n		zlights.point.length = pointLength;\r\n		zlights.spot.length = spotLength;\r\n		zlights.hemi.length = hemiLength;\r\n\r\n		zlights.ambient[ 0 ] = r;\r\n		zlights.ambient[ 1 ] = g;\r\n		zlights.ambient[ 2 ] = b;\r\n\r\n	}\r\n\r\n	// GL state setting\r\n\r\n	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n		if ( cullFace === THREE.CullFaceNone ) {\r\n\r\n			state.disable( _gl.CULL_FACE );\r\n\r\n		} else {\r\n\r\n			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n				_gl.frontFace( _gl.CW );\r\n\r\n			} else {\r\n\r\n				_gl.frontFace( _gl.CCW );\r\n\r\n			}\r\n\r\n			if ( cullFace === THREE.CullFaceBack ) {\r\n\r\n				_gl.cullFace( _gl.BACK );\r\n\r\n			} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n				_gl.cullFace( _gl.FRONT );\r\n\r\n			} else {\r\n\r\n				_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n			}\r\n\r\n			state.enable( _gl.CULL_FACE );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Textures\r\n\r\n	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n		var extension;\r\n\r\n		if ( isImagePowerOfTwo ) {\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n		} else {\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );\r\n\r\n			}\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n		if ( extension ) {\r\n\r\n			if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n			if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\r\n			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\r\n				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n				properties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function uploadTexture( textureProperties, texture, slot ) {\r\n\r\n		if ( textureProperties.__webglInit === undefined ) {\r\n\r\n			textureProperties.__webglInit = true;\r\n\r\n			texture.__webglInit = true;\r\n\r\n			texture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n			textureProperties.__webglTexture = _gl.createTexture();\r\n\r\n			_infoMemory.textures ++;\r\n\r\n		}\r\n\r\n		state.activeTexture( _gl.TEXTURE0 + slot );\r\n		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n		texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\r\n		var image = texture.image,\r\n		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n		glFormat = paramThreeToGL( texture.format ),\r\n		glType = paramThreeToGL( texture.type );\r\n\r\n		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n		var mipmap, mipmaps = texture.mipmaps;\r\n\r\n		if ( texture instanceof THREE.DataTexture ) {\r\n\r\n			// use manually created mipmaps if available\r\n			// if there are no manual mipmaps\r\n			// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n					mipmap = mipmaps[ i ];\r\n					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n				}\r\n\r\n				texture.generateMipmaps = false;\r\n\r\n			} else {\r\n\r\n				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n			}\r\n\r\n		} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n				mipmap = mipmaps[ i ];\r\n\r\n				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n					} else {\r\n\r\n						console.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// regular Texture (image, video, canvas)\r\n\r\n			// use manually created mipmaps if available\r\n			// if there are no manual mipmaps\r\n			// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n					mipmap = mipmaps[ i ];\r\n					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n				}\r\n\r\n				texture.generateMipmaps = false;\r\n\r\n			} else {\r\n\r\n				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n		textureProperties.__version = texture.version;\r\n\r\n		if ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n	}\r\n\r\n	this.setTexture = function ( texture, slot ) {\r\n\r\n		var textureProperties = properties.get( texture );\r\n\r\n		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n			var image = texture.image;\r\n\r\n			if ( image === undefined ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n				return;\r\n\r\n			}\r\n\r\n			if ( image.complete === false ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n				return;\r\n\r\n			}\r\n\r\n			uploadTexture( textureProperties, texture, slot );\r\n			return;\r\n\r\n		}\r\n\r\n		state.activeTexture( _gl.TEXTURE0 + slot );\r\n		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n	};\r\n\r\n	function clampToMaxSize ( image, maxSize ) {\r\n\r\n		if ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n			// Warning: Scaling through the canvas will only work with images that use\r\n			// premultiplied alpha.\r\n\r\n			var scale = maxSize / Math.max( image.width, image.height );\r\n\r\n			var canvas = document.createElement( 'canvas' );\r\n			canvas.width = Math.floor( image.width * scale );\r\n			canvas.height = Math.floor( image.height * scale );\r\n\r\n			var context = canvas.getContext( '2d' );\r\n			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n			return canvas;\r\n\r\n		}\r\n\r\n		return image;\r\n\r\n	}\r\n\r\n	function setCubeTexture ( texture, slot ) {\r\n\r\n		var textureProperties = properties.get( texture );\r\n\r\n		if ( texture.image.length === 6 ) {\r\n\r\n			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n				if ( ! textureProperties.__image__webglTextureCube ) {\r\n\r\n					texture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n					textureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\r\n					_infoMemory.textures ++;\r\n\r\n				}\r\n\r\n				state.activeTexture( _gl.TEXTURE0 + slot );\r\n				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n				var isCompressed = texture instanceof THREE.CompressedTexture;\r\n				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n				var cubeImage = [];\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\r\n					} else {\r\n\r\n						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n					}\r\n\r\n				}\r\n\r\n				var image = cubeImage[ 0 ],\r\n				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n				glFormat = paramThreeToGL( texture.format ),\r\n				glType = paramThreeToGL( texture.type );\r\n\r\n				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					if ( ! isCompressed ) {\r\n\r\n						if ( isDataTexture ) {\r\n\r\n							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n						} else {\r\n\r\n							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						var mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n							mipmap = mipmaps[ j ];\r\n\r\n							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n								} else {\r\n\r\n									console.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\r\n								}\r\n\r\n							} else {\r\n\r\n								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				if ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n				}\r\n\r\n				textureProperties.__version = texture.version;\r\n\r\n				if ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n			} else {\r\n\r\n				state.activeTexture( _gl.TEXTURE0 + slot );\r\n				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setCubeTextureDynamic ( texture, slot ) {\r\n\r\n		state.activeTexture( _gl.TEXTURE0 + slot );\r\n		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\r\n	}\r\n\r\n	// Render targets\r\n\r\n	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );\r\n\r\n	}\r\n\r\n	function setupRenderBuffer ( renderbuffer, renderTarget ) {\r\n\r\n		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		/* For some reason this is not working. Defaulting to RGBA4.\r\n		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n		*/\r\n\r\n		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		} else {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setRenderTarget = function ( renderTarget ) {\r\n\r\n		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\r\n			var renderTargetProperties = properties.get( renderTarget );\r\n\r\n			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n			renderTargetProperties.__webglTexture = _gl.createTexture();\r\n\r\n			_infoMemory.textures ++;\r\n\r\n			// Setup texture, create render and frame buffers\r\n\r\n			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n				glFormat = paramThreeToGL( renderTarget.format ),\r\n				glType = paramThreeToGL( renderTarget.type );\r\n\r\n			if ( isCube ) {\r\n\r\n				renderTargetProperties.__webglFramebuffer = [];\r\n				renderTargetProperties.__webglRenderbuffer = [];\r\n\r\n				state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );\r\n\r\n				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n					renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n					state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n					setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n				}\r\n\r\n				if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n			} else {\r\n\r\n				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n				if ( renderTarget.shareDepthFrom ) {\r\n\r\n					renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n				} else {\r\n\r\n					renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n				}\r\n\r\n				state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );\r\n				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n				setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n				if ( renderTarget.shareDepthFrom ) {\r\n\r\n					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );\r\n\r\n					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );\r\n\r\n				}\r\n\r\n				if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n			}\r\n\r\n			// Release everything\r\n\r\n			if ( isCube ) {\r\n\r\n				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n			} else {\r\n\r\n				state.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n			}\r\n\r\n			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n		}\r\n\r\n		var framebuffer, width, height, vx, vy;\r\n\r\n		if ( renderTarget ) {\r\n\r\n			var renderTargetProperties = properties.get( renderTarget );\r\n\r\n			if ( isCube ) {\r\n\r\n				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n			} else {\r\n\r\n				framebuffer = renderTargetProperties.__webglFramebuffer;\r\n\r\n			}\r\n\r\n			width = renderTarget.width;\r\n			height = renderTarget.height;\r\n\r\n			vx = 0;\r\n			vy = 0;\r\n\r\n		} else {\r\n\r\n			framebuffer = null;\r\n\r\n			width = _viewportWidth;\r\n			height = _viewportHeight;\r\n\r\n			vx = _viewportX;\r\n			vy = _viewportY;\r\n\r\n		}\r\n\r\n		if ( framebuffer !== _currentFramebuffer ) {\r\n\r\n			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n			_gl.viewport( vx, vy, width, height );\r\n\r\n			_currentFramebuffer = framebuffer;\r\n\r\n		}\r\n\r\n		_currentWidth = width;\r\n		_currentHeight = height;\r\n\r\n	};\r\n\r\n	this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {\r\n\r\n		if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {\r\n\r\n			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n			return;\r\n\r\n		}\r\n\r\n		if ( properties.get( renderTarget ).__webglFramebuffer ) {\r\n\r\n			if ( renderTarget.format !== THREE.RGBAFormat ) {\r\n\r\n				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );\r\n				return;\r\n\r\n			}\r\n\r\n			var restore = false;\r\n\r\n			if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {\r\n\r\n				_gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );\r\n\r\n				restore = true;\r\n\r\n			}\r\n\r\n			if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n				_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );\r\n\r\n			} else {\r\n\r\n				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n			}\r\n\r\n			if ( restore ) {\r\n\r\n				_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );\r\n			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n		} else {\r\n\r\n			state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );\r\n			_gl.generateMipmap( _gl.TEXTURE_2D );\r\n			state.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Fallback filters for non-power-of-2 textures\r\n\r\n	function filterFallback ( f ) {\r\n\r\n		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n			return _gl.NEAREST;\r\n\r\n		}\r\n\r\n		return _gl.LINEAR;\r\n\r\n	}\r\n\r\n	// Map three.js constants to WebGL constants\r\n\r\n	function paramThreeToGL ( p ) {\r\n\r\n		var extension;\r\n\r\n		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n		if ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n		if ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n		if ( p === THREE.ByteType ) return _gl.BYTE;\r\n		if ( p === THREE.ShortType ) return _gl.SHORT;\r\n		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n		if ( p === THREE.IntType ) return _gl.INT;\r\n		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n		if ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n		extension = extensions.get( 'OES_texture_half_float' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n		}\r\n\r\n		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n		if ( p === THREE.RGBFormat ) return _gl.RGB;\r\n		if ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n		if ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n		if ( p === THREE.OneFactor ) return _gl.ONE;\r\n		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n		}\r\n\r\n		return 0;\r\n\r\n	}\r\n\r\n	// DEPRECATED\r\n\r\n	this.supportsFloatTextures = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n		return extensions.get( 'OES_texture_float' );\r\n\r\n	};\r\n\r\n	this.supportsHalfFloatTextures = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n		return extensions.get( 'OES_texture_half_float' );\r\n\r\n	};\r\n\r\n	this.supportsStandardDerivatives = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n		return extensions.get( 'OES_standard_derivatives' );\r\n\r\n	};\r\n\r\n	this.supportsCompressedTextureS3TC = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n		return extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n	};\r\n\r\n	this.supportsCompressedTexturePVRTC = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n	};\r\n\r\n	this.supportsBlendMinMax = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n		return extensions.get( 'EXT_blend_minmax' );\r\n\r\n	};\r\n\r\n	this.supportsVertexTextures = function () {\r\n\r\n		return capabilities.vertexTextures;\r\n\r\n	};\r\n\r\n	this.supportsInstancedArrays = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n		return extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n	};\r\n\r\n	//\r\n\r\n	this.initMaterial = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\r\n	};\r\n\r\n	this.addPrePlugin = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\r\n	};\r\n\r\n	this.addPostPlugin = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\r\n	};\r\n\r\n	this.updateShadowMap = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\r\n	};\r\n\r\n	Object.defineProperties( this, {\r\n		shadowMapEnabled: {\r\n			get: function () {\r\n\r\n				return shadowMap.enabled;\r\n\r\n			},\r\n			set: function ( value ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n				shadowMap.enabled = value;\r\n\r\n			}\r\n		},\r\n		shadowMapType: {\r\n			get: function () {\r\n\r\n				return shadowMap.type;\r\n\r\n			},\r\n			set: function ( value ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n				shadowMap.type = value;\r\n\r\n			}\r\n		},\r\n		shadowMapCullFace: {\r\n			get: function () {\r\n\r\n				return shadowMap.cullFace;\r\n\r\n			},\r\n			set: function ( value ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n				shadowMap.cullFace = value;\r\n\r\n			}\r\n		},\r\n		shadowMapDebug: {\r\n			get: function () {\r\n\r\n				return shadowMap.debug;\r\n\r\n			},\r\n			set: function ( value ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );\r\n				shadowMap.debug = value;\r\n\r\n			}\r\n		}\r\n	} );\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.width = width;\r\n	this.height = height;\r\n\r\n	options = options || {};\r\n\r\n	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n	this.offset = new THREE.Vector2( 0, 0 );\r\n	this.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n	this.generateMipmaps = true;\r\n\r\n	this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n	constructor: THREE.WebGLRenderTarget,\r\n\r\n	setSize: function ( width, height ) {\r\n\r\n		if ( this.width !== width || this.height !== height ) {\r\n\r\n			this.width = width;\r\n			this.height = height;\r\n\r\n			this.dispose();\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.width = source.width;\r\n		this.height = source.height;\r\n\r\n		this.wrapS = source.wrapS;\r\n		this.wrapT = source.wrapT;\r\n\r\n		this.magFilter = source.magFilter;\r\n		this.minFilter = source.minFilter;\r\n\r\n		this.anisotropy = source.anisotropy;\r\n\r\n		this.offset.copy( source.offset );\r\n		this.repeat.copy( source.repeat );\r\n\r\n		this.format = source.format;\r\n		this.type = source.type;\r\n\r\n		this.depthBuffer = source.depthBuffer;\r\n		this.stencilBuffer = source.stencilBuffer;\r\n\r\n		this.generateMipmaps = source.generateMipmaps;\r\n\r\n		this.shareDepthFrom = source.shareDepthFrom;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n	THREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n	var mode;\r\n\r\n	function setMode( value ) {\r\n\r\n		mode = value;\r\n\r\n	}\r\n\r\n	function render( start, count ) {\r\n\r\n		_gl.drawArrays( mode, start, count );\r\n\r\n		_infoRender.calls ++;\r\n		_infoRender.vertices += count;\r\n		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n	}\r\n\r\n	function renderInstances( geometry ) {\r\n\r\n		var extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var position = geometry.attributes.position;\r\n\r\n		if ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );\r\n\r\n		} else {\r\n\r\n			extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setMode = setMode;\r\n	this.render = render;\r\n	this.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n	var mode;\r\n\r\n	function setMode( value ) {\r\n\r\n		mode = value;\r\n\r\n	}\r\n\r\n	var type, size;\r\n\r\n	function setIndex( index ) {\r\n\r\n		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n			type = _gl.UNSIGNED_INT;\r\n			size = 4;\r\n\r\n		} else {\r\n\r\n			type = _gl.UNSIGNED_SHORT;\r\n			size = 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function render( start, count ) {\r\n\r\n		_gl.drawElements( mode, count, type, start * size );\r\n\r\n		_infoRender.calls ++;\r\n		_infoRender.vertices += count;\r\n		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n	}\r\n\r\n	function renderInstances( geometry ) {\r\n\r\n		var extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var index = geometry.index;\r\n\r\n		extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );\r\n\r\n	}\r\n\r\n	this.setMode = setMode;\r\n	this.setIndex = setIndex;\r\n	this.render = render;\r\n	this.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n	var extensions = {};\r\n\r\n	this.get = function ( name ) {\r\n\r\n		if ( extensions[ name ] !== undefined ) {\r\n\r\n			return extensions[ name ];\r\n\r\n		}\r\n\r\n		var extension;\r\n\r\n		switch ( name ) {\r\n\r\n			case 'EXT_texture_filter_anisotropic':\r\n				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_s3tc':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_pvrtc':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n				break;\r\n\r\n			default:\r\n				extension = gl.getExtension( name );\r\n\r\n		}\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n		}\r\n\r\n		extensions[ name ] = extension;\r\n\r\n		return extension;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLCapabilities.js\r\n\r\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\r\n	function getMaxPrecision( precision ) {\r\n\r\n		if ( precision === 'highp' ) {\r\n\r\n			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\r\n				return 'highp';\r\n\r\n			}\r\n\r\n			precision = 'mediump';\r\n\r\n		}\r\n\r\n		if ( precision === 'mediump' ) {\r\n\r\n			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\r\n				return 'mediump';\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return 'lowp';\r\n\r\n	}\r\n\r\n	this.getMaxPrecision = getMaxPrecision;\r\n\r\n	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\r\n	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\r\n	this.vertexTextures = this.maxVertexTextures > 0;\r\n	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\r\n	var _maxPrecision = getMaxPrecision( this.precision );\r\n\r\n	if ( _maxPrecision !== this.precision ) {\r\n\r\n		console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n		this.precision = _maxPrecision;\r\n\r\n	}\r\n\r\n	if ( this.logarithmicDepthBuffer ) {\r\n\r\n		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLGeometries.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\r\n	var geometries = {};\r\n\r\n	function get( object ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( geometries[ geometry.id ] !== undefined ) {\r\n\r\n			return geometries[ geometry.id ];\r\n\r\n		}\r\n\r\n		geometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n		var buffergeometry;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			buffergeometry = geometry;\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			if ( geometry._bufferGeometry === undefined ) {\r\n\r\n				geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\r\n			}\r\n\r\n			buffergeometry = geometry._bufferGeometry;\r\n\r\n		}\r\n\r\n		geometries[ geometry.id ] = buffergeometry;\r\n\r\n		info.memory.geometries ++;\r\n\r\n		return buffergeometry;\r\n\r\n	}\r\n\r\n	function onGeometryDispose( event ) {\r\n\r\n		var geometry = event.target;\r\n		var buffergeometry = geometries[ geometry.id ];\r\n\r\n		deleteAttributes( buffergeometry.attributes );\r\n\r\n		geometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n		delete geometries[ geometry.id ];\r\n\r\n		var property = properties.get( geometry );\r\n		if ( property.wireframe ) deleteAttribute( property.wireframe );\r\n\r\n		info.memory.geometries --;\r\n\r\n	}\r\n\r\n	function getAttributeBuffer( attribute ) {\r\n\r\n		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			return properties.get( attribute.data ).__webglBuffer;\r\n\r\n		}\r\n\r\n		return properties.get( attribute ).__webglBuffer;\r\n\r\n	}\r\n\r\n	function deleteAttribute( attribute ) {\r\n\r\n		var buffer = getAttributeBuffer( attribute );\r\n\r\n		if ( buffer !== undefined ) {\r\n\r\n			gl.deleteBuffer( buffer );\r\n			removeAttributeBuffer( attribute );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function deleteAttributes( attributes ) {\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			deleteAttribute( attributes[ name ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function removeAttributeBuffer( attribute ) {\r\n\r\n		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			properties.delete( attribute.data );\r\n\r\n		} else {\r\n\r\n			properties.delete( attribute );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.get = get;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLObjects.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\r\n	var geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\r\n	//\r\n\r\n	function update( object ) {\r\n\r\n		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\r\n		var geometry = geometries.get( object );\r\n\r\n		if ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n			geometry.updateFromObject( object );\r\n\r\n		}\r\n\r\n		var index = geometry.index;\r\n		var attributes = geometry.attributes;\r\n\r\n		if ( index !== null ) {\r\n\r\n			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n		}\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\r\n		}\r\n\r\n		// morph targets\r\n\r\n		var morphAttributes = geometry.morphAttributes;\r\n\r\n		for ( var name in morphAttributes ) {\r\n\r\n			var array = morphAttributes[ name ];\r\n\r\n			for ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n				updateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	}\r\n\r\n	function updateAttribute( attribute, bufferType ) {\r\n\r\n		var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\r\n		var attributeProperties = properties.get( data );\r\n\r\n		if ( attributeProperties.__webglBuffer === undefined ) {\r\n\r\n			createBuffer( attributeProperties, data, bufferType );\r\n\r\n		} else if ( attributeProperties.version !== data.version ) {\r\n\r\n			updateBuffer( attributeProperties, data, bufferType );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function createBuffer( attributeProperties, data, bufferType ) {\r\n\r\n		attributeProperties.__webglBuffer = gl.createBuffer();\r\n		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\r\n		gl.bufferData( bufferType, data.array, usage );\r\n\r\n		attributeProperties.version = data.version;\r\n\r\n	}\r\n\r\n	function updateBuffer( attributeProperties, data, bufferType ) {\r\n\r\n		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n		if ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\r\n			// Not using update ranges\r\n\r\n			gl.bufferSubData( bufferType, 0, data.array );\r\n\r\n		} else if ( data.updateRange.count === 0 ) {\r\n\r\n			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n		} else {\r\n\r\n			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\r\n			data.updateRange.count = 0; // reset range\r\n\r\n		}\r\n\r\n		attributeProperties.version = data.version;\r\n\r\n	}\r\n\r\n	function getAttributeBuffer( attribute ) {\r\n\r\n		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			return properties.get( attribute.data ).__webglBuffer;\r\n\r\n		}\r\n\r\n		return properties.get( attribute ).__webglBuffer;\r\n\r\n	}\r\n\r\n	function getWireframeAttribute( geometry ) {\r\n\r\n		var property = properties.get( geometry );\r\n\r\n		if ( property.wireframe !== undefined ) {\r\n\r\n			return property.wireframe;\r\n\r\n		}\r\n\r\n		var indices = [];\r\n\r\n		var index = geometry.index;\r\n		var attributes = geometry.attributes;\r\n		var position = attributes.position;\r\n\r\n		// console.time( 'wireframe' );\r\n\r\n		if ( index !== null ) {\r\n\r\n			var edges = {};\r\n			var array = index.array;\r\n\r\n			for ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n				var a = array[ i + 0 ];\r\n				var b = array[ i + 1 ];\r\n				var c = array[ i + 2 ];\r\n\r\n				if ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n				if ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n				if ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			var array = attributes.position.array;\r\n\r\n			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\r\n				var a = i + 0;\r\n				var b = i + 1;\r\n				var c = i + 2;\r\n\r\n				indices.push( a, b, b, c, c, a );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// console.timeEnd( 'wireframe' );\r\n\r\n		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n		var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\r\n		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n		property.wireframe = attribute;\r\n\r\n		return attribute;\r\n\r\n	}\r\n\r\n	function checkEdge( edges, a, b ) {\r\n\r\n		if ( a > b ) {\r\n\r\n			var tmp = a;\r\n			a = b;\r\n			b = tmp;\r\n\r\n		}\r\n\r\n		var list = edges[ a ];\r\n\r\n		if ( list === undefined ) {\r\n\r\n			edges[ a ] = [ b ];\r\n			return true;\r\n\r\n		} else if ( list.indexOf( b ) === -1 ) {\r\n\r\n			list.push( b );\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	}\r\n\r\n	this.getAttributeBuffer = getAttributeBuffer;\r\n	this.getWireframeAttribute = getWireframeAttribute;\r\n\r\n	this.update = update;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n	var programIdCount = 0;\r\n\r\n	function generateDefines( defines ) {\r\n\r\n		var chunks = [];\r\n\r\n		for ( var name in defines ) {\r\n\r\n			var value = defines[ name ];\r\n\r\n			if ( value === false ) continue;\r\n\r\n			chunks.push( '#define ' + name + ' ' + value );\r\n\r\n		}\r\n\r\n		return chunks.join( '\\n' );\r\n\r\n	}\r\n\r\n	function fetchUniformLocations( gl, program, identifiers ) {\r\n\r\n		var uniforms = {};\r\n\r\n		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\r\n		for ( var i = 0; i < n; i ++ ) {\r\n\r\n			var info = gl.getActiveUniform( program, i );\r\n			var name = info.name;\r\n			var location = gl.getUniformLocation( program, name );\r\n\r\n			// console.log(\"THREE.WebGLProgram: ACTIVE UNIFORM:\", name);\r\n\r\n			var suffixPos = name.lastIndexOf( '[0]' );\r\n			if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {\r\n\r\n				uniforms[ name.substr( 0, suffixPos ) ] = location;\r\n\r\n			}\r\n\r\n			uniforms[ name ] = location;\r\n\r\n		}\r\n\r\n		return uniforms;\r\n\r\n	}\r\n\r\n	function fetchAttributeLocations( gl, program, identifiers ) {\r\n\r\n		var attributes = {};\r\n\r\n		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\r\n		for ( var i = 0; i < n; i ++ ) {\r\n\r\n			var info = gl.getActiveAttrib( program, i );\r\n			var name = info.name;\r\n\r\n			// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\r\n			attributes[ name ] = gl.getAttribLocation( program, name );\r\n\r\n		}\r\n\r\n		return attributes;\r\n\r\n	}\r\n\r\n	function filterEmptyLine( string ) {\r\n\r\n		return string !== '';\r\n\r\n	}\r\n\r\n	return function WebGLProgram( renderer, code, material, parameters ) {\r\n\r\n		var gl = renderer.context;\r\n\r\n		var defines = material.defines;\r\n\r\n		var vertexShader = material.__webglShader.vertexShader;\r\n		var fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n		}\r\n\r\n		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n		if ( parameters.envMap ) {\r\n\r\n			switch ( material.envMap.mapping ) {\r\n\r\n				case THREE.CubeReflectionMapping:\r\n				case THREE.CubeRefractionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n					break;\r\n\r\n				case THREE.EquirectangularReflectionMapping:\r\n				case THREE.EquirectangularRefractionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n					break;\r\n\r\n				case THREE.SphericalReflectionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n					break;\r\n\r\n			}\r\n\r\n			switch ( material.envMap.mapping ) {\r\n\r\n				case THREE.CubeRefractionMapping:\r\n				case THREE.EquirectangularRefractionMapping:\r\n					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n					break;\r\n\r\n			}\r\n\r\n			switch ( material.combine ) {\r\n\r\n				case THREE.MultiplyOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n					break;\r\n\r\n				case THREE.MixOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n					break;\r\n\r\n				case THREE.AddOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n		// console.log( 'building new program ' );\r\n\r\n		//\r\n\r\n		var customDefines = generateDefines( defines );\r\n\r\n		//\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var prefixVertex, prefixFragment;\r\n\r\n		if ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n			prefixVertex = '';\r\n			prefixFragment = '';\r\n\r\n		} else {\r\n\r\n			prefixVertex = [\r\n\r\n				'precision ' + parameters.precision + ' float;',\r\n				'precision ' + parameters.precision + ' int;',\r\n\r\n				'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n				customDefines,\r\n\r\n				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n				renderer.gammaInput ? '#define GAMMA_INPUT' : '',\r\n				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n				'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n				'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n				'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n				parameters.map ? '#define USE_MAP' : '',\r\n				parameters.envMap ? '#define USE_ENVMAP' : '',\r\n				parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n				parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n				parameters.aoMap ? '#define USE_AOMAP' : '',\r\n				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n				parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n				parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n				parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n				parameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n				parameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n				parameters.skinning ? '#define USE_SKINNING' : '',\r\n				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n				parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\r\n				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\r\n				'uniform mat4 modelMatrix;',\r\n				'uniform mat4 modelViewMatrix;',\r\n				'uniform mat4 projectionMatrix;',\r\n				'uniform mat4 viewMatrix;',\r\n				'uniform mat3 normalMatrix;',\r\n				'uniform vec3 cameraPosition;',\r\n\r\n				'attribute vec3 position;',\r\n				'attribute vec3 normal;',\r\n				'attribute vec2 uv;',\r\n\r\n				'#ifdef USE_COLOR',\r\n\r\n				'	attribute vec3 color;',\r\n\r\n				'#endif',\r\n\r\n				'#ifdef USE_MORPHTARGETS',\r\n\r\n				'	attribute vec3 morphTarget0;',\r\n				'	attribute vec3 morphTarget1;',\r\n				'	attribute vec3 morphTarget2;',\r\n				'	attribute vec3 morphTarget3;',\r\n\r\n				'	#ifdef USE_MORPHNORMALS',\r\n\r\n				'		attribute vec3 morphNormal0;',\r\n				'		attribute vec3 morphNormal1;',\r\n				'		attribute vec3 morphNormal2;',\r\n				'		attribute vec3 morphNormal3;',\r\n\r\n				'	#else',\r\n\r\n				'		attribute vec3 morphTarget4;',\r\n				'		attribute vec3 morphTarget5;',\r\n				'		attribute vec3 morphTarget6;',\r\n				'		attribute vec3 morphTarget7;',\r\n\r\n				'	#endif',\r\n\r\n				'#endif',\r\n\r\n				'#ifdef USE_SKINNING',\r\n\r\n				'	attribute vec4 skinIndex;',\r\n				'	attribute vec4 skinWeight;',\r\n\r\n				'#endif',\r\n\r\n				'\\n'\r\n\r\n			].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n			prefixFragment = [\r\n\r\n				parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\r\n				'precision ' + parameters.precision + ' float;',\r\n				'precision ' + parameters.precision + ' int;',\r\n\r\n				'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n				customDefines,\r\n\r\n				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n				'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n				renderer.gammaInput ? '#define GAMMA_INPUT' : '',\r\n				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n				'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n				parameters.map ? '#define USE_MAP' : '',\r\n				parameters.envMap ? '#define USE_ENVMAP' : '',\r\n				parameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n				parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n				parameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n				parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n				parameters.aoMap ? '#define USE_AOMAP' : '',\r\n				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n				parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n				parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n				parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n				parameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n				parameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n				parameters.metal ? '#define METAL' : '',\r\n				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n				parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\r\n				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n				'uniform mat4 viewMatrix;',\r\n				'uniform vec3 cameraPosition;',\r\n\r\n				'\\n'\r\n\r\n			].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n		}\r\n\r\n		var vertexGlsl = prefixVertex + vertexShader;\r\n		var fragmentGlsl = prefixFragment + fragmentShader;\r\n\r\n		var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n		var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\r\n		gl.attachShader( program, glVertexShader );\r\n		gl.attachShader( program, glFragmentShader );\r\n\r\n		// Force a particular attribute to index 0.\r\n\r\n		if ( material.index0AttributeName !== undefined ) {\r\n\r\n			gl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\r\n		} else if ( parameters.morphTargets === true ) {\r\n\r\n			// programs with morphTargets displace position out of attribute 0\r\n			gl.bindAttribLocation( program, 0, 'position' );\r\n\r\n		}\r\n\r\n		gl.linkProgram( program );\r\n\r\n		var programLog = gl.getProgramInfoLog( program );\r\n		var vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\r\n		var runnable = true;\r\n		var haveDiagnostics = true;\r\n\r\n		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\r\n			runnable = false;\r\n\r\n			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\r\n		} else if ( programLog !== '' ) {\r\n\r\n			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\r\n		} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\r\n			haveDiagnostics = false;\r\n\r\n		}\r\n\r\n		if ( haveDiagnostics ) {\r\n\r\n			this.diagnostics = {\r\n\r\n				runnable: runnable,\r\n				material: material,\r\n\r\n				programLog: programLog,\r\n\r\n				vertexShader: {\r\n\r\n					log: vertexLog,\r\n					prefix: prefixVertex\r\n\r\n				},\r\n\r\n				fragmentShader: {\r\n\r\n					log: fragmentLog,\r\n					prefix: prefixFragment\r\n\r\n				}\r\n\r\n			};\r\n\r\n		}\r\n\r\n		// clean up\r\n\r\n		gl.deleteShader( glVertexShader );\r\n		gl.deleteShader( glFragmentShader );\r\n\r\n		// set up caching for uniform locations\r\n\r\n		var cachedUniforms;\r\n\r\n		this.getUniforms = function() {\r\n\r\n			if ( cachedUniforms === undefined ) {\r\n\r\n				cachedUniforms = fetchUniformLocations( gl, program );\r\n\r\n			}\r\n\r\n			return cachedUniforms;\r\n\r\n		};\r\n\r\n		// set up caching for attribute locations\r\n\r\n		var cachedAttributes;\r\n\r\n		this.getAttributes = function() {\r\n\r\n			if ( cachedAttributes === undefined ) {\r\n\r\n				cachedAttributes = fetchAttributeLocations( gl, program );\r\n\r\n			}\r\n\r\n			return cachedAttributes;\r\n\r\n		};\r\n\r\n		// free resource\r\n\r\n		this.destroy = function() {\r\n\r\n			gl.deleteProgram( program );\r\n			this.program = undefined;\r\n\r\n		};\r\n\r\n		// DEPRECATED\r\n\r\n		Object.defineProperties( this, {\r\n\r\n			uniforms: {\r\n				get: function() {\r\n\r\n					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n					return this.getUniforms();\r\n\r\n				}\r\n			},\r\n\r\n			attributes: {\r\n				get: function() {\r\n\r\n					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n					return this.getAttributes();\r\n\r\n				}\r\n			}\r\n\r\n		} );\r\n\r\n\r\n		//\r\n\r\n		this.id = programIdCount ++;\r\n		this.code = code;\r\n		this.usedTimes = 1;\r\n		this.program = program;\r\n		this.vertexShader = glVertexShader;\r\n		this.fragmentShader = glFragmentShader;\r\n\r\n		return this;\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLPrograms.js\r\n\r\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\r\n	var programs = [];\r\n\r\n	var shaderIDs = {\r\n		MeshDepthMaterial: 'depth',\r\n		MeshNormalMaterial: 'normal',\r\n		MeshBasicMaterial: 'basic',\r\n		MeshLambertMaterial: 'lambert',\r\n		MeshPhongMaterial: 'phong',\r\n		LineBasicMaterial: 'basic',\r\n		LineDashedMaterial: 'dashed',\r\n		PointsMaterial: 'points'\r\n	};\r\n\r\n	var parameterNames = [\r\n		\"precision\", \"supportsVertexTextures\", \"map\", \"envMap\", \"envMapMode\",\r\n		\"lightMap\", \"aoMap\", \"emissiveMap\", \"bumpMap\", \"normalMap\", \"specularMap\",\r\n		\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n		\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n		\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n		\"maxMorphTargets\", \"maxMorphNormals\", \"maxDirLights\", \"maxPointLights\",\r\n		\"maxSpotLights\", \"maxHemiLights\", \"maxShadows\", \"shadowMapEnabled\",\r\n		\"shadowMapType\", \"shadowMapDebug\", \"alphaTest\", \"metal\", \"doubleSided\",\r\n		\"flipSided\"\r\n	];\r\n\r\n\r\n	function allocateBones ( object ) {\r\n\r\n		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n			return 1024;\r\n\r\n		} else {\r\n\r\n			// default for when object is not specified\r\n			// ( for example when prebuilding shader to be used with multiple objects )\r\n			//\r\n			//  - leave some extra space for other uniforms\r\n			//  - limit here is ANGLE's 254 max uniform vectors\r\n			//    (up to 54 should be safe)\r\n\r\n			var nVertexUniforms = capabilities.maxVertexUniforms;\r\n			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n			var maxBones = nVertexMatrices;\r\n\r\n			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n				maxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n				if ( maxBones < object.skeleton.bones.length ) {\r\n\r\n					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return maxBones;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function allocateLights( lights ) {\r\n\r\n		var dirLights = 0;\r\n		var pointLights = 0;\r\n		var spotLights = 0;\r\n		var hemiLights = 0;\r\n\r\n		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			var light = lights[ l ];\r\n\r\n			if ( light.onlyShadow || light.visible === false ) continue;\r\n\r\n			if ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n			if ( light instanceof THREE.PointLight ) pointLights ++;\r\n			if ( light instanceof THREE.SpotLight ) spotLights ++;\r\n			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\r\n		}\r\n\r\n		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\r\n	}\r\n\r\n	function allocateShadows( lights ) {\r\n\r\n		var maxShadows = 0;\r\n\r\n		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			var light = lights[ l ];\r\n\r\n			if ( ! light.castShadow ) continue;\r\n\r\n			if ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n			if ( light instanceof THREE.DirectionalLight ) maxShadows ++;\r\n\r\n		}\r\n\r\n		return maxShadows;\r\n\r\n	}\r\n\r\n	this.getParameters = function ( material, lights, fog, object ) {\r\n\r\n		var shaderID = shaderIDs[ material.type ];\r\n		// heuristics to create shader parameters according to lights in the scene\r\n		// (not to blow over maxLights budget)\r\n\r\n		var maxLightCount = allocateLights( lights );\r\n		var maxShadows = allocateShadows( lights );\r\n		var maxBones = allocateBones( object );\r\n		var precision = renderer.getPrecision();\r\n\r\n		if ( material.precision !== null ) {\r\n\r\n			precision = capabilities.getMaxPrecision( material.precision );\r\n\r\n			if ( precision !== material.precision ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var parameters = {\r\n\r\n			shaderID: shaderID,\r\n\r\n			precision: precision,\r\n			supportsVertexTextures: capabilities.vertexTextures,\r\n\r\n			map: !! material.map,\r\n			envMap: !! material.envMap,\r\n			envMapMode: material.envMap && material.envMap.mapping,\r\n			lightMap: !! material.lightMap,\r\n			aoMap: !! material.aoMap,\r\n			emissiveMap: !! material.emissiveMap,\r\n			bumpMap: !! material.bumpMap,\r\n			normalMap: !! material.normalMap,\r\n			displacementMap: !! material.displacementMap,\r\n			specularMap: !! material.specularMap,\r\n			alphaMap: !! material.alphaMap,\r\n\r\n			combine: material.combine,\r\n\r\n			vertexColors: material.vertexColors,\r\n\r\n			fog: fog,\r\n			useFog: material.fog,\r\n			fogExp: fog instanceof THREE.FogExp2,\r\n\r\n			flatShading: material.shading === THREE.FlatShading,\r\n\r\n			sizeAttenuation: material.sizeAttenuation,\r\n			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\r\n			skinning: material.skinning,\r\n			maxBones: maxBones,\r\n			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n			morphTargets: material.morphTargets,\r\n			morphNormals: material.morphNormals,\r\n			maxMorphTargets: renderer.maxMorphTargets,\r\n			maxMorphNormals: renderer.maxMorphNormals,\r\n\r\n			maxDirLights: maxLightCount.directional,\r\n			maxPointLights: maxLightCount.point,\r\n			maxSpotLights: maxLightCount.spot,\r\n			maxHemiLights: maxLightCount.hemi,\r\n\r\n			maxShadows: maxShadows,\r\n			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,\r\n			shadowMapType: renderer.shadowMap.type,\r\n			shadowMapDebug: renderer.shadowMap.debug,\r\n\r\n			alphaTest: material.alphaTest,\r\n			metal: material.metal,\r\n			doubleSided: material.side === THREE.DoubleSide,\r\n			flipSided: material.side === THREE.BackSide\r\n\r\n		};\r\n\r\n		return parameters;\r\n\r\n	};\r\n\r\n	this.getProgramCode = function ( material, parameters ) {\r\n\r\n		var chunks = [];\r\n\r\n		if ( parameters.shaderID ) {\r\n\r\n			chunks.push( parameters.shaderID );\r\n\r\n		} else {\r\n\r\n			chunks.push( material.fragmentShader );\r\n			chunks.push( material.vertexShader );\r\n\r\n		}\r\n\r\n		if ( material.defines !== undefined ) {\r\n\r\n			for ( var name in material.defines ) {\r\n\r\n				chunks.push( name );\r\n				chunks.push( material.defines[ name ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\r\n			var parameterName = parameterNames[ i ];\r\n			chunks.push( parameterName );\r\n			chunks.push( parameters[ parameterName ] );\r\n\r\n		}\r\n\r\n		return chunks.join();\r\n\r\n	};\r\n\r\n	this.acquireProgram = function ( material, parameters, code ) {\r\n\r\n		var program;\r\n\r\n		// Check if code has been already compiled\r\n		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\r\n			var programInfo = programs[ p ];\r\n\r\n			if ( programInfo.code === code ) {\r\n\r\n				program = programInfo;\r\n				++ program.usedTimes;\r\n\r\n				break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( program === undefined ) {\r\n\r\n			program = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n			programs.push( program );\r\n\r\n		}\r\n\r\n		return program;\r\n\r\n	};\r\n\r\n	this.releaseProgram = function( program ) {\r\n\r\n		if ( -- program.usedTimes === 0 ) {\r\n\r\n			// Remove from unordered set\r\n			var i = programs.indexOf( program );\r\n			programs[ i ] = programs[ programs.length - 1 ];\r\n			programs.pop();\r\n\r\n			// Free WebGL resources\r\n			program.destroy();\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Exposed for resource monitoring & error feedback via renderer.info:\r\n	this.programs = programs;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProperties.js\r\n\r\n/**\r\n* @author fordacious / fordacious.github.io\r\n*/\r\n\r\nTHREE.WebGLProperties = function () {\r\n\r\n	var properties = {};\r\n\r\n	this.get = function ( object ) {\r\n\r\n		var uuid = object.uuid;\r\n		var map = properties[ uuid ];\r\n\r\n		if ( map === undefined ) {\r\n\r\n			map = {};\r\n			properties[ uuid ] = map;\r\n\r\n		}\r\n\r\n		return map;\r\n\r\n	};\r\n\r\n	this.delete = function ( object ) {\r\n\r\n		delete properties[ object.uuid ];\r\n\r\n	};\r\n\r\n	this.clear = function () {\r\n\r\n		properties = {};\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n	var addLineNumbers = function ( string ) {\r\n\r\n		var lines = string.split( '\\n' );\r\n\r\n		for ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n		}\r\n\r\n		return lines.join( '\\n' );\r\n\r\n	};\r\n\r\n	return function WebGLShader( gl, type, string ) {\r\n\r\n		var shader = gl.createShader( type );\r\n\r\n		gl.shaderSource( shader, string );\r\n		gl.compileShader( shader );\r\n\r\n		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n			console.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n		}\r\n\r\n		if ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n		}\r\n\r\n		// --enable-privileged-webgl-extension\r\n		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n		return shader;\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShadowMap.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\r\n	var _gl = _renderer.context,\r\n	_state = _renderer.state,\r\n	_frustum = new THREE.Frustum(),\r\n	_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n	_min = new THREE.Vector3(),\r\n	_max = new THREE.Vector3(),\r\n\r\n	_matrixPosition = new THREE.Vector3(),\r\n\r\n	_renderList = [];\r\n\r\n	// init\r\n\r\n	var depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n	var _depthMaterial = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader\r\n	 } );\r\n\r\n	var _depthMaterialMorph = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader,\r\n		morphTargets: true\r\n	} );\r\n\r\n	var _depthMaterialSkin = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader,\r\n		skinning: true\r\n	} );\r\n\r\n	var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader,\r\n		morphTargets: true,\r\n		skinning: true\r\n	} );\r\n\r\n	_depthMaterial._shadowPass = true;\r\n	_depthMaterialMorph._shadowPass = true;\r\n	_depthMaterialSkin._shadowPass = true;\r\n	_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n	//\r\n\r\n	var scope = this;\r\n\r\n	this.enabled = false;\r\n\r\n	this.autoUpdate = true;\r\n	this.needsUpdate = false;\r\n\r\n	this.type = THREE.PCFShadowMap;\r\n	this.cullFace = THREE.CullFaceFront;\r\n\r\n	this.render = function ( scene, camera ) {\r\n\r\n		if ( scope.enabled === false ) return;\r\n		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\r\n		// set GL state for depth map\r\n\r\n		_gl.clearColor( 1, 1, 1, 1 );\r\n		_state.disable( _gl.BLEND );\r\n\r\n		_state.enable( _gl.CULL_FACE );\r\n		_gl.frontFace( _gl.CCW );\r\n\r\n		if ( scope.cullFace === THREE.CullFaceFront ) {\r\n\r\n			_gl.cullFace( _gl.FRONT );\r\n\r\n		} else {\r\n\r\n			_gl.cullFace( _gl.BACK );\r\n\r\n		}\r\n\r\n		_state.setDepthTest( true );\r\n\r\n		// render depth map\r\n\r\n		for ( var i = 0, il = _lights.length; i < il; i ++ ) {\r\n\r\n			var light = _lights[ i ];\r\n\r\n			if ( ! light.castShadow ) continue;\r\n\r\n			if ( ! light.shadowMap ) {\r\n\r\n				var shadowFilter = THREE.LinearFilter;\r\n\r\n				if ( scope.type === THREE.PCFSoftShadowMap ) {\r\n\r\n					shadowFilter = THREE.NearestFilter;\r\n\r\n				}\r\n\r\n				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n				light.shadowMatrix = new THREE.Matrix4();\r\n\r\n			}\r\n\r\n			if ( ! light.shadowCamera ) {\r\n\r\n				if ( light instanceof THREE.SpotLight ) {\r\n\r\n					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n				} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n				} else {\r\n\r\n					console.error( \"THREE.ShadowMapPlugin: Unsupported light type for shadow\", light );\r\n					continue;\r\n\r\n				}\r\n\r\n				scene.add( light.shadowCamera );\r\n\r\n				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n			}\r\n\r\n			if ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n				scene.add( light.cameraHelper );\r\n\r\n			}\r\n\r\n			var shadowMap = light.shadowMap;\r\n			var shadowMatrix = light.shadowMatrix;\r\n			var shadowCamera = light.shadowCamera;\r\n\r\n			//\r\n\r\n			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n			shadowCamera.lookAt( _matrixPosition );\r\n			shadowCamera.updateMatrixWorld();\r\n\r\n			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n			//\r\n\r\n			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n			if ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n			// compute shadow matrix\r\n\r\n			shadowMatrix.set(\r\n				0.5, 0.0, 0.0, 0.5,\r\n				0.0, 0.5, 0.0, 0.5,\r\n				0.0, 0.0, 0.5, 0.5,\r\n				0.0, 0.0, 0.0, 1.0\r\n			);\r\n\r\n			shadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n			// update camera matrices and frustum\r\n\r\n			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n			_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n			// render shadow map\r\n\r\n			_renderer.setRenderTarget( shadowMap );\r\n			_renderer.clear();\r\n\r\n			// set object matrices & frustum culling\r\n\r\n			_renderList.length = 0;\r\n\r\n			projectObject( scene, shadowCamera );\r\n\r\n\r\n			// render regular objects\r\n\r\n			for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n				var object = _renderList[ j ];\r\n				var geometry = _objects.update( object );\r\n				var material = object.material;\r\n\r\n				if ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n					var groups = geometry.groups;\r\n					var materials = material.materials;\r\n\r\n					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n						var group = groups[ k ];\r\n						var groupMaterial = materials[ group.materialIndex ];\r\n\r\n						if ( groupMaterial.visible === true ) {\r\n\r\n							_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore GL state\r\n\r\n		var clearColor = _renderer.getClearColor(),\r\n		clearAlpha = _renderer.getClearAlpha();\r\n\r\n		_renderer.setClearColor( clearColor, clearAlpha );\r\n		_state.enable( _gl.BLEND );\r\n\r\n		if ( scope.cullFace === THREE.CullFaceFront ) {\r\n\r\n			_gl.cullFace( _gl.BACK );\r\n\r\n		}\r\n\r\n		_renderer.resetGLState();\r\n\r\n		scope.needsUpdate = false;\r\n\r\n	};\r\n\r\n	function getDepthMaterial( object, material ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;\r\n		var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\r\n		var depthMaterial;\r\n\r\n		if ( object.customDepthMaterial ) {\r\n\r\n			depthMaterial = object.customDepthMaterial;\r\n\r\n		} else if ( useSkinning ) {\r\n\r\n			depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n		} else if ( useMorphing ) {\r\n\r\n			depthMaterial = _depthMaterialMorph;\r\n\r\n		} else {\r\n\r\n			depthMaterial = _depthMaterial;\r\n\r\n		}\r\n\r\n		depthMaterial.visible = material.visible;\r\n		depthMaterial.wireframe = material.wireframe;\r\n		depthMaterial.wireframeLinewidth = material.wireframeLinewidth;\r\n\r\n		return depthMaterial;\r\n\r\n	}\r\n\r\n	function projectObject( object, camera ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\r\n			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n				var material = object.material;\r\n\r\n				if ( material.visible === true ) {\r\n\r\n					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n					_renderList.push( object );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var children = object.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			projectObject( children[ i ], camera );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\r\n	var _this = this;\r\n\r\n	var newAttributes = new Uint8Array( 16 );\r\n	var enabledAttributes = new Uint8Array( 16 );\r\n\r\n	var capabilities = {};\r\n\r\n	var compressedTextureFormats = null;\r\n\r\n	var currentBlending = null;\r\n	var currentBlendEquation = null;\r\n	var currentBlendSrc = null;\r\n	var currentBlendDst = null;\r\n	var currentBlendEquationAlpha = null;\r\n	var currentBlendSrcAlpha = null;\r\n	var currentBlendDstAlpha = null;\r\n\r\n	var currentDepthFunc = null;\r\n	var currentDepthWrite = null;\r\n\r\n	var currentColorWrite = null;\r\n\r\n	var currentFlipSided = null;\r\n\r\n	var currentLineWidth = null;\r\n\r\n	var currentPolygonOffsetFactor = null;\r\n	var currentPolygonOffsetUnits = null;\r\n\r\n	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\r\n	var currentTextureSlot = undefined;\r\n	var currentBoundTextures = {};\r\n\r\n	this.init = function () {\r\n\r\n		gl.clearColor( 0, 0, 0, 1 );\r\n		gl.clearDepth( 1 );\r\n		gl.clearStencil( 0 );\r\n\r\n		this.enable( gl.DEPTH_TEST );\r\n		gl.depthFunc( gl.LEQUAL );\r\n\r\n		gl.frontFace( gl.CCW );\r\n		gl.cullFace( gl.BACK );\r\n		this.enable( gl.CULL_FACE );\r\n\r\n		this.enable( gl.BLEND );\r\n		gl.blendEquation( gl.FUNC_ADD );\r\n		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n	};\r\n\r\n	this.initAttributes = function () {\r\n\r\n		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n			newAttributes[ i ] = 0;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.enableAttribute = function ( attribute ) {\r\n\r\n		newAttributes[ attribute ] = 1;\r\n\r\n		if ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n			gl.enableVertexAttribArray( attribute );\r\n			enabledAttributes[ attribute ] = 1;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.disableUnusedAttributes = function () {\r\n\r\n		for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\r\n			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n				gl.disableVertexAttribArray( i );\r\n				enabledAttributes[ i ] = 0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.enable = function ( id ) {\r\n\r\n		if ( capabilities[ id ] !== true ) {\r\n\r\n			gl.enable( id );\r\n			capabilities[ id ] = true;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.disable = function ( id ) {\r\n\r\n		if ( capabilities[ id ] !== false ) {\r\n\r\n			gl.disable( id );\r\n			capabilities[ id ] = false;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.getCompressedTextureFormats = function () {\r\n\r\n		if ( compressedTextureFormats === null ) {\r\n\r\n			compressedTextureFormats = [];\r\n\r\n			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {\r\n\r\n				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n				for ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n					compressedTextureFormats.push( formats[ i ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return compressedTextureFormats;\r\n\r\n	};\r\n\r\n	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {\r\n\r\n		if ( blending !== currentBlending ) {\r\n\r\n			if ( blending === THREE.NoBlending ) {\r\n\r\n				this.disable( gl.BLEND );\r\n\r\n			} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n				this.enable( gl.BLEND );\r\n				gl.blendEquation( gl.FUNC_ADD );\r\n				gl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n			} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n				// TODO: Find blendFuncSeparate() combination\r\n\r\n				this.enable( gl.BLEND );\r\n				gl.blendEquation( gl.FUNC_ADD );\r\n				gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n			} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n				// TODO: Find blendFuncSeparate() combination\r\n\r\n				this.enable( gl.BLEND );\r\n				gl.blendEquation( gl.FUNC_ADD );\r\n				gl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n			} else if ( blending === THREE.CustomBlending ) {\r\n\r\n				this.enable( gl.BLEND );\r\n\r\n			} else {\r\n\r\n				this.enable( gl.BLEND );\r\n				gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n				gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n			}\r\n\r\n			currentBlending = blending;\r\n\r\n		}\r\n\r\n		if ( blending === THREE.CustomBlending ) {\r\n\r\n			blendEquationAlpha = blendEquationAlpha || blendEquation;\r\n			blendSrcAlpha = blendSrcAlpha || blendSrc;\r\n			blendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n				currentBlendEquation = blendEquation;\r\n				currentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n			}\r\n\r\n			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n				currentBlendSrc = blendSrc;\r\n				currentBlendDst = blendDst;\r\n				currentBlendSrcAlpha = blendSrcAlpha;\r\n				currentBlendDstAlpha = blendDstAlpha;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			currentBlendEquation = null;\r\n			currentBlendSrc = null;\r\n			currentBlendDst = null;\r\n			currentBlendEquationAlpha = null;\r\n			currentBlendSrcAlpha = null;\r\n			currentBlendDstAlpha = null;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthFunc = function ( depthFunc ) {\r\n\r\n		if ( currentDepthFunc !== depthFunc ) {\r\n\r\n			if ( depthFunc ) {\r\n\r\n				switch ( depthFunc ) {\r\n\r\n					case THREE.NeverDepth:\r\n\r\n						gl.depthFunc( gl.NEVER );\r\n						break;\r\n\r\n					case THREE.AlwaysDepth:\r\n\r\n						gl.depthFunc( gl.ALWAYS );\r\n						break;\r\n\r\n					case THREE.LessDepth:\r\n\r\n						gl.depthFunc( gl.LESS );\r\n						break;\r\n\r\n					case THREE.LessEqualDepth:\r\n\r\n						gl.depthFunc( gl.LEQUAL );\r\n						break;\r\n\r\n					case THREE.EqualDepth:\r\n\r\n						gl.depthFunc( gl.EQUAL );\r\n						break;\r\n\r\n					case THREE.GreaterEqualDepth:\r\n\r\n						gl.depthFunc( gl.GEQUAL );\r\n						break;\r\n\r\n					case THREE.GreaterDepth:\r\n\r\n						gl.depthFunc( gl.GREATER );\r\n						break;\r\n\r\n					case THREE.NotEqualDepth:\r\n\r\n						gl.depthFunc( gl.NOTEQUAL );\r\n						break;\r\n\r\n					default:\r\n\r\n						gl.depthFunc( gl.LEQUAL );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				gl.depthFunc( gl.LEQUAL );\r\n\r\n			}\r\n\r\n			currentDepthFunc = depthFunc;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthTest = function ( depthTest ) {\r\n\r\n		if ( depthTest ) {\r\n\r\n			this.enable( gl.DEPTH_TEST );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.DEPTH_TEST );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthWrite = function ( depthWrite ) {\r\n\r\n		if ( currentDepthWrite !== depthWrite ) {\r\n\r\n			gl.depthMask( depthWrite );\r\n			currentDepthWrite = depthWrite;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setColorWrite = function ( colorWrite ) {\r\n\r\n		if ( currentColorWrite !== colorWrite ) {\r\n\r\n			gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n			currentColorWrite = colorWrite;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setFlipSided = function ( flipSided ) {\r\n\r\n		if ( currentFlipSided !== flipSided ) {\r\n\r\n			if ( flipSided ) {\r\n\r\n				gl.frontFace( gl.CW );\r\n\r\n			} else {\r\n\r\n				gl.frontFace( gl.CCW );\r\n\r\n			}\r\n\r\n			currentFlipSided = flipSided;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setLineWidth = function ( width ) {\r\n\r\n		if ( width !== currentLineWidth ) {\r\n\r\n			gl.lineWidth( width );\r\n\r\n			currentLineWidth = width;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\r\n		if ( polygonOffset ) {\r\n\r\n			this.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n		}\r\n\r\n		if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\r\n			gl.polygonOffset( factor, units );\r\n\r\n			currentPolygonOffsetFactor = factor;\r\n			currentPolygonOffsetUnits = units;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setScissorTest = function ( scissorTest ) {\r\n\r\n		if ( scissorTest ) {\r\n\r\n			this.enable( gl.SCISSOR_TEST );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.SCISSOR_TEST );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// texture\r\n\r\n	this.activeTexture = function ( webglSlot ) {\r\n\r\n		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\r\n		if ( currentTextureSlot !== webglSlot ) {\r\n\r\n			gl.activeTexture( webglSlot );\r\n			currentTextureSlot = webglSlot;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.bindTexture = function ( webglType, webglTexture ) {\r\n\r\n		if ( currentTextureSlot === undefined ) {\r\n\r\n			_this.activeTexture();\r\n\r\n		}\r\n\r\n		var boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\r\n		if ( boundTexture === undefined ) {\r\n\r\n			boundTexture = { type: undefined, texture: undefined };\r\n			currentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\r\n		}\r\n\r\n		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\r\n			gl.bindTexture( webglType, webglTexture );\r\n\r\n			boundTexture.type = webglType;\r\n			boundTexture.texture = webglTexture;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.compressedTexImage2D = function () {\r\n\r\n		try {\r\n\r\n			gl.compressedTexImage2D.apply( gl, arguments );\r\n\r\n		} catch ( error ) {\r\n\r\n			console.error( error );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.texImage2D = function () {\r\n\r\n		try {\r\n\r\n			gl.texImage2D.apply( gl, arguments );\r\n\r\n		} catch ( error ) {\r\n\r\n			console.error( error );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	//\r\n\r\n	this.reset = function () {\r\n\r\n		for ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n			if ( enabledAttributes[ i ] === 1 ) {\r\n\r\n				gl.disableVertexAttribArray( i );\r\n				enabledAttributes[ i ] = 0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		capabilities = {};\r\n\r\n		compressedTextureFormats = null;\r\n\r\n		currentBlending = null;\r\n\r\n		currentDepthWrite = null;\r\n		currentColorWrite = null;\r\n\r\n		currentFlipSided = null;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n	var gl = renderer.context;\r\n	var state = renderer.state;\r\n\r\n	var vertexBuffer, elementBuffer;\r\n	var program, attributes, uniforms;\r\n	var hasVertexTexture;\r\n\r\n	var tempTexture, occlusionTexture;\r\n\r\n	var init = function () {\r\n\r\n		var vertices = new Float32Array( [\r\n			- 1, - 1,  0, 0,\r\n			 1, - 1,  1, 0,\r\n			 1,  1,  1, 1,\r\n			- 1,  1,  0, 1\r\n		] );\r\n\r\n		var faces = new Uint16Array( [\r\n			0, 1, 2,\r\n			0, 2, 3\r\n		] );\r\n\r\n		// buffers\r\n\r\n		vertexBuffer     = gl.createBuffer();\r\n		elementBuffer    = gl.createBuffer();\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n		// textures\r\n\r\n		tempTexture      = gl.createTexture();\r\n		occlusionTexture = gl.createTexture();\r\n\r\n		state.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\r\n		var shader;\r\n\r\n		if ( hasVertexTexture ) {\r\n\r\n			shader = {\r\n\r\n				vertexShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform vec3 screenPosition;\",\r\n					\"uniform vec2 scale;\",\r\n					\"uniform float rotation;\",\r\n\r\n					\"uniform sampler2D occlusionMap;\",\r\n\r\n					\"attribute vec2 position;\",\r\n					\"attribute vec2 uv;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n					\"varying float vVisibility;\",\r\n\r\n					\"void main() {\",\r\n\r\n						\"vUV = uv;\",\r\n\r\n						\"vec2 pos = position;\",\r\n\r\n						\"if( renderType == 2 ) {\",\r\n\r\n							\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n							\"vVisibility =        visibility.r / 9.0;\",\r\n							\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n							\"vVisibility *=       visibility.b / 9.0;\",\r\n							\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n							\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n							\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n						\"}\",\r\n\r\n						\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" ),\r\n\r\n				fragmentShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform sampler2D map;\",\r\n					\"uniform float opacity;\",\r\n					\"uniform vec3 color;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n					\"varying float vVisibility;\",\r\n\r\n					\"void main() {\",\r\n\r\n						// pink square\r\n\r\n						\"if( renderType == 0 ) {\",\r\n\r\n							\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n						// restore\r\n\r\n						\"} else if( renderType == 1 ) {\",\r\n\r\n							\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n						// flare\r\n\r\n						\"} else {\",\r\n\r\n							\"vec4 texture = texture2D( map, vUV );\",\r\n							\"texture.a *= opacity * vVisibility;\",\r\n							\"gl_FragColor = texture;\",\r\n							\"gl_FragColor.rgb *= color;\",\r\n\r\n						\"}\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" )\r\n\r\n			};\r\n\r\n		} else {\r\n\r\n			shader = {\r\n\r\n				vertexShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform vec3 screenPosition;\",\r\n					\"uniform vec2 scale;\",\r\n					\"uniform float rotation;\",\r\n\r\n					\"attribute vec2 position;\",\r\n					\"attribute vec2 uv;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n\r\n					\"void main() {\",\r\n\r\n						\"vUV = uv;\",\r\n\r\n						\"vec2 pos = position;\",\r\n\r\n						\"if( renderType == 2 ) {\",\r\n\r\n							\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n							\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n						\"}\",\r\n\r\n						\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" ),\r\n\r\n				fragmentShader: [\r\n\r\n					\"precision mediump float;\",\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform sampler2D map;\",\r\n					\"uniform sampler2D occlusionMap;\",\r\n					\"uniform float opacity;\",\r\n					\"uniform vec3 color;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n\r\n					\"void main() {\",\r\n\r\n						// pink square\r\n\r\n						\"if( renderType == 0 ) {\",\r\n\r\n							\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n						// restore\r\n\r\n						\"} else if( renderType == 1 ) {\",\r\n\r\n							\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n						// flare\r\n\r\n						\"} else {\",\r\n\r\n							\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n							\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n							\"vec4 texture = texture2D( map, vUV );\",\r\n							\"texture.a *= opacity * visibility;\",\r\n							\"gl_FragColor = texture;\",\r\n							\"gl_FragColor.rgb *= color;\",\r\n\r\n						\"}\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" )\r\n\r\n			};\r\n\r\n		}\r\n\r\n		program = createProgram( shader );\r\n\r\n		attributes = {\r\n			vertex: gl.getAttribLocation ( program, \"position\" ),\r\n			uv:     gl.getAttribLocation ( program, \"uv\" )\r\n		};\r\n\r\n		uniforms = {\r\n			renderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n			map:            gl.getUniformLocation( program, \"map\" ),\r\n			occlusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n			opacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n			color:          gl.getUniformLocation( program, \"color\" ),\r\n			scale:          gl.getUniformLocation( program, \"scale\" ),\r\n			rotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n			screenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n		};\r\n\r\n	};\r\n\r\n	/*\r\n	 * Render lens flares\r\n	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n	 *         reads these back and calculates occlusion.\r\n	 */\r\n\r\n	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n		if ( flares.length === 0 ) return;\r\n\r\n		var tempPosition = new THREE.Vector3();\r\n\r\n		var invAspect = viewportHeight / viewportWidth,\r\n			halfViewportWidth = viewportWidth * 0.5,\r\n			halfViewportHeight = viewportHeight * 0.5;\r\n\r\n		var size = 16 / viewportHeight,\r\n			scale = new THREE.Vector2( size * invAspect, size );\r\n\r\n		var screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n			screenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n		if ( program === undefined ) {\r\n\r\n			init();\r\n\r\n		}\r\n\r\n		gl.useProgram( program );\r\n\r\n		state.initAttributes();\r\n		state.enableAttribute( attributes.vertex );\r\n		state.enableAttribute( attributes.uv );\r\n		state.disableUnusedAttributes();\r\n\r\n		// loop through all lens flares to update their occlusion and positions\r\n		// setup gl and common used attribs/uniforms\r\n\r\n		gl.uniform1i( uniforms.occlusionMap, 0 );\r\n		gl.uniform1i( uniforms.map, 1 );\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n		state.disable( gl.CULL_FACE );\r\n		gl.depthMask( false );\r\n\r\n		for ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n			size = 16 / viewportHeight;\r\n			scale.set( size * invAspect, size );\r\n\r\n			// calc object screen position\r\n\r\n			var flare = flares[ i ];\r\n\r\n			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\r\n			tempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n			tempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n			// setup arrays for gl programs\r\n\r\n			screenPosition.copy( tempPosition );\r\n\r\n			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n			// screen cull\r\n\r\n			if ( hasVertexTexture || (\r\n				screenPositionPixels.x > 0 &&\r\n				screenPositionPixels.x < viewportWidth &&\r\n				screenPositionPixels.y > 0 &&\r\n				screenPositionPixels.y < viewportHeight ) ) {\r\n\r\n				// save current RGB to temp texture\r\n\r\n				state.activeTexture( gl.TEXTURE0 );\r\n				state.bindTexture( gl.TEXTURE_2D, null );\r\n				state.activeTexture( gl.TEXTURE1 );\r\n				state.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n				// render pink quad\r\n\r\n				gl.uniform1i( uniforms.renderType, 0 );\r\n				gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n				state.disable( gl.BLEND );\r\n				state.enable( gl.DEPTH_TEST );\r\n\r\n				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n				// copy result to occlusionMap\r\n\r\n				state.activeTexture( gl.TEXTURE0 );\r\n				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n				// restore graphics\r\n\r\n				gl.uniform1i( uniforms.renderType, 1 );\r\n				state.disable( gl.DEPTH_TEST );\r\n\r\n				state.activeTexture( gl.TEXTURE1 );\r\n				state.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n				// update object positions\r\n\r\n				flare.positionScreen.copy( screenPosition );\r\n\r\n				if ( flare.customUpdateCallback ) {\r\n\r\n					flare.customUpdateCallback( flare );\r\n\r\n				} else {\r\n\r\n					flare.updateLensFlares();\r\n\r\n				}\r\n\r\n				// render flares\r\n\r\n				gl.uniform1i( uniforms.renderType, 2 );\r\n				state.enable( gl.BLEND );\r\n\r\n				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n					var sprite = flare.lensFlares[ j ];\r\n\r\n					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n						screenPosition.x = sprite.x;\r\n						screenPosition.y = sprite.y;\r\n						screenPosition.z = sprite.z;\r\n\r\n						size = sprite.size * sprite.scale / viewportHeight;\r\n\r\n						scale.x = size * invAspect;\r\n						scale.y = size;\r\n\r\n						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n						gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n						gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n						gl.uniform1f( uniforms.opacity, sprite.opacity );\r\n						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n						renderer.setTexture( sprite.texture, 1 );\r\n\r\n						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore gl\r\n\r\n		state.enable( gl.CULL_FACE );\r\n		state.enable( gl.DEPTH_TEST );\r\n		gl.depthMask( true );\r\n\r\n		renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function createProgram ( shader ) {\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n		var vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n		var prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n		gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n		gl.compileShader( fragmentShader );\r\n		gl.compileShader( vertexShader );\r\n\r\n		gl.attachShader( program, fragmentShader );\r\n		gl.attachShader( program, vertexShader );\r\n\r\n		gl.linkProgram( program );\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n	var gl = renderer.context;\r\n	var state = renderer.state;\r\n\r\n	var vertexBuffer, elementBuffer;\r\n	var program, attributes, uniforms;\r\n\r\n	var texture;\r\n\r\n	// decompose matrixWorld\r\n\r\n	var spritePosition = new THREE.Vector3();\r\n	var spriteRotation = new THREE.Quaternion();\r\n	var spriteScale = new THREE.Vector3();\r\n\r\n	var init = function () {\r\n\r\n		var vertices = new Float32Array( [\r\n			- 0.5, - 0.5,  0, 0,\r\n			  0.5, - 0.5,  1, 0,\r\n			  0.5,   0.5,  1, 1,\r\n			- 0.5,   0.5,  0, 1\r\n		] );\r\n\r\n		var faces = new Uint16Array( [\r\n			0, 1, 2,\r\n			0, 2, 3\r\n		] );\r\n\r\n		vertexBuffer  = gl.createBuffer();\r\n		elementBuffer = gl.createBuffer();\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n		program = createProgram();\r\n\r\n		attributes = {\r\n			position:			gl.getAttribLocation ( program, 'position' ),\r\n			uv:					gl.getAttribLocation ( program, 'uv' )\r\n		};\r\n\r\n		uniforms = {\r\n			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),\r\n			uvScale:			gl.getUniformLocation( program, 'uvScale' ),\r\n\r\n			rotation:			gl.getUniformLocation( program, 'rotation' ),\r\n			scale:				gl.getUniformLocation( program, 'scale' ),\r\n\r\n			color:				gl.getUniformLocation( program, 'color' ),\r\n			map:				gl.getUniformLocation( program, 'map' ),\r\n			opacity:			gl.getUniformLocation( program, 'opacity' ),\r\n\r\n			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),\r\n			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n			fogType:			gl.getUniformLocation( program, 'fogType' ),\r\n			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),\r\n			fogNear:			gl.getUniformLocation( program, 'fogNear' ),\r\n			fogFar:				gl.getUniformLocation( program, 'fogFar' ),\r\n			fogColor:			gl.getUniformLocation( program, 'fogColor' ),\r\n\r\n			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )\r\n		};\r\n\r\n		var canvas = document.createElement( 'canvas' );\r\n		canvas.width = 8;\r\n		canvas.height = 8;\r\n\r\n		var context = canvas.getContext( '2d' );\r\n		context.fillStyle = 'white';\r\n		context.fillRect( 0, 0, 8, 8 );\r\n\r\n		texture = new THREE.Texture( canvas );\r\n		texture.needsUpdate = true;\r\n\r\n	};\r\n\r\n	this.render = function ( scene, camera ) {\r\n\r\n		if ( sprites.length === 0 ) return;\r\n\r\n		// setup gl\r\n\r\n		if ( program === undefined ) {\r\n\r\n			init();\r\n\r\n		}\r\n\r\n		gl.useProgram( program );\r\n\r\n		state.initAttributes();\r\n		state.enableAttribute( attributes.position );\r\n		state.enableAttribute( attributes.uv );\r\n		state.disableUnusedAttributes();\r\n\r\n		state.disable( gl.CULL_FACE );\r\n		state.enable( gl.BLEND );\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n		state.activeTexture( gl.TEXTURE0 );\r\n		gl.uniform1i( uniforms.map, 0 );\r\n\r\n		var oldFogType = 0;\r\n		var sceneFogType = 0;\r\n		var fog = scene.fog;\r\n\r\n		if ( fog ) {\r\n\r\n			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n			if ( fog instanceof THREE.Fog ) {\r\n\r\n				gl.uniform1f( uniforms.fogNear, fog.near );\r\n				gl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n				gl.uniform1i( uniforms.fogType, 1 );\r\n				oldFogType = 1;\r\n				sceneFogType = 1;\r\n\r\n			} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n				gl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n				gl.uniform1i( uniforms.fogType, 2 );\r\n				oldFogType = 2;\r\n				sceneFogType = 2;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			gl.uniform1i( uniforms.fogType, 0 );\r\n			oldFogType = 0;\r\n			sceneFogType = 0;\r\n\r\n		}\r\n\r\n\r\n		// update positions and sort\r\n\r\n		for ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n			var sprite = sprites[ i ];\r\n\r\n			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\r\n		}\r\n\r\n		sprites.sort( painterSortStable );\r\n\r\n		// render all sprites\r\n\r\n		var scale = [];\r\n\r\n		for ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n			var sprite = sprites[ i ];\r\n			var material = sprite.material;\r\n\r\n			gl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\r\n			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n			scale[ 0 ] = spriteScale.x;\r\n			scale[ 1 ] = spriteScale.y;\r\n\r\n			var fogType = 0;\r\n\r\n			if ( scene.fog && material.fog ) {\r\n\r\n				fogType = sceneFogType;\r\n\r\n			}\r\n\r\n			if ( oldFogType !== fogType ) {\r\n\r\n				gl.uniform1i( uniforms.fogType, fogType );\r\n				oldFogType = fogType;\r\n\r\n			}\r\n\r\n			if ( material.map !== null ) {\r\n\r\n				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n			} else {\r\n\r\n				gl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n				gl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n			}\r\n\r\n			gl.uniform1f( uniforms.opacity, material.opacity );\r\n			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n			gl.uniform1f( uniforms.rotation, material.rotation );\r\n			gl.uniform2fv( uniforms.scale, scale );\r\n\r\n			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n			state.setDepthTest( material.depthTest );\r\n			state.setDepthWrite( material.depthWrite );\r\n\r\n			if ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n				renderer.setTexture( material.map, 0 );\r\n\r\n			} else {\r\n\r\n				renderer.setTexture( texture, 0 );\r\n\r\n			}\r\n\r\n			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n		}\r\n\r\n		// restore gl\r\n\r\n		state.enable( gl.CULL_FACE );\r\n\r\n		renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function createProgram () {\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n		gl.shaderSource( vertexShader, [\r\n\r\n			'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n			'uniform mat4 modelViewMatrix;',\r\n			'uniform mat4 projectionMatrix;',\r\n			'uniform float rotation;',\r\n			'uniform vec2 scale;',\r\n			'uniform vec2 uvOffset;',\r\n			'uniform vec2 uvScale;',\r\n\r\n			'attribute vec2 position;',\r\n			'attribute vec2 uv;',\r\n\r\n			'varying vec2 vUV;',\r\n\r\n			'void main() {',\r\n\r\n				'vUV = uvOffset + uv * uvScale;',\r\n\r\n				'vec2 alignedPosition = position * scale;',\r\n\r\n				'vec2 rotatedPosition;',\r\n				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n				'vec4 finalPosition;',\r\n\r\n				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n				'finalPosition.xy += rotatedPosition;',\r\n				'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n				'gl_Position = finalPosition;',\r\n\r\n			'}'\r\n\r\n		].join( '\\n' ) );\r\n\r\n		gl.shaderSource( fragmentShader, [\r\n\r\n			'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n			'uniform vec3 color;',\r\n			'uniform sampler2D map;',\r\n			'uniform float opacity;',\r\n\r\n			'uniform int fogType;',\r\n			'uniform vec3 fogColor;',\r\n			'uniform float fogDensity;',\r\n			'uniform float fogNear;',\r\n			'uniform float fogFar;',\r\n			'uniform float alphaTest;',\r\n\r\n			'varying vec2 vUV;',\r\n\r\n			'void main() {',\r\n\r\n				'vec4 texture = texture2D( map, vUV );',\r\n\r\n				'if ( texture.a < alphaTest ) discard;',\r\n\r\n				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n				'if ( fogType > 0 ) {',\r\n\r\n					'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n					'float fogFactor = 0.0;',\r\n\r\n					'if ( fogType == 1 ) {',\r\n\r\n						'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n					'} else {',\r\n\r\n						'const float LOG2 = 1.442695;',\r\n						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n					'}',\r\n\r\n					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n				'}',\r\n\r\n			'}'\r\n\r\n		].join( '\\n' ) );\r\n\r\n		gl.compileShader( vertexShader );\r\n		gl.compileShader( fragmentShader );\r\n\r\n		gl.attachShader( program, vertexShader );\r\n		gl.attachShader( program, fragmentShader );\r\n\r\n		gl.linkProgram( program );\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n	function painterSortStable ( a, b ) {\r\n\r\n		if ( a.z !== b.z ) {\r\n\r\n			return b.z - a.z;\r\n\r\n		} else {\r\n\r\n			return b.id - a.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/GeometryUtils.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n	merge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n		var matrix;\r\n\r\n		if ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n			geometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n			matrix = geometry2.matrix;\r\n			geometry2 = geometry2.geometry;\r\n\r\n		}\r\n\r\n		geometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n	},\r\n\r\n	center: function ( geometry ) {\r\n\r\n		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n		return geometry.center();\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/ImageUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n	crossOrigin: undefined,\r\n\r\n	loadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n		var loader = new THREE.ImageLoader();\r\n		loader.crossOrigin = this.crossOrigin;\r\n\r\n		var texture = new THREE.Texture( undefined, mapping );\r\n\r\n		loader.load( url, function ( image ) {\r\n\r\n			texture.image = image;\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad ) onLoad( texture );\r\n\r\n		}, undefined, function ( event ) {\r\n\r\n			if ( onError ) onError( event );\r\n\r\n		} );\r\n\r\n		texture.sourceFile = url;\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	loadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n		var images = [];\r\n\r\n		var loader = new THREE.ImageLoader();\r\n		loader.crossOrigin = this.crossOrigin;\r\n\r\n		var texture = new THREE.CubeTexture( images, mapping );\r\n\r\n		var loaded = 0;\r\n\r\n		var loadTexture = function ( i ) {\r\n\r\n			loader.load( array[ i ], function ( image ) {\r\n\r\n				texture.images[ i ] = image;\r\n\r\n				loaded += 1;\r\n\r\n				if ( loaded === 6 ) {\r\n\r\n					texture.needsUpdate = true;\r\n\r\n					if ( onLoad ) onLoad( texture );\r\n\r\n				}\r\n\r\n			}, undefined, onError );\r\n\r\n		};\r\n\r\n		for ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n			loadTexture( i );\r\n\r\n		}\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	loadCompressedTexture: function () {\r\n\r\n		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n	},\r\n\r\n	loadCompressedTextureCube: function () {\r\n\r\n		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n	},\r\n\r\n	getNormalMap: function ( image, depth ) {\r\n\r\n		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n		var cross = function ( a, b ) {\r\n\r\n			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n		};\r\n\r\n		var subtract = function ( a, b ) {\r\n\r\n			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n		};\r\n\r\n		var normalize = function ( a ) {\r\n\r\n			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n		};\r\n\r\n		depth = depth | 1;\r\n\r\n		var width = image.width;\r\n		var height = image.height;\r\n\r\n		var canvas = document.createElement( 'canvas' );\r\n		canvas.width = width;\r\n		canvas.height = height;\r\n\r\n		var context = canvas.getContext( '2d' );\r\n		context.drawImage( image, 0, 0 );\r\n\r\n		var data = context.getImageData( 0, 0, width, height ).data;\r\n		var imageData = context.createImageData( width, height );\r\n		var output = imageData.data;\r\n\r\n		for ( var x = 0; x < width; x ++ ) {\r\n\r\n			for ( var y = 0; y < height; y ++ ) {\r\n\r\n				var ly = y - 1 < 0 ? 0 : y - 1;\r\n				var uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n				var lx = x - 1 < 0 ? 0 : x - 1;\r\n				var ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n				var points = [];\r\n				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n				var normals = [];\r\n				var num_points = points.length;\r\n\r\n				for ( var i = 0; i < num_points; i ++ ) {\r\n\r\n					var v1 = points[ i ];\r\n					var v2 = points[ ( i + 1 ) % num_points ];\r\n					v1 = subtract( v1, origin );\r\n					v2 = subtract( v2, origin );\r\n					normals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n				}\r\n\r\n				var normal = [ 0, 0, 0 ];\r\n\r\n				for ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n					normal[ 0 ] += normals[ i ][ 0 ];\r\n					normal[ 1 ] += normals[ i ][ 1 ];\r\n					normal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n				}\r\n\r\n				normal[ 0 ] /= normals.length;\r\n				normal[ 1 ] /= normals.length;\r\n				normal[ 2 ] /= normals.length;\r\n\r\n				var idx = ( y * width + x ) * 4;\r\n\r\n				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n				output[ idx + 3 ] = 255;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		context.putImageData( imageData, 0, 0 );\r\n\r\n		return canvas;\r\n\r\n	},\r\n\r\n	generateDataTexture: function ( width, height, color ) {\r\n\r\n		var size = width * height;\r\n		var data = new Uint8Array( 3 * size );\r\n\r\n		var r = Math.floor( color.r * 255 );\r\n		var g = Math.floor( color.g * 255 );\r\n		var b = Math.floor( color.b * 255 );\r\n\r\n		for ( var i = 0; i < size; i ++ ) {\r\n\r\n			data[ i * 3 ] 	   = r;\r\n			data[ i * 3 + 1 ] = g;\r\n			data[ i * 3 + 2 ] = b;\r\n\r\n		}\r\n\r\n		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n		texture.needsUpdate = true;\r\n\r\n		return texture;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n	createMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n		var group = new THREE.Group();\r\n\r\n		for ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n			group.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n		}\r\n\r\n		return group;\r\n\r\n	},\r\n\r\n	detach: function ( child, parent, scene ) {\r\n\r\n		child.applyMatrix( parent.matrixWorld );\r\n		parent.remove( child );\r\n		scene.add( child );\r\n\r\n	},\r\n\r\n	attach: function ( child, scene, parent ) {\r\n\r\n		var matrixWorldInverse = new THREE.Matrix4();\r\n		matrixWorldInverse.getInverse( parent.matrixWorld );\r\n		child.applyMatrix( matrixWorldInverse );\r\n\r\n		scene.remove( child );\r\n		parent.add( child );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/FontUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n *	Triangulation ported from AS3\r\n *		Simple Polygon Triangulation\r\n *		http://actionsnippet.com/?p=1462\r\n *\r\n * 	A Method to triangulate shapes with holes\r\n *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n	faces: {},\r\n\r\n	// Just for now. face[weight][style]\r\n\r\n	face: 'helvetiker',\r\n	weight: 'normal',\r\n	style: 'normal',\r\n	size: 150,\r\n	divisions: 10,\r\n\r\n	getFace: function () {\r\n\r\n		try {\r\n\r\n			return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];\r\n\r\n		} catch ( e ) {\r\n\r\n			throw \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\"\r\n\r\n		}\r\n\r\n	},\r\n\r\n	loadFace: function ( data ) {\r\n\r\n		var family = data.familyName.toLowerCase();\r\n\r\n		var ThreeFont = this;\r\n\r\n		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	drawText: function ( text ) {\r\n\r\n		// RenderText\r\n\r\n		var i,\r\n			face = this.getFace(),\r\n			scale = this.size / face.resolution,\r\n			offset = 0,\r\n			chars = String( text ).split( '' ),\r\n			length = chars.length;\r\n\r\n		var fontPaths = [];\r\n\r\n		for ( i = 0; i < length; i ++ ) {\r\n\r\n			var path = new THREE.Path();\r\n\r\n			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n			offset += ret.offset;\r\n\r\n			fontPaths.push( ret.path );\r\n\r\n		}\r\n\r\n		// get the width\r\n\r\n		var width = offset / 2;\r\n		//\r\n		// for ( p = 0; p < allPts.length; p++ ) {\r\n		//\r\n		// 	allPts[ p ].x -= width;\r\n		//\r\n		// }\r\n\r\n		//var extract = this.extractPoints( allPts, characterPts );\r\n		//extract.contour = allPts;\r\n\r\n		//extract.paths = fontPaths;\r\n		//extract.offset = width;\r\n\r\n		return { paths: fontPaths, offset: width };\r\n\r\n	},\r\n\r\n\r\n\r\n\r\n	extractGlyphPoints: function ( c, face, scale, offset, path ) {\r\n\r\n		var pts = [];\r\n\r\n		var i, i2, divisions,\r\n			outline, action, length,\r\n			scaleX, scaleY,\r\n			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n			laste,\r\n			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n		if ( ! glyph ) return;\r\n\r\n		if ( glyph.o ) {\r\n\r\n			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n			length = outline.length;\r\n\r\n			scaleX = scale;\r\n			scaleY = scale;\r\n\r\n			for ( i = 0; i < length; ) {\r\n\r\n				action = outline[ i ++ ];\r\n\r\n				//console.log( action );\r\n\r\n				switch ( action ) {\r\n\r\n				case 'm':\r\n\r\n					// Move To\r\n\r\n					x = outline[ i ++ ] * scaleX + offset;\r\n					y = outline[ i ++ ] * scaleY;\r\n\r\n					path.moveTo( x, y );\r\n					break;\r\n\r\n				case 'l':\r\n\r\n					// Line To\r\n\r\n					x = outline[ i ++ ] * scaleX + offset;\r\n					y = outline[ i ++ ] * scaleY;\r\n					path.lineTo( x, y );\r\n					break;\r\n\r\n				case 'q':\r\n\r\n					// QuadraticCurveTo\r\n\r\n					cpx  = outline[ i ++ ] * scaleX + offset;\r\n					cpy  = outline[ i ++ ] * scaleY;\r\n					cpx1 = outline[ i ++ ] * scaleX + offset;\r\n					cpy1 = outline[ i ++ ] * scaleY;\r\n\r\n					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n					laste = pts[ pts.length - 1 ];\r\n\r\n					if ( laste ) {\r\n\r\n						cpx0 = laste.x;\r\n						cpy0 = laste.y;\r\n\r\n						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n							var t = i2 / divisions;\r\n							THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n							THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'b':\r\n\r\n					// Cubic Bezier Curve\r\n\r\n					cpx  = outline[ i ++ ] *  scaleX + offset;\r\n					cpy  = outline[ i ++ ] *  scaleY;\r\n					cpx1 = outline[ i ++ ] *  scaleX + offset;\r\n					cpy1 = outline[ i ++ ] *  scaleY;\r\n					cpx2 = outline[ i ++ ] *  scaleX + offset;\r\n					cpy2 = outline[ i ++ ] *  scaleY;\r\n\r\n					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n					laste = pts[ pts.length - 1 ];\r\n\r\n					if ( laste ) {\r\n\r\n						cpx0 = laste.x;\r\n						cpy0 = laste.y;\r\n\r\n						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n							var t = i2 / divisions;\r\n							THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n							THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		return { offset: glyph.ha * scale, path: path };\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function ( text, parameters ) {\r\n\r\n	// Parameters\r\n\r\n	parameters = parameters || {};\r\n\r\n	var size = parameters.size !== undefined ? parameters.size : 100;\r\n	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\r\n\r\n	var font = parameters.font !== undefined ? parameters.font : 'helvetiker';\r\n	var weight = parameters.weight !== undefined ? parameters.weight : 'normal';\r\n	var style = parameters.style !== undefined ? parameters.style : 'normal';\r\n\r\n	THREE.FontUtils.size = size;\r\n	THREE.FontUtils.divisions = curveSegments;\r\n\r\n	THREE.FontUtils.face = font;\r\n	THREE.FontUtils.weight = weight;\r\n	THREE.FontUtils.style = style;\r\n\r\n	// Get a Font data json object\r\n\r\n	var data = THREE.FontUtils.drawText( text );\r\n\r\n	var paths = data.paths;\r\n	var shapes = [];\r\n\r\n	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n	}\r\n\r\n	return shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function ( namespace ) {\r\n\r\n	var EPSILON = 0.0000000001;\r\n\r\n	// takes in an contour array and returns\r\n\r\n	var process = function ( contour, indices ) {\r\n\r\n		var n = contour.length;\r\n\r\n		if ( n < 3 ) return null;\r\n\r\n		var result = [],\r\n			verts = [],\r\n			vertIndices = [];\r\n\r\n		/* we want a counter-clockwise polygon in verts */\r\n\r\n		var u, v, w;\r\n\r\n		if ( area( contour ) > 0.0 ) {\r\n\r\n			for ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n		} else {\r\n\r\n			for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n		}\r\n\r\n		var nv = n;\r\n\r\n		/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n		var count = 2 * nv;   /* error detection */\r\n\r\n		for ( v = nv - 1; nv > 2; ) {\r\n\r\n			/* if we loop, it is probably a non-simple polygon */\r\n\r\n			if ( ( count -- ) <= 0 ) {\r\n\r\n				//** Triangulate: ERROR - probable bad polygon!\r\n\r\n				//throw ( \"Warning, unable to triangulate polygon!\" );\r\n				//return null;\r\n				// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n				console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );\r\n\r\n				if ( indices ) return vertIndices;\r\n				return result;\r\n\r\n			}\r\n\r\n			/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */\r\n			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n			if ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n				var a, b, c, s, t;\r\n\r\n				/* true names of the vertices */\r\n\r\n				a = verts[ u ];\r\n				b = verts[ v ];\r\n				c = verts[ w ];\r\n\r\n				/* output Triangle */\r\n\r\n				result.push( [ contour[ a ],\r\n					contour[ b ],\r\n					contour[ c ] ] );\r\n\r\n\r\n				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n				/* remove v from the remaining polygon */\r\n\r\n				for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n					verts[ s ] = verts[ t ];\r\n\r\n				}\r\n\r\n				nv --;\r\n\r\n				/* reset error detection counter */\r\n\r\n				count = 2 * nv;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( indices ) return vertIndices;\r\n		return result;\r\n\r\n	};\r\n\r\n	// calculate area of the contour polygon\r\n\r\n	var area = function ( contour ) {\r\n\r\n		var n = contour.length;\r\n		var a = 0.0;\r\n\r\n		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n		}\r\n\r\n		return a * 0.5;\r\n\r\n	};\r\n\r\n	var snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n		var p;\r\n		var ax, ay, bx, by;\r\n		var cx, cy, px, py;\r\n\r\n		ax = contour[ verts[ u ] ].x;\r\n		ay = contour[ verts[ u ] ].y;\r\n\r\n		bx = contour[ verts[ v ] ].x;\r\n		by = contour[ verts[ v ] ].y;\r\n\r\n		cx = contour[ verts[ w ] ].x;\r\n		cy = contour[ verts[ w ] ].y;\r\n\r\n		if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n		var aX, aY, bX, bY, cX, cY;\r\n		var apx, apy, bpx, bpy, cpx, cpy;\r\n		var cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n		aX = cx - bx;  aY = cy - by;\r\n		bX = ax - cx;  bY = ay - cy;\r\n		cX = bx - ax;  cY = by - ay;\r\n\r\n		for ( p = 0; p < n; p ++ ) {\r\n\r\n			px = contour[ verts[ p ] ].x;\r\n			py = contour[ verts[ p ] ].y;\r\n\r\n			if ( ( ( px === ax ) && ( py === ay ) ) ||\r\n				 ( ( px === bx ) && ( py === by ) ) ||\r\n				 ( ( px === cx ) && ( py === cy ) ) )	continue;\r\n\r\n			apx = px - ax;  apy = py - ay;\r\n			bpx = px - bx;  bpy = py - by;\r\n			cpx = px - cx;  cpy = py - cy;\r\n\r\n			// see if p is inside triangle abc\r\n\r\n			aCROSSbp = aX * bpy - aY * bpx;\r\n			cCROSSap = cX * apy - cY * apx;\r\n			bCROSScp = bX * cpy - bY * cpx;\r\n\r\n			if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	};\r\n\r\n\r\n	namespace.Triangulate = process;\r\n	namespace.Triangulate.area = area;\r\n\r\n	return namespace;\r\n\r\n} )( THREE.FontUtils );\r\n\r\n// To use the typeface.js face files, hook up the API\r\n\r\nTHREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\nif ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;\r\n\r\n// File:src/extras/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Audio';\r\n\r\n	this.context = listener.context;\r\n	this.source = this.context.createBufferSource();\r\n	this.source.onended = this.onEnded.bind( this );\r\n\r\n	this.gain = this.context.createGain();\r\n	this.gain.connect( this.context.destination );\r\n\r\n	this.panner = this.context.createPanner();\r\n	this.panner.connect( this.gain );\r\n\r\n	this.autoplay = false;\r\n\r\n	this.startTime = 0;\r\n	this.playbackRate = 1;\r\n	this.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.load = function ( file ) {\r\n\r\n	var scope = this;\r\n\r\n	var request = new XMLHttpRequest();\r\n	request.open( 'GET', file, true );\r\n	request.responseType = 'arraybuffer';\r\n	request.onload = function ( e ) {\r\n\r\n		scope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\r\n			scope.source.buffer = buffer;\r\n\r\n			if ( scope.autoplay ) scope.play();\r\n\r\n		} );\r\n\r\n	};\r\n	request.send();\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.play = function () {\r\n\r\n	if ( this.isPlaying === true ) {\r\n\r\n		console.warn( 'THREE.Audio: Audio is already playing.' );\r\n		return;\r\n\r\n	}\r\n\r\n	var source = this.context.createBufferSource();\r\n\r\n	source.buffer = this.source.buffer;\r\n	source.loop = this.source.loop;\r\n	source.onended = this.source.onended;\r\n	source.start( 0, this.startTime );\r\n	source.playbackRate.value = this.playbackRate;\r\n\r\n	this.isPlaying = true;\r\n\r\n	this.source = source;\r\n\r\n	this.connect();\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.pause = function () {\r\n\r\n	this.source.stop();\r\n	this.startTime = this.context.currentTime;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.stop = function () {\r\n\r\n	this.source.stop();\r\n	this.startTime = 0;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.connect = function () {\r\n\r\n	if ( this.filter !== undefined ) {\r\n\r\n		this.source.connect( this.filter );\r\n		this.filter.connect( this.panner );\r\n\r\n	} else {\r\n\r\n		this.source.connect( this.panner );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.disconnect = function () {\r\n\r\n	if ( this.filter !== undefined ) {\r\n\r\n		this.source.disconnect( this.filter );\r\n		this.filter.disconnect( this.panner );\r\n\r\n	} else {\r\n\r\n		this.source.disconnect( this.panner );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setFilter = function ( value ) {\r\n\r\n	if ( this.isPlaying === true ) {\r\n\r\n		this.disconnect();\r\n		this.filter = value;\r\n		this.connect();\r\n\r\n	} else {\r\n\r\n		this.filter = value;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getFilter = function () {\r\n\r\n	return this.filter;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setPlaybackRate = function ( value ) {\r\n\r\n	this.playbackRate = value;\r\n\r\n	if ( this.isPlaying === true ) {\r\n\r\n		this.source.playbackRate.value = this.playbackRate;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getPlaybackRate = function () {\r\n\r\n	return this.playbackRate;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.onEnded = function() {\r\n\r\n	this.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n	this.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getLoop = function () {\r\n\r\n	return this.source.loop;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRefDistance = function ( value ) {\r\n\r\n	this.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getRefDistance = function () {\r\n\r\n	return this.panner.refDistance;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n	this.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getRolloffFactor = function () {\r\n\r\n	return this.panner.rolloffFactor;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\r\n	this.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getVolume = function () {\r\n\r\n	return this.gain.gain.value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var position = new THREE.Vector3();\r\n\r\n	return function updateMatrixWorld( force ) {\r\n\r\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n		position.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		this.panner.setPosition( position.x, position.y, position.z );\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/extras/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'AudioListener';\r\n\r\n	this.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var position = new THREE.Vector3();\r\n	var quaternion = new THREE.Quaternion();\r\n	var scale = new THREE.Vector3();\r\n\r\n	var orientation = new THREE.Vector3();\r\n\r\n	return function updateMatrixWorld( force ) {\r\n\r\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n		var listener = this.context.listener;\r\n		var up = this.up;\r\n\r\n		this.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n		orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n		listener.setPosition( position.x, position.y, position.z );\r\n		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *	Abstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//	- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n	console.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n	return null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n	var t = this.getUtoTmapping( u );\r\n	return this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = 5;\r\n\r\n	var d, pts = [];\r\n\r\n	for ( d = 0; d <= divisions; d ++ ) {\r\n\r\n		pts.push( this.getPoint( d / divisions ) );\r\n\r\n	}\r\n\r\n	return pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = 5;\r\n\r\n	var d, pts = [];\r\n\r\n	for ( d = 0; d <= divisions; d ++ ) {\r\n\r\n		pts.push( this.getPointAt( d / divisions ) );\r\n\r\n	}\r\n\r\n	return pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n	var lengths = this.getLengths();\r\n	return lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\r\n	if ( this.cacheArcLengths\r\n		&& ( this.cacheArcLengths.length === divisions + 1 )\r\n		&& ! this.needsUpdate ) {\r\n\r\n		//console.log( \"cached\", this.cacheArcLengths );\r\n		return this.cacheArcLengths;\r\n\r\n	}\r\n\r\n	this.needsUpdate = false;\r\n\r\n	var cache = [];\r\n	var current, last = this.getPoint( 0 );\r\n	var p, sum = 0;\r\n\r\n	cache.push( 0 );\r\n\r\n	for ( p = 1; p <= divisions; p ++ ) {\r\n\r\n		current = this.getPoint ( p / divisions );\r\n		sum += current.distanceTo( last );\r\n		cache.push( sum );\r\n		last = current;\r\n\r\n	}\r\n\r\n	this.cacheArcLengths = cache;\r\n\r\n	return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n\r\n	this.needsUpdate = true;\r\n	this.getLengths();\r\n\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n	var arcLengths = this.getLengths();\r\n\r\n	var i = 0, il = arcLengths.length;\r\n\r\n	var targetArcLength; // The targeted u distance value to get\r\n\r\n	if ( distance ) {\r\n\r\n		targetArcLength = distance;\r\n\r\n	} else {\r\n\r\n		targetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n	}\r\n\r\n	//var time = Date.now();\r\n\r\n	// binary search for the index with largest value smaller than target u distance\r\n\r\n	var low = 0, high = il - 1, comparison;\r\n\r\n	while ( low <= high ) {\r\n\r\n		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n		comparison = arcLengths[ i ] - targetArcLength;\r\n\r\n		if ( comparison < 0 ) {\r\n\r\n			low = i + 1;\r\n\r\n		} else if ( comparison > 0 ) {\r\n\r\n			high = i - 1;\r\n\r\n		} else {\r\n\r\n			high = i;\r\n			break;\r\n\r\n			// DONE\r\n\r\n		}\r\n\r\n	}\r\n\r\n	i = high;\r\n\r\n	//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n	if ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n		var t = i / ( il - 1 );\r\n		return t;\r\n\r\n	}\r\n\r\n	// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n	var lengthBefore = arcLengths[ i ];\r\n	var lengthAfter = arcLengths[ i + 1 ];\r\n\r\n	var segmentLength = lengthAfter - lengthBefore;\r\n\r\n	// determine where we are between the 'before' and 'after' points\r\n\r\n	var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n	// add that fractional amount to t\r\n\r\n	var t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n	return t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n	var delta = 0.0001;\r\n	var t1 = t - delta;\r\n	var t2 = t + delta;\r\n\r\n	// Capping in case of danger\r\n\r\n	if ( t1 < 0 ) t1 = 0;\r\n	if ( t2 > 1 ) t2 = 1;\r\n\r\n	var pt1 = this.getPoint( t1 );\r\n	var pt2 = this.getPoint( t2 );\r\n\r\n	var vec = pt2.clone().sub( pt1 );\r\n	return vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n	var t = this.getUtoTmapping( u );\r\n	return this.getTangent( t );\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/**************************************************************\r\n *	Utils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n	},\r\n\r\n	// Puay Bing, thanks for helping with this derivative!\r\n\r\n	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n			3 * t * t * p3;\r\n\r\n	},\r\n\r\n	tangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		// To check if my formulas are correct\r\n\r\n		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1\r\n		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2\r\n		var h11 = 3 * t * t - 2 * t;	// t3 − t2\r\n\r\n		return h00 + h10 + h01 + h11;\r\n\r\n	},\r\n\r\n	// Catmull-Rom\r\n\r\n	interpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5;\r\n		var v1 = ( p3 - p1 ) * 0.5;\r\n		var t2 = t * t;\r\n		var t3 = t * t2;\r\n		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *	3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n	constructor.prototype = Object.create( THREE.Curve.prototype );\r\n	constructor.prototype.constructor = constructor;\r\n	constructor.prototype.getPoint = getPointFunc;\r\n\r\n	return constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *	Curved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n	this.curves = [];\r\n	this.bends = [];\r\n\r\n	this.autoClose = false; // Automatically closes the path\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n	this.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n	// TODO\r\n	// If the ending of curve is not connected to the starting\r\n	// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\r\n	// TODO Test\r\n	// and verify for vector3 (needs to implement equals)\r\n	// Add a line curve if start and end of lines are not connected\r\n	var startPoint = this.curves[ 0 ].getPoint( 0 );\r\n	var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n	if ( ! startPoint.equals( endPoint ) ) {\r\n\r\n		this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\r\n	}\r\n\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n	var d = t * this.getLength();\r\n	var curveLengths = this.getCurveLengths();\r\n	var i = 0, diff, curve;\r\n\r\n	// To think about boundaries points.\r\n\r\n	while ( i < curveLengths.length ) {\r\n\r\n		if ( curveLengths[ i ] >= d ) {\r\n\r\n			diff = curveLengths[ i ] - d;\r\n			curve = this.curves[ i ];\r\n\r\n			var u = 1 - diff / curve.getLength();\r\n\r\n			return curve.getPointAt( u );\r\n\r\n		}\r\n\r\n		i ++;\r\n\r\n	}\r\n\r\n	return null;\r\n\r\n	// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n	var lens = this.getCurveLengths();\r\n	return lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n	// We use cache values if curves and cache array are same length\r\n\r\n	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n		return this.cacheLengths;\r\n\r\n	}\r\n\r\n	// Get length of sub-curve\r\n	// Push sums into cached array\r\n\r\n	var lengths = [], sums = 0;\r\n	var i, il = this.curves.length;\r\n\r\n	for ( i = 0; i < il; i ++ ) {\r\n\r\n		sums += this.curves[ i ].getLength();\r\n		lengths.push( sums );\r\n\r\n	}\r\n\r\n	this.cacheLengths = lengths;\r\n\r\n	return lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n	var points = this.getPoints();\r\n\r\n	var maxX, maxY, maxZ;\r\n	var minX, minY, minZ;\r\n\r\n	maxX = maxY = Number.NEGATIVE_INFINITY;\r\n	minX = minY = Number.POSITIVE_INFINITY;\r\n\r\n	var p, i, il, sum;\r\n\r\n	var v3 = points[ 0 ] instanceof THREE.Vector3;\r\n\r\n	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n	for ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n		p = points[ i ];\r\n\r\n		if ( p.x > maxX ) maxX = p.x;\r\n		else if ( p.x < minX ) minX = p.x;\r\n\r\n		if ( p.y > maxY ) maxY = p.y;\r\n		else if ( p.y < minY ) minY = p.y;\r\n\r\n		if ( v3 ) {\r\n\r\n			if ( p.z > maxZ ) maxZ = p.z;\r\n			else if ( p.z < minZ ) minZ = p.z;\r\n\r\n		}\r\n\r\n		sum.add( p );\r\n\r\n	}\r\n\r\n	var ret = {\r\n\r\n		minX: minX,\r\n		minY: minY,\r\n		maxX: maxX,\r\n		maxY: maxY\r\n\r\n	};\r\n\r\n	if ( v3 ) {\r\n\r\n		ret.maxZ = maxZ;\r\n		ret.minZ = minZ;\r\n\r\n	}\r\n\r\n	return ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *	Create Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n	var pts = this.getPoints( divisions, true );\r\n	return this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistant sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n	var pts = this.getSpacedPoints( divisions, true );\r\n	return this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	for ( var i = 0; i < points.length; i ++ ) {\r\n\r\n		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );\r\n\r\n	}\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *	Bend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n	this.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n	var i, il;\r\n\r\n	if ( ! bends ) {\r\n\r\n		bends = this.bends;\r\n\r\n	}\r\n\r\n	for ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n		oldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n	}\r\n\r\n	return oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n	var oldPts = this.getSpacedPoints( segments );\r\n\r\n	var i, il;\r\n\r\n	if ( ! bends ) {\r\n\r\n		bends = this.bends;\r\n\r\n	}\r\n\r\n	for ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n		oldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n	}\r\n\r\n	return oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n	var bounds = this.getBoundingBox();\r\n\r\n	var i, il, p, oldX, oldY, xNorm;\r\n\r\n	for ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n		p = oldPts[ i ];\r\n\r\n		oldX = p.x;\r\n		oldY = p.y;\r\n\r\n		xNorm = oldX / bounds.maxX;\r\n\r\n		// If using actual distance, for length > path, requires line extrusions\r\n		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n		xNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n		// check for out of bounds?\r\n\r\n		var pathPt = path.getPoint( xNorm );\r\n		var normal = path.getTangent( xNorm );\r\n		normal.set( - normal.y, normal.x ).multiplyScalar( oldY );\r\n\r\n		p.x = pathPt.x + normal.x;\r\n		p.y = pathPt.y + normal.y;\r\n\r\n	}\r\n\r\n	return oldPts;\r\n\r\n};\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n	THREE.CurvePath.call( this );\r\n\r\n	this.actions = [];\r\n\r\n	if ( points ) {\r\n\r\n		this.fromPoints( points );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\nTHREE.PathActions = {\r\n\r\n	MOVE_TO: 'moveTo',\r\n	LINE_TO: 'lineTo',\r\n	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve\r\n	CSPLINE_THRU: 'splineThru',				// Catmull-Rom spline\r\n	ARC: 'arc',								// Circle\r\n	ELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n		this.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n	}\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n												new THREE.Vector2( aCPx, aCPy ),\r\n												new THREE.Vector2( aX, aY ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n											   aCP2x, aCP2y,\r\n											   aX, aY ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n											new THREE.Vector2( aCP1x, aCP1y ),\r\n											new THREE.Vector2( aCP2x, aCP2y ),\r\n											new THREE.Vector2( aX, aY ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n	//---\r\n	var npts = [ new THREE.Vector2( x0, y0 ) ];\r\n	Array.prototype.push.apply( npts, pts );\r\n\r\n	var curve = new THREE.SplineCurve( npts );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n									  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	this.absarc( aX + x0, aY + y0, aRadius,\r\n		aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n									  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n									  aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	this.absellipse( aX + x0, aY + y0, xRadius, yRadius,\r\n		aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n									  aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n	var args = [\r\n		aX, aY,\r\n		xRadius, yRadius,\r\n		aStartAngle, aEndAngle,\r\n		aClockwise,\r\n		aRotation || 0 // aRotation is optional.\r\n	];\r\n	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n									aStartAngle, aEndAngle, aClockwise, aRotation );\r\n	this.curves.push( curve );\r\n\r\n	var lastPoint = curve.getPoint( 1 );\r\n	args.push( lastPoint.x );\r\n	args.push( lastPoint.y );\r\n\r\n	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n	if ( ! divisions ) divisions = 40;\r\n\r\n	var points = [];\r\n\r\n	for ( var i = 0; i < divisions; i ++ ) {\r\n\r\n		points.push( this.getPoint( i / divisions ) );\r\n\r\n		//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n	}\r\n\r\n	// if ( closedPath ) {\r\n	//\r\n	// 	points.push( points[ 0 ] );\r\n	//\r\n	// }\r\n\r\n	return points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n	if ( this.useSpacedPoints ) {\r\n\r\n		return this.getSpacedPoints( divisions, closedPath );\r\n\r\n	}\r\n\r\n	divisions = divisions || 12;\r\n\r\n	var points = [];\r\n\r\n	var i, il, item, action, args;\r\n	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n		laste, j,\r\n		t, tx, ty;\r\n\r\n	for ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n		item = this.actions[ i ];\r\n\r\n		action = item.action;\r\n		args = item.args;\r\n\r\n		switch ( action ) {\r\n\r\n		case THREE.PathActions.MOVE_TO:\r\n\r\n			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.LINE_TO:\r\n\r\n			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n			cpx  = args[ 2 ];\r\n			cpy  = args[ 3 ];\r\n\r\n			cpx1 = args[ 0 ];\r\n			cpy1 = args[ 1 ];\r\n\r\n			if ( points.length > 0 ) {\r\n\r\n				laste = points[ points.length - 1 ];\r\n\r\n				cpx0 = laste.x;\r\n				cpy0 = laste.y;\r\n\r\n			} else {\r\n\r\n				laste = this.actions[ i - 1 ].args;\r\n\r\n				cpx0 = laste[ laste.length - 2 ];\r\n				cpy0 = laste[ laste.length - 1 ];\r\n\r\n			}\r\n\r\n			for ( j = 1; j <= divisions; j ++ ) {\r\n\r\n				t = j / divisions;\r\n\r\n				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n			cpx  = args[ 4 ];\r\n			cpy  = args[ 5 ];\r\n\r\n			cpx1 = args[ 0 ];\r\n			cpy1 = args[ 1 ];\r\n\r\n			cpx2 = args[ 2 ];\r\n			cpy2 = args[ 3 ];\r\n\r\n			if ( points.length > 0 ) {\r\n\r\n				laste = points[ points.length - 1 ];\r\n\r\n				cpx0 = laste.x;\r\n				cpy0 = laste.y;\r\n\r\n			} else {\r\n\r\n				laste = this.actions[ i - 1 ].args;\r\n\r\n				cpx0 = laste[ laste.length - 2 ];\r\n				cpy0 = laste[ laste.length - 1 ];\r\n\r\n			}\r\n\r\n\r\n			for ( j = 1; j <= divisions; j ++ ) {\r\n\r\n				t = j / divisions;\r\n\r\n				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.CSPLINE_THRU:\r\n\r\n			laste = this.actions[ i - 1 ].args;\r\n\r\n			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n			var spts = [ last ];\r\n\r\n			var n = divisions * args[ 0 ].length;\r\n\r\n			spts = spts.concat( args[ 0 ] );\r\n\r\n			var spline = new THREE.SplineCurve( spts );\r\n\r\n			for ( j = 1; j <= n; j ++ ) {\r\n\r\n				points.push( spline.getPointAt( j / n ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.ARC:\r\n\r\n			var aX = args[ 0 ], aY = args[ 1 ],\r\n				aRadius = args[ 2 ],\r\n				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n				aClockwise = !! args[ 5 ];\r\n\r\n			var deltaAngle = aEndAngle - aStartAngle;\r\n			var angle;\r\n			var tdivisions = divisions * 2;\r\n\r\n			for ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n				t = j / tdivisions;\r\n\r\n				if ( ! aClockwise ) {\r\n\r\n					t = 1 - t;\r\n\r\n				}\r\n\r\n				angle = aStartAngle + t * deltaAngle;\r\n\r\n				tx = aX + aRadius * Math.cos( angle );\r\n				ty = aY + aRadius * Math.sin( angle );\r\n\r\n				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			//console.log(points);\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.ELLIPSE:\r\n\r\n			var aX = args[ 0 ], aY = args[ 1 ],\r\n				xRadius = args[ 2 ],\r\n				yRadius = args[ 3 ],\r\n				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n				aClockwise = !! args[ 6 ],\r\n				aRotation = args[ 7 ];\r\n\r\n\r\n			var deltaAngle = aEndAngle - aStartAngle;\r\n			var angle;\r\n			var tdivisions = divisions * 2;\r\n\r\n			var cos, sin;\r\n			if ( aRotation !== 0 ) {\r\n		\r\n				cos = Math.cos( aRotation );\r\n				sin = Math.sin( aRotation );\r\n\r\n			}\r\n\r\n			for ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n				t = j / tdivisions;\r\n\r\n				if ( ! aClockwise ) {\r\n\r\n					t = 1 - t;\r\n\r\n				}\r\n\r\n				angle = aStartAngle + t * deltaAngle;\r\n\r\n				tx = aX + xRadius * Math.cos( angle );\r\n				ty = aY + yRadius * Math.sin( angle );\r\n\r\n				if ( aRotation !== 0 ) {\r\n\r\n					var x = tx, y = ty;\r\n\r\n					// Rotate the point about the center of the ellipse.\r\n					tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n					ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\r\n				}\r\n\r\n				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			//console.log(points);\r\n\r\n			break;\r\n\r\n		} // end switch\r\n\r\n	}\r\n\r\n\r\n\r\n	// Normalize to remove the closing point by default.\r\n	var lastPoint = points[ points.length - 1 ];\r\n	var EPSILON = 0.0000000001;\r\n	if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&\r\n			 Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )\r\n		points.splice( points.length - 1, 1 );\r\n	if ( closedPath ) {\r\n\r\n		points.push( points[ 0 ] );\r\n\r\n	}\r\n\r\n	return points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//	Assumptions (if parameter isCCW==true the opposite holds):\r\n//	- solid shapes are defined clockwise (CW)\r\n//	- holes are defined counterclockwise (CCW)\r\n//\r\n//	If parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n	function extractSubpaths( inActions ) {\r\n\r\n		var i, il, item, action, args;\r\n\r\n		var subPaths = [], lastPath = new THREE.Path();\r\n\r\n		for ( i = 0, il = inActions.length; i < il; i ++ ) {\r\n\r\n			item = inActions[ i ];\r\n\r\n			args = item.args;\r\n			action = item.action;\r\n\r\n			if ( action === THREE.PathActions.MOVE_TO ) {\r\n\r\n				if ( lastPath.actions.length !== 0 ) {\r\n\r\n					subPaths.push( lastPath );\r\n					lastPath = new THREE.Path();\r\n\r\n				}\r\n\r\n			}\r\n\r\n			lastPath[ action ].apply( lastPath, args );\r\n\r\n		}\r\n\r\n		if ( lastPath.actions.length !== 0 ) {\r\n\r\n			subPaths.push( lastPath );\r\n\r\n		}\r\n\r\n		// console.log(subPaths);\r\n\r\n		return	subPaths;\r\n\r\n	}\r\n\r\n	function toShapesNoHoles( inSubpaths ) {\r\n\r\n		var shapes = [];\r\n\r\n		for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {\r\n\r\n			var tmpPath = inSubpaths[ i ];\r\n\r\n			var tmpShape = new THREE.Shape();\r\n			tmpShape.actions = tmpPath.actions;\r\n			tmpShape.curves = tmpPath.curves;\r\n\r\n			shapes.push( tmpShape );\r\n\r\n		}\r\n\r\n		//console.log(\"shape\", shapes);\r\n\r\n		return shapes;\r\n\r\n	}\r\n\r\n	function isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n		var EPSILON = 0.0000000001;\r\n\r\n		var polyLen = inPolygon.length;\r\n\r\n		// inPt on polygon contour => immediate success    or\r\n		// toggling of inside/outside at every single! intersection point of an edge\r\n		//  with the horizontal line through inPt, left of inPt\r\n		//  not counting lowerY endpoints of edges and whole edges on that line\r\n		var inside = false;\r\n		for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n			var edgeLowPt  = inPolygon[ p ];\r\n			var edgeHighPt = inPolygon[ q ];\r\n\r\n			var edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n			var edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n			if ( Math.abs( edgeDy ) > EPSILON ) {\r\n\r\n				// not parallel\r\n				if ( edgeDy < 0 ) {\r\n\r\n					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n				}\r\n				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;\r\n\r\n				if ( inPt.y === edgeLowPt.y ) {\r\n\r\n					if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?\r\n					// continue;				// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n				} else {\r\n\r\n					var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n					if ( perpEdge === 0 )				return	true;		// inPt is on contour ?\r\n					if ( perpEdge < 0 ) 				continue;\r\n					inside = ! inside;		// true intersection left of inPt\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// parallel or collinear\r\n				if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel\r\n				// edge lies on the same horizontal line as inPt\r\n				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !\r\n				// continue;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return	inside;\r\n\r\n	}\r\n\r\n\r\n	var subPaths = extractSubpaths( this.actions );\r\n	if ( subPaths.length === 0 ) return [];\r\n\r\n	if ( noHoles === true )	return	toShapesNoHoles( subPaths );\r\n\r\n\r\n	var solid, tmpPath, tmpShape, shapes = [];\r\n\r\n	if ( subPaths.length === 1 ) {\r\n\r\n		tmpPath = subPaths[ 0 ];\r\n		tmpShape = new THREE.Shape();\r\n		tmpShape.actions = tmpPath.actions;\r\n		tmpShape.curves = tmpPath.curves;\r\n		shapes.push( tmpShape );\r\n		return shapes;\r\n\r\n	}\r\n\r\n	var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n	holesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n	// console.log(\"Holes first\", holesFirst);\r\n\r\n	var betterShapeHoles = [];\r\n	var newShapes = [];\r\n	var newShapeHoles = [];\r\n	var mainIdx = 0;\r\n	var tmpPoints;\r\n\r\n	newShapes[ mainIdx ] = undefined;\r\n	newShapeHoles[ mainIdx ] = [];\r\n\r\n	var i, il;\r\n\r\n	for ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n		tmpPath = subPaths[ i ];\r\n		tmpPoints = tmpPath.getPoints();\r\n		solid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n		solid = isCCW ? ! solid : solid;\r\n\r\n		if ( solid ) {\r\n\r\n			if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;\r\n\r\n			newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n			newShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n			newShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n			if ( holesFirst )	mainIdx ++;\r\n			newShapeHoles[ mainIdx ] = [];\r\n\r\n			//console.log('cw', i);\r\n\r\n		} else {\r\n\r\n			newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n			//console.log('ccw', i);\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// only Holes? -> probably all Shapes with wrong orientation\r\n	if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );\r\n\r\n\r\n	if ( newShapes.length > 1 ) {\r\n\r\n		var ambiguous = false;\r\n		var toChange = [];\r\n\r\n		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n			betterShapeHoles[ sIdx ] = [];\r\n\r\n		}\r\n		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n			var sho = newShapeHoles[ sIdx ];\r\n			for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n				var ho = sho[ hIdx ];\r\n				var hole_unassigned = true;\r\n				for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n					if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n						if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n						if ( hole_unassigned ) {\r\n\r\n							hole_unassigned = false;\r\n							betterShapeHoles[ s2Idx ].push( ho );\r\n\r\n						} else {\r\n\r\n							ambiguous = true;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n				if ( hole_unassigned ) {\r\n\r\n					betterShapeHoles[ sIdx ].push( ho );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n		// console.log(\"ambiguous: \", ambiguous);\r\n		if ( toChange.length > 0 ) {\r\n\r\n			// console.log(\"to change: \", toChange);\r\n			if ( ! ambiguous )	newShapeHoles = betterShapeHoles;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var tmpHoles, j, jl;\r\n	for ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n		tmpShape = newShapes[ i ].s;\r\n		shapes.push( tmpShape );\r\n		tmpHoles = newShapeHoles[ i ];\r\n		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n			tmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	//console.log(\"shape\", shapes);\r\n\r\n	return shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n	THREE.Path.apply( this, arguments );\r\n	this.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n	var extruded = new THREE.ExtrudeGeometry( this, options );\r\n	return extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n	var geometry = new THREE.ShapeGeometry( this, options );\r\n	return geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n	var i, il = this.holes.length, holesPts = [];\r\n\r\n	for ( i = 0; i < il; i ++ ) {\r\n\r\n		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n	}\r\n\r\n	return holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n	var i, il = this.holes.length, holesPts = [];\r\n\r\n	for ( i = 0; i < il; i ++ ) {\r\n\r\n		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n	}\r\n\r\n	return holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n	return {\r\n\r\n		shape: this.getTransformedPoints( divisions ),\r\n		holes: this.getPointsHoles( divisions )\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n	if ( this.useSpacedPoints ) {\r\n\r\n		return this.extractAllSpacedPoints( divisions );\r\n\r\n	}\r\n\r\n	return this.extractAllPoints( divisions );\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// 	return {\r\n//\r\n// 		shape: this.transform( bend, divisions ),\r\n// 		holes: this.getPointsHoles( divisions, bend )\r\n//\r\n// 	};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n	return {\r\n\r\n		shape: this.getTransformedSpacedPoints( divisions ),\r\n		holes: this.getSpacedPointsHoles( divisions )\r\n\r\n	};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *	Utils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n	triangulateShape: function ( contour, holes ) {\r\n\r\n		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\r\n			// inOtherPt needs to be collinear to the inSegment\r\n			if ( inSegPt1.x !== inSegPt2.x ) {\r\n\r\n				if ( inSegPt1.x < inSegPt2.x ) {\r\n\r\n					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\r\n				} else {\r\n\r\n					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				if ( inSegPt1.y < inSegPt2.y ) {\r\n\r\n					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\r\n				} else {\r\n\r\n					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\r\n			var EPSILON = 0.0000000001;\r\n\r\n			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;\r\n			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n			if ( Math.abs( limit ) > EPSILON ) {\r\n\r\n				// not parallel\r\n\r\n				var perpSeg2;\r\n				if ( limit > 0 ) {\r\n\r\n					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];\r\n					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];\r\n\r\n				} else {\r\n\r\n					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];\r\n					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];\r\n\r\n				}\r\n\r\n				// i.e. to reduce rounding errors\r\n				// intersection at endpoint of segment#1?\r\n				if ( perpSeg2 === 0 ) {\r\n\r\n					if ( ( inExcludeAdjacentSegs ) &&\r\n						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];\r\n					return [ inSeg1Pt1 ];\r\n\r\n				}\r\n				if ( perpSeg2 === limit ) {\r\n\r\n					if ( ( inExcludeAdjacentSegs ) &&\r\n						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];\r\n					return [ inSeg1Pt2 ];\r\n\r\n				}\r\n				// intersection at endpoint of segment#2?\r\n				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];\r\n				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];\r\n\r\n				// return real intersection point\r\n				var factorSeg1 = perpSeg2 / limit;\r\n				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n			} else {\r\n\r\n				// parallel or collinear\r\n				if ( ( perpSeg1 !== 0 ) ||\r\n					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];\r\n\r\n				// they are collinear or degenerate\r\n				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?\r\n				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?\r\n				// both segments are points\r\n				if ( seg1Pt && seg2Pt ) {\r\n\r\n					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points\r\n					return [ inSeg1Pt1 ];                 						// they are the same point\r\n\r\n				}\r\n				// segment#1  is a single point\r\n				if ( seg1Pt ) {\r\n\r\n					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2\r\n					return [ inSeg1Pt1 ];\r\n\r\n				}\r\n				// segment#2  is a single point\r\n				if ( seg2Pt ) {\r\n\r\n					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1\r\n					return [ inSeg2Pt1 ];\r\n\r\n				}\r\n\r\n				// they are collinear segments, which might overlap\r\n				var seg1min, seg1max, seg1minVal, seg1maxVal;\r\n				var seg2min, seg2max, seg2minVal, seg2maxVal;\r\n				if ( seg1dx !== 0 ) {\r\n\r\n					// the segments are NOT on a vertical line\r\n					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\r\n						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\r\n					} else {\r\n\r\n						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\r\n					}\r\n					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\r\n						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\r\n					} else {\r\n\r\n						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					// the segments are on a vertical line\r\n					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\r\n						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\r\n					} else {\r\n\r\n						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\r\n					}\r\n					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\r\n						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\r\n					} else {\r\n\r\n						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\r\n					}\r\n\r\n				}\r\n				if ( seg1minVal <= seg2minVal ) {\r\n\r\n					if ( seg1maxVal <  seg2minVal )	return [];\r\n					if ( seg1maxVal === seg2minVal )	{\r\n\r\n						if ( inExcludeAdjacentSegs )		return [];\r\n						return [ seg2min ];\r\n\r\n					}\r\n					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];\r\n					return	[ seg2min, seg2max ];\r\n\r\n				} else {\r\n\r\n					if ( seg1minVal >  seg2maxVal )	return [];\r\n					if ( seg1minVal === seg2maxVal )	{\r\n\r\n						if ( inExcludeAdjacentSegs )		return [];\r\n						return [ seg1min ];\r\n\r\n					}\r\n					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];\r\n					return	[ seg1min, seg2max ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\r\n			// The order of legs is important\r\n\r\n			var EPSILON = 0.0000000001;\r\n\r\n			// translation of all points, so that Vertex is at (0,0)\r\n			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;\r\n			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;\r\n			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;\r\n\r\n			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n			if ( Math.abs( from2toAngle ) > EPSILON ) {\r\n\r\n				// angle != 180 deg.\r\n\r\n				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;\r\n				// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n				if ( from2toAngle > 0 ) {\r\n\r\n					// main angle < 180 deg.\r\n					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\r\n				} else {\r\n\r\n					// main angle > 180 deg.\r\n					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// angle == 180 deg.\r\n				// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n				return	( from2otherAngle > 0 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n		function removeHoles( contour, holes ) {\r\n\r\n			var shape = contour.concat(); // work on this shape\r\n			var hole;\r\n\r\n			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\r\n				// Check if hole point lies within angle around shape point\r\n				var lastShapeIdx = shape.length - 1;\r\n\r\n				var prevShapeIdx = inShapeIdx - 1;\r\n				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;\r\n\r\n				var nextShapeIdx = inShapeIdx + 1;\r\n				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;\r\n\r\n				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n				if ( ! insideAngle ) {\r\n\r\n					// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n					return	false;\r\n\r\n				}\r\n\r\n				// Check if shape point lies within angle around hole point\r\n				var lastHoleIdx = hole.length - 1;\r\n\r\n				var prevHoleIdx = inHoleIdx - 1;\r\n				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;\r\n\r\n				var nextHoleIdx = inHoleIdx + 1;\r\n				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;\r\n\r\n				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n				if ( ! insideAngle ) {\r\n\r\n					// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n					return	false;\r\n\r\n				}\r\n\r\n				return	true;\r\n\r\n			}\r\n\r\n			function intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\r\n				// checks for intersections with shape edges\r\n				var sIdx, nextIdx, intersection;\r\n				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\r\n					nextIdx = sIdx + 1; nextIdx %= shape.length;\r\n					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n					if ( intersection.length > 0 )		return	true;\r\n\r\n				}\r\n\r\n				return	false;\r\n\r\n			}\r\n\r\n			var indepHoles = [];\r\n\r\n			function intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\r\n				// checks for intersections with hole edges\r\n				var ihIdx, chkHole,\r\n					hIdx, nextIdx, intersection;\r\n				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\r\n					chkHole = holes[ indepHoles[ ihIdx ]];\r\n					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\r\n						nextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n						if ( intersection.length > 0 )		return	true;\r\n\r\n					}\r\n\r\n				}\r\n				return	false;\r\n\r\n			}\r\n\r\n			var holeIndex, shapeIndex,\r\n				shapePt, holePt,\r\n				holeIdx, cutKey, failedCuts = [],\r\n				tmpShape1, tmpShape2,\r\n				tmpHole1, tmpHole2;\r\n\r\n			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n				indepHoles.push( h );\r\n\r\n			}\r\n\r\n			var minShapeIndex = 0;\r\n			var counter = indepHoles.length * 2;\r\n			while ( indepHoles.length > 0 ) {\r\n\r\n				counter --;\r\n				if ( counter < 0 ) {\r\n\r\n					console.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n					break;\r\n\r\n				}\r\n\r\n				// search for shape-vertex and hole-vertex,\r\n				// which can be connected without intersections\r\n				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n					shapePt = shape[ shapeIndex ];\r\n					holeIndex	= - 1;\r\n\r\n					// search for hole which can be reached without intersections\r\n					for ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\r\n						holeIdx = indepHoles[ h ];\r\n\r\n						// prevent multiple checks\r\n						cutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n						if ( failedCuts[ cutKey ] !== undefined )			continue;\r\n\r\n						hole = holes[ holeIdx ];\r\n						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n							holePt = hole[ h2 ];\r\n							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;\r\n							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;\r\n							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;\r\n\r\n							holeIndex = h2;\r\n							indepHoles.splice( h, 1 );\r\n\r\n							tmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n							tmpShape2 = shape.slice( shapeIndex );\r\n							tmpHole1 = hole.slice( holeIndex );\r\n							tmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n							minShapeIndex = shapeIndex;\r\n\r\n							// Debug only, to show the selected cuts\r\n							// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n							break;\r\n\r\n						}\r\n						if ( holeIndex >= 0 )	break;		// hole-vertex found\r\n\r\n						failedCuts[ cutKey ] = true;			// remember failure\r\n\r\n					}\r\n					if ( holeIndex >= 0 )	break;		// hole-vertex found\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return shape; 			/* shape with no holes */\r\n\r\n		}\r\n\r\n\r\n		var i, il, f, face,\r\n			key, index,\r\n			allPointsMap = {};\r\n\r\n		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n		var allpoints = contour.concat();\r\n\r\n		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			Array.prototype.push.apply( allpoints, holes[ h ] );\r\n\r\n		}\r\n\r\n		//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n		// prepare all points map\r\n\r\n		for ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n			key = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n			if ( allPointsMap[ key ] !== undefined ) {\r\n\r\n				console.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n			}\r\n\r\n			allPointsMap[ key ] = i;\r\n\r\n		}\r\n\r\n		// remove holes by cutting paths to holes and adding them to the shape\r\n		var shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n		//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n		// check all face vertices against all points map\r\n\r\n		for ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n			face = triangles[ i ];\r\n\r\n			for ( f = 0; f < 3; f ++ ) {\r\n\r\n				key = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n				index = allPointsMap[ key ];\r\n\r\n				if ( index !== undefined ) {\r\n\r\n					face[ f ] = index;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return triangles.concat();\r\n\r\n	},\r\n\r\n	isClockWise: function ( pts ) {\r\n\r\n		return THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n	},\r\n\r\n	// Bezier Curves formulas obtained from\r\n	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n	// Quad Bezier Functions\r\n\r\n	b2p0: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return k * k * p;\r\n\r\n	},\r\n\r\n	b2p1: function ( t, p ) {\r\n\r\n		return 2 * ( 1 - t ) * t * p;\r\n\r\n	},\r\n\r\n	b2p2: function ( t, p ) {\r\n\r\n		return t * t * p;\r\n\r\n	},\r\n\r\n	b2: function ( t, p0, p1, p2 ) {\r\n\r\n		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n	},\r\n\r\n	// Cubic Bezier Functions\r\n\r\n	b3p0: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return k * k * k * p;\r\n\r\n	},\r\n\r\n	b3p1: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return 3 * k * k * t * p;\r\n\r\n	},\r\n\r\n	b3p2: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return 3 * k * t * t * p;\r\n\r\n	},\r\n\r\n	b3p3: function ( t, p ) {\r\n\r\n		return t * t * t * p;\r\n\r\n	},\r\n\r\n	b3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *	Line\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var point = this.v2.clone().sub( this.v1 );\r\n	point.multiplyScalar( t ).add( this.v1 );\r\n\r\n	return point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n	return this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tangent = this.v2.clone().sub( this.v1 );\r\n\r\n	return tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *	Quadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n	this.v0 = v0;\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n	vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n	return vector;\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n	vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n	// returns unit vector\r\n\r\n	return vector.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *	Cubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n	this.v0 = v0;\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n	this.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var tx, ty;\r\n\r\n	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n	return new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tx, ty;\r\n\r\n	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n	var tangent = new THREE.Vector2( tx, ty );\r\n	tangent.normalize();\r\n\r\n	return tangent;\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *	Spline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n	this.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var points = this.points;\r\n	var point = ( points.length - 1 ) * t;\r\n\r\n	var intPoint = Math.floor( point );\r\n	var weight = point - intPoint;\r\n\r\n	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n	var point1 = points[ intPoint ];\r\n	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n	vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\r\n	return vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *	Ellipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n	this.aX = aX;\r\n	this.aY = aY;\r\n\r\n	this.xRadius = xRadius;\r\n	this.yRadius = yRadius;\r\n\r\n	this.aStartAngle = aStartAngle;\r\n	this.aEndAngle = aEndAngle;\r\n\r\n	this.aClockwise = aClockwise;\r\n	\r\n	this.aRotation = aRotation || 0;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n	var angle;\r\n\r\n	if ( this.aClockwise === true ) {\r\n\r\n		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n	} else {\r\n\r\n		angle = this.aStartAngle + t * deltaAngle;\r\n\r\n	}\r\n	\r\n	var x = this.aX + this.xRadius * Math.cos( angle );\r\n	var y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n	if ( this.aRotation !== 0 ) {\r\n\r\n		var cos = Math.cos( this.aRotation );\r\n		var sin = Math.sin( this.aRotation );\r\n\r\n		var tx = x, ty = y;\r\n\r\n		// Rotate the point about the center of the ellipse.\r\n		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\r\n	}\r\n\r\n	return new THREE.Vector2( x, y );\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *	Arc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *	Line3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n	function ( v1, v2 ) {\r\n\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.subVectors( this.v2, this.v1 ); // diff\r\n		vector.multiplyScalar( t );\r\n		vector.add( this.v1 );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *	Quadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n	function ( v0, v1, v2 ) {\r\n\r\n		this.v0 = v0;\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n		vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *	Cubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n	function ( v0, v1, v2, v3 ) {\r\n\r\n		this.v0 = v0;\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n		this.v3 = v3;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n		vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n		vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *	Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n	function ( points /* array of Vector3 */ ) {\r\n\r\n		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n		this.points = ( points == undefined ) ? [] : points;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var points = this.points;\r\n		var point = ( points.length - 1 ) * t;\r\n\r\n		var intPoint = Math.floor( point );\r\n		var weight = point - intPoint;\r\n\r\n		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n		var point1 = points[ intPoint ];\r\n		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CatmullRomCurve3.js\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\nTHREE.CatmullRomCurve3 = ( function() {\r\n\r\n	var\r\n		tmp = new THREE.Vector3(),\r\n		px = new CubicPoly(),\r\n		py = new CubicPoly(),\r\n		pz = new CubicPoly();\r\n\r\n	/*\r\n	Based on an optimized c++ solution in\r\n	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n	 - http://ideone.com/NoEbVM\r\n\r\n	This CubicPoly class could be used for reusing some variables and calculations,\r\n	but for three.js curve use, it could be possible inlined and flatten into a single function call\r\n	which can be placed in CurveUtils.\r\n	*/\r\n\r\n	function CubicPoly() {\r\n\r\n	}\r\n\r\n	/*\r\n	 * Compute coefficients for a cubic polynomial\r\n	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n	 * such that\r\n	 *   p(0) = x0, p(1) = x1\r\n	 *  and\r\n	 *   p'(0) = t0, p'(1) = t1.\r\n	 */\r\n	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\r\n		this.c0 = x0;\r\n		this.c1 = t0;\r\n		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n	};\r\n\r\n	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n		// compute tangents when parameterized in [t1,t2]\r\n		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n		// rescale tangents for parametrization in [0,1]\r\n		t1 *= dt1;\r\n		t2 *= dt1;\r\n\r\n		// initCubicPoly\r\n		this.init( x1, x2, t1, t2 );\r\n\r\n	};\r\n\r\n	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\r\n		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n	};\r\n\r\n	CubicPoly.prototype.calc = function( t ) {\r\n\r\n		var t2 = t * t;\r\n		var t3 = t2 * t;\r\n		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\r\n	};\r\n\r\n	// Subclass Three.js curve\r\n	return THREE.Curve.create(\r\n\r\n		function ( p /* array of Vector3 */ ) {\r\n\r\n			this.points = p || [];\r\n\r\n		},\r\n\r\n		function ( t ) {\r\n\r\n			var points = this.points,\r\n				point, intPoint, weight, l;\r\n\r\n			l = points.length;\r\n\r\n			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\r\n			point = ( l - 1 ) * t;\r\n			intPoint = Math.floor( point );\r\n			weight = point - intPoint;\r\n\r\n			if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n				intPoint = l - 2;\r\n				weight = 1;\r\n\r\n			}\r\n\r\n			var p0, p1, p2, p3;\r\n\r\n			if ( intPoint === 0 ) {\r\n\r\n				// extrapolate first point\r\n				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n				p0 = tmp;\r\n\r\n			} else {\r\n\r\n				p0 = points[ intPoint - 1 ];\r\n\r\n			}\r\n\r\n			p1 = points[ intPoint ];\r\n			p2 = points[ intPoint + 1 ];\r\n\r\n			if ( intPoint + 2 < l ) {\r\n\r\n				p3 = points[ intPoint + 2 ]\r\n\r\n			} else {\r\n\r\n				// extrapolate last point\r\n				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );\r\n				p3 = tmp;\r\n\r\n			}\r\n\r\n			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\r\n				// init Centripetal / Chordal Catmull-Rom\r\n				var pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n				// safety check for repeated points\r\n				if ( dt1 < 1e-4 ) dt1 = 1.0;\r\n				if ( dt0 < 1e-4 ) dt0 = dt1;\r\n				if ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n			} else if ( this.type === 'catmullrom' ) {\r\n\r\n				var tension = this.tension !== undefined ? this.tension : 0.5;\r\n				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\r\n			}\r\n\r\n			var v = new THREE.Vector3(\r\n				px.calc( weight ),\r\n				py.calc( weight ),\r\n				pz.calc( weight )\r\n			);\r\n\r\n			return v;\r\n\r\n		}\r\n\r\n	);\r\n\r\n} )();\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *	Closed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n	function ( points /* array of Vector3 */ ) {\r\n\r\n		this.points = ( points == undefined ) ? [] : points;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var points = this.points;\r\n		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1\r\n\r\n		var intPoint = Math.floor( point );\r\n		var weight = point - intPoint;\r\n\r\n		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n		var point0 = points[ ( intPoint - 1 ) % points.length ];\r\n		var point1 = points[ ( intPoint     ) % points.length ];\r\n		var point2 = points[ ( intPoint + 1 ) % points.length ];\r\n		var point3 = points[ ( intPoint + 2 ) % points.length ];\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/animation/AnimationHandler.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = {\r\n\r\n	LINEAR: 0,\r\n	CATMULLROM: 1,\r\n	CATMULLROM_FORWARD: 2,\r\n\r\n	//\r\n\r\n	add: function () {\r\n\r\n		console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );\r\n\r\n	},\r\n	get: function () {\r\n\r\n		console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );\r\n\r\n	},\r\n	remove: function () {\r\n\r\n		console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );\r\n\r\n	},\r\n\r\n	//\r\n\r\n	animations: [],\r\n\r\n	init: function ( data ) {\r\n\r\n		if ( data.initialized === true ) return data;\r\n\r\n		// loop through all keys\r\n\r\n		for ( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n				// remove minus times\r\n\r\n				if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\r\n\r\n					 data.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n				}\r\n\r\n				// create quaternions\r\n\r\n				if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n				  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n					var quat = data.hierarchy[ h ].keys[ k ].rot;\r\n					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// prepare morph target keys\r\n\r\n			if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n				// get all used\r\n\r\n				var usedMorphTargets = {};\r\n\r\n				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n						usedMorphTargets[ morphTargetName ] = - 1;\r\n\r\n					}\r\n\r\n				}\r\n\r\n				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n				// set all used on all frames\r\n\r\n				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n					var influences = {};\r\n\r\n					for ( var morphTargetName in usedMorphTargets ) {\r\n\r\n						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n								break;\r\n\r\n							}\r\n\r\n						}\r\n\r\n						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n							influences[ morphTargetName ] = 0;\r\n\r\n						}\r\n\r\n					}\r\n\r\n					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n				}\r\n\r\n			}\r\n\r\n\r\n			// remove all keys that are on the same time\r\n\r\n			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n					data.hierarchy[ h ].keys.splice( k, 1 );\r\n					k --;\r\n\r\n				}\r\n\r\n			}\r\n\r\n\r\n			// set index\r\n\r\n			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n				data.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		data.initialized = true;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	parse: function ( root ) {\r\n\r\n		var parseRecurseHierarchy = function ( root, hierarchy ) {\r\n\r\n			hierarchy.push( root );\r\n\r\n			for ( var c = 0; c < root.children.length; c ++ )\r\n				parseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n		};\r\n\r\n		// setup hierarchy\r\n\r\n		var hierarchy = [];\r\n\r\n		if ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n			for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\r\n\r\n				hierarchy.push( root.skeleton.bones[ b ] );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			parseRecurseHierarchy( root, hierarchy );\r\n\r\n		}\r\n\r\n		return hierarchy;\r\n\r\n	},\r\n\r\n	play: function ( animation ) {\r\n\r\n		if ( this.animations.indexOf( animation ) === - 1 ) {\r\n\r\n			this.animations.push( animation );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	stop: function ( animation ) {\r\n\r\n		var index = this.animations.indexOf( animation );\r\n\r\n		if ( index !== - 1 ) {\r\n\r\n			this.animations.splice( index, 1 );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	update: function ( deltaTimeMS ) {\r\n\r\n		for ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n			this.animations[ i ].resetBlendWeights();\r\n\r\n		}\r\n\r\n		for ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n			this.animations[ i ].update( deltaTimeMS );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/animation/Animation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, data ) {\r\n\r\n	this.root = root;\r\n	this.data = THREE.AnimationHandler.init( data );\r\n	this.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n	this.currentTime = 0;\r\n	this.timeScale = 1;\r\n\r\n	this.isPlaying = false;\r\n	this.loop = true;\r\n	this.weight = 0;\r\n\r\n	this.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\r\n};\r\n\r\nTHREE.Animation.prototype = {\r\n\r\n	constructor: THREE.Animation,\r\n\r\n	keyTypes:  [ \"pos\", \"rot\", \"scl\" ],\r\n\r\n	play: function ( startTime, weight ) {\r\n\r\n		this.currentTime = startTime !== undefined ? startTime : 0;\r\n		this.weight = weight !== undefined ? weight : 1;\r\n\r\n		this.isPlaying = true;\r\n\r\n		this.reset();\r\n\r\n		THREE.AnimationHandler.play( this );\r\n\r\n	},\r\n\r\n	stop: function() {\r\n\r\n		this.isPlaying = false;\r\n\r\n		THREE.AnimationHandler.stop( this );\r\n\r\n	},\r\n\r\n	reset: function () {\r\n\r\n		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n			var object = this.hierarchy[ h ];\r\n\r\n			if ( object.animationCache === undefined ) {\r\n\r\n				object.animationCache = {\r\n					animations: {},\r\n					blending: {\r\n						positionWeight: 0.0,\r\n						quaternionWeight: 0.0,\r\n						scaleWeight: 0.0\r\n					}\r\n				};\r\n\r\n			}\r\n\r\n			var name = this.data.name;\r\n			var animations = object.animationCache.animations;\r\n			var animationCache = animations[ name ];\r\n\r\n			if ( animationCache === undefined ) {\r\n\r\n				animationCache = {\r\n					prevKey: { pos: 0, rot: 0, scl: 0 },\r\n					nextKey: { pos: 0, rot: 0, scl: 0 },\r\n					originalMatrix: object.matrix\r\n				};\r\n\r\n				animations[ name ] = animationCache;\r\n\r\n			}\r\n\r\n			// Get keys to match our current time\r\n\r\n			for ( var t = 0; t < 3; t ++ ) {\r\n\r\n				var type = this.keyTypes[ t ];\r\n\r\n				var prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n				var nextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n					prevKey = nextKey;\r\n					nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n				}\r\n\r\n				animationCache.prevKey[ type ] = prevKey;\r\n				animationCache.nextKey[ type ] = nextKey;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	resetBlendWeights: function () {\r\n\r\n		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n			var object = this.hierarchy[ h ];\r\n			var animationCache = object.animationCache;\r\n\r\n			if ( animationCache !== undefined ) {\r\n\r\n				var blending = animationCache.blending;\r\n\r\n				blending.positionWeight = 0.0;\r\n				blending.quaternionWeight = 0.0;\r\n				blending.scaleWeight = 0.0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	update: ( function() {\r\n\r\n		var points = [];\r\n		var target = new THREE.Vector3();\r\n		var newVector = new THREE.Vector3();\r\n		var newQuat = new THREE.Quaternion();\r\n\r\n		// Catmull-Rom spline\r\n\r\n		var interpolateCatmullRom = function ( points, scale ) {\r\n\r\n			var c = [], v3 = [],\r\n			point, intPoint, weight, w2, w3,\r\n			pa, pb, pc, pd;\r\n\r\n			point = ( points.length - 1 ) * scale;\r\n			intPoint = Math.floor( point );\r\n			weight = point - intPoint;\r\n\r\n			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n			c[ 1 ] = intPoint;\r\n			c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n			c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\r\n			pa = points[ c[ 0 ] ];\r\n			pb = points[ c[ 1 ] ];\r\n			pc = points[ c[ 2 ] ];\r\n			pd = points[ c[ 3 ] ];\r\n\r\n			w2 = weight * weight;\r\n			w3 = weight * w2;\r\n\r\n			v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n			v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n			v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\r\n			return v3;\r\n\r\n		};\r\n\r\n		var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n			var v0 = ( p2 - p0 ) * 0.5,\r\n				v1 = ( p3 - p1 ) * 0.5;\r\n\r\n			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n		};\r\n\r\n		return function ( delta ) {\r\n\r\n			if ( this.isPlaying === false ) return;\r\n\r\n			this.currentTime += delta * this.timeScale;\r\n\r\n			if ( this.weight === 0 )\r\n				return;\r\n\r\n			//\r\n\r\n			var duration = this.data.length;\r\n\r\n			if ( this.currentTime > duration || this.currentTime < 0 ) {\r\n\r\n				if ( this.loop ) {\r\n\r\n					this.currentTime %= duration;\r\n\r\n					if ( this.currentTime < 0 )\r\n						this.currentTime += duration;\r\n\r\n					this.reset();\r\n\r\n				} else {\r\n\r\n					this.stop();\r\n\r\n				}\r\n\r\n			}\r\n\r\n			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n				var object = this.hierarchy[ h ];\r\n				var animationCache = object.animationCache.animations[ this.data.name ];\r\n				var blending = object.animationCache.blending;\r\n\r\n				// loop through pos/rot/scl\r\n\r\n				for ( var t = 0; t < 3; t ++ ) {\r\n\r\n					// get keys\r\n\r\n					var type    = this.keyTypes[ t ];\r\n					var prevKey = animationCache.prevKey[ type ];\r\n					var nextKey = animationCache.nextKey[ type ];\r\n\r\n					if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\r\n						( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\r\n\r\n						prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n						nextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n							prevKey = nextKey;\r\n							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n						}\r\n\r\n						animationCache.prevKey[ type ] = prevKey;\r\n						animationCache.nextKey[ type ] = nextKey;\r\n\r\n					}\r\n\r\n					var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\r\n					var prevXYZ = prevKey[ type ];\r\n					var nextXYZ = nextKey[ type ];\r\n\r\n					if ( scale < 0 ) scale = 0;\r\n					if ( scale > 1 ) scale = 1;\r\n\r\n					// interpolate\r\n\r\n					if ( type === \"pos\" ) {\r\n\r\n						if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\r\n							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n							// blend\r\n							var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n							object.position.lerp( newVector, proportionalWeight );\r\n							blending.positionWeight += this.weight;\r\n\r\n						} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n									this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n							points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n							points[ 1 ] = prevXYZ;\r\n							points[ 2 ] = nextXYZ;\r\n							points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\r\n							scale = scale * 0.33 + 0.33;\r\n\r\n							var currentPoint = interpolateCatmullRom( points, scale );\r\n							var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n							blending.positionWeight += this.weight;\r\n\r\n							// blend\r\n\r\n							var vector = object.position;\r\n\r\n							vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\r\n							vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\r\n							vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\r\n\r\n							if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n								var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\r\n								target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n								target.sub( vector );\r\n								target.y = 0;\r\n								target.normalize();\r\n\r\n								var angle = Math.atan2( target.x, target.z );\r\n								object.rotation.set( 0, angle, 0 );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					} else if ( type === \"rot\" ) {\r\n\r\n						THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\r\n\r\n						// Avoid paying the cost of an additional slerp if we don't have to\r\n						if ( blending.quaternionWeight === 0 ) {\r\n\r\n							object.quaternion.copy( newQuat );\r\n							blending.quaternionWeight = this.weight;\r\n\r\n						} else {\r\n\r\n							var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\r\n							THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\r\n							blending.quaternionWeight += this.weight;\r\n\r\n						}\r\n\r\n					} else if ( type === \"scl\" ) {\r\n\r\n						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n						var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\r\n						object.scale.lerp( newVector, proportionalWeight );\r\n						blending.scaleWeight += this.weight;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return true;\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n	getNextKeyWith: function ( type, h, key ) {\r\n\r\n		var keys = this.data.hierarchy[ h ].keys;\r\n\r\n		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n			key = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n		} else {\r\n\r\n			key = key % keys.length;\r\n\r\n		}\r\n\r\n		for ( ; key < keys.length; key ++ ) {\r\n\r\n			if ( keys[ key ][ type ] !== undefined ) {\r\n\r\n				return keys[ key ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n	},\r\n\r\n	getPrevKeyWith: function ( type, h, key ) {\r\n\r\n		var keys = this.data.hierarchy[ h ].keys;\r\n\r\n		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n			this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n			key = key > 0 ? key : 0;\r\n\r\n		} else {\r\n\r\n			key = key >= 0 ? key : key + keys.length;\r\n\r\n		}\r\n\r\n\r\n		for ( ; key >= 0; key -- ) {\r\n\r\n			if ( keys[ key ][ type ] !== undefined ) {\r\n\r\n				return keys[ key ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/animation/KeyFrameAnimation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function ( data ) {\r\n\r\n	this.root = data.node;\r\n	this.data = THREE.AnimationHandler.init( data );\r\n	this.hierarchy = THREE.AnimationHandler.parse( this.root );\r\n	this.currentTime = 0;\r\n	this.timeScale = 0.001;\r\n	this.isPlaying = false;\r\n	this.isPaused = true;\r\n	this.loop = true;\r\n\r\n	// initialize to first keyframes\r\n\r\n	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n		var keys = this.data.hierarchy[ h ].keys,\r\n			sids = this.data.hierarchy[ h ].sids,\r\n			obj = this.hierarchy[ h ];\r\n\r\n		if ( keys.length && sids ) {\r\n\r\n			for ( var s = 0; s < sids.length; s ++ ) {\r\n\r\n				var sid = sids[ s ],\r\n					next = this.getNextKeyWith( sid, h, 0 );\r\n\r\n				if ( next ) {\r\n\r\n					next.apply( sid );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			obj.matrixAutoUpdate = false;\r\n			this.data.hierarchy[ h ].node.updateMatrix();\r\n			obj.matrixWorldNeedsUpdate = true;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.KeyFrameAnimation.prototype = {\r\n\r\n	constructor: THREE.KeyFrameAnimation,\r\n\r\n	play: function ( startTime ) {\r\n\r\n		this.currentTime = startTime !== undefined ? startTime : 0;\r\n\r\n		if ( this.isPlaying === false ) {\r\n\r\n			this.isPlaying = true;\r\n\r\n			// reset key cache\r\n\r\n			var h, hl = this.hierarchy.length,\r\n				object,\r\n				node;\r\n\r\n			for ( h = 0; h < hl; h ++ ) {\r\n\r\n				object = this.hierarchy[ h ];\r\n				node = this.data.hierarchy[ h ];\r\n\r\n				if ( node.animationCache === undefined ) {\r\n\r\n					node.animationCache = {};\r\n					node.animationCache.prevKey = null;\r\n					node.animationCache.nextKey = null;\r\n					node.animationCache.originalMatrix = object.matrix;\r\n\r\n				}\r\n\r\n				var keys = this.data.hierarchy[ h ].keys;\r\n\r\n				if ( keys.length ) {\r\n\r\n					node.animationCache.prevKey = keys[ 0 ];\r\n					node.animationCache.nextKey = keys[ 1 ];\r\n\r\n					this.startTime = Math.min( keys[ 0 ].time, this.startTime );\r\n					this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.update( 0 );\r\n\r\n		}\r\n\r\n		this.isPaused = false;\r\n\r\n		THREE.AnimationHandler.play( this );\r\n\r\n	},\r\n\r\n	stop: function () {\r\n\r\n		this.isPlaying = false;\r\n		this.isPaused  = false;\r\n\r\n		THREE.AnimationHandler.stop( this );\r\n\r\n		// reset JIT matrix and remove cache\r\n\r\n		for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\r\n\r\n			var obj = this.hierarchy[ h ];\r\n			var node = this.data.hierarchy[ h ];\r\n\r\n			if ( node.animationCache !== undefined ) {\r\n\r\n				var original = node.animationCache.originalMatrix;\r\n\r\n				original.copy( obj.matrix );\r\n				obj.matrix = original;\r\n\r\n				delete node.animationCache;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	update: function ( delta ) {\r\n\r\n		if ( this.isPlaying === false ) return;\r\n\r\n		this.currentTime += delta * this.timeScale;\r\n\r\n		//\r\n\r\n		var duration = this.data.length;\r\n\r\n		if ( this.loop === true && this.currentTime > duration ) {\r\n\r\n			this.currentTime %= duration;\r\n\r\n		}\r\n\r\n		this.currentTime = Math.min( this.currentTime, duration );\r\n\r\n		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n			var object = this.hierarchy[ h ];\r\n			var node = this.data.hierarchy[ h ];\r\n\r\n			var keys = node.keys,\r\n				animationCache = node.animationCache;\r\n\r\n\r\n			if ( keys.length ) {\r\n\r\n				var prevKey = animationCache.prevKey;\r\n				var nextKey = animationCache.nextKey;\r\n\r\n				if ( nextKey.time <= this.currentTime ) {\r\n\r\n					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n						prevKey = nextKey;\r\n						nextKey = keys[ prevKey.index + 1 ];\r\n\r\n					}\r\n\r\n					animationCache.prevKey = prevKey;\r\n					animationCache.nextKey = nextKey;\r\n\r\n				}\r\n\r\n				if ( nextKey.time >= this.currentTime ) {\r\n\r\n					prevKey.interpolate( nextKey, this.currentTime );\r\n\r\n				} else {\r\n\r\n					prevKey.interpolate( nextKey, nextKey.time );\r\n\r\n				}\r\n\r\n				this.data.hierarchy[ h ].node.updateMatrix();\r\n				object.matrixWorldNeedsUpdate = true;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getNextKeyWith: function ( sid, h, key ) {\r\n\r\n		var keys = this.data.hierarchy[ h ].keys;\r\n		key = key % keys.length;\r\n\r\n		for ( ; key < keys.length; key ++ ) {\r\n\r\n			if ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n				return keys[ key ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return keys[ 0 ];\r\n\r\n	},\r\n\r\n	getPrevKeyWith: function ( sid, h, key ) {\r\n\r\n		var keys = this.data.hierarchy[ h ].keys;\r\n		key = key >= 0 ? key : key + keys.length;\r\n\r\n		for ( ; key >= 0; key -- ) {\r\n\r\n			if ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n				return keys[ key ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return keys[ keys.length - 1 ];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/animation/MorphAnimation.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com\r\n * @author willy-vvu / http://willy-vvu.github.io\r\n */\r\n\r\nTHREE.MorphAnimation = function ( mesh ) {\r\n\r\n	this.mesh = mesh;\r\n	this.frames = mesh.morphTargetInfluences.length;\r\n	this.currentTime = 0;\r\n	this.duration = 1000;\r\n	this.loop = true;\r\n	this.lastFrame = 0;\r\n	this.currentFrame = 0;\r\n\r\n	this.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimation.prototype = {\r\n\r\n	constructor: THREE.MorphAnimation,\r\n\r\n	play: function () {\r\n\r\n		this.isPlaying = true;\r\n\r\n	},\r\n\r\n	pause: function () {\r\n\r\n		this.isPlaying = false;\r\n\r\n	},\r\n\r\n	update: function ( delta ) {\r\n\r\n		if ( this.isPlaying === false ) return;\r\n\r\n		this.currentTime += delta;\r\n\r\n		if ( this.loop === true && this.currentTime > this.duration ) {\r\n\r\n			this.currentTime %= this.duration;\r\n\r\n		}\r\n\r\n		this.currentTime = Math.min( this.currentTime, this.duration );\r\n\r\n		var frameTime = this.duration / this.frames;\r\n		var frame = Math.floor( this.currentTime / frameTime );\r\n\r\n		var influences = this.mesh.morphTargetInfluences;\r\n\r\n		if ( frame !== this.currentFrame ) {\r\n\r\n			influences[ this.lastFrame ] = 0;\r\n			influences[ this.currentFrame ] = 1;\r\n			influences[ frame ] = 0;\r\n\r\n			this.lastFrame = this.currentFrame;\r\n			this.currentFrame = frame;\r\n\r\n		}\r\n\r\n		var mix = ( this.currentTime % frameTime ) / frameTime;\r\n\r\n		influences[ frame ] = mix;\r\n		influences[ this.lastFrame ] = 1 - mix;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'BoxGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		depth: depth,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		depthSegments: depthSegments\r\n	};\r\n\r\n	this.widthSegments = widthSegments || 1;\r\n	this.heightSegments = heightSegments || 1;\r\n	this.depthSegments = depthSegments || 1;\r\n\r\n	var scope = this;\r\n\r\n	var width_half = width / 2;\r\n	var height_half = height / 2;\r\n	var depth_half = depth / 2;\r\n\r\n	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\r\n	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n		var w, ix, iy,\r\n		gridX = scope.widthSegments,\r\n		gridY = scope.heightSegments,\r\n		width_half = width / 2,\r\n		height_half = height / 2,\r\n		offset = scope.vertices.length;\r\n\r\n		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n			w = 'z';\r\n\r\n		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n			w = 'y';\r\n			gridY = scope.depthSegments;\r\n\r\n		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n			w = 'x';\r\n			gridX = scope.depthSegments;\r\n\r\n		}\r\n\r\n		var gridX1 = gridX + 1,\r\n		gridY1 = gridY + 1,\r\n		segment_width = width / gridX,\r\n		segment_height = height / gridY,\r\n		normal = new THREE.Vector3();\r\n\r\n		normal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n		for ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n			for ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n				var vector = new THREE.Vector3();\r\n				vector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n				vector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n				vector[ w ] = depth;\r\n\r\n				scope.vertices.push( vector );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n			for ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n				var a = ix + gridX1 * iy;\r\n				var b = ix + gridX1 * ( iy + 1 );\r\n				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n				var d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\r\n				var face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n				face.normal.copy( normal );\r\n				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n				face.materialIndex = materialIndex;\r\n\r\n				scope.faces.push( face );\r\n				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n				face = new THREE.Face3( b + offset, c + offset, d + offset );\r\n				face.normal.copy( normal );\r\n				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n				face.materialIndex = materialIndex;\r\n\r\n				scope.faces.push( face );\r\n				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\nTHREE.BoxGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.BoxGeometry(\r\n		this.parameters.width,\r\n		this.parameters.height,\r\n		this.parameters.depth,\r\n		this.parameters.widthSegments,\r\n		this.parameters.heightSegments,\r\n		this.parameters.depthSegments\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\nTHREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'CircleGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		segments: segments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radius = radius || 50;\r\n	segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	var i, uvs = [],\r\n	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n	this.vertices.push( center );\r\n	uvs.push( centerUV );\r\n\r\n	for ( i = 0; i <= segments; i ++ ) {\r\n\r\n		var vertex = new THREE.Vector3();\r\n		var segment = thetaStart + i / segments * thetaLength;\r\n\r\n		vertex.x = radius * Math.cos( segment );\r\n		vertex.y = radius * Math.sin( segment );\r\n\r\n		this.vertices.push( vertex );\r\n		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\r\n	}\r\n\r\n	var n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n	for ( i = 1; i <= segments; i ++ ) {\r\n\r\n		this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );\r\n		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\nTHREE.CircleGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.CircleGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.segments,\r\n		this.parameters.thetaStart,\r\n		this.parameters.thetaLength\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/CircleBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'CircleBufferGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		segments: segments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radius = radius || 50;\r\n	segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	var vertices = segments + 2;\r\n\r\n	var positions = new Float32Array( vertices * 3 );\r\n	var normals = new Float32Array( vertices * 3 );\r\n	var uvs = new Float32Array( vertices * 2 );\r\n\r\n	// center data is already zero, but need to set a few extras\r\n	normals[ 3 ] = 1.0;\r\n	uvs[ 0 ] = 0.5;\r\n	uvs[ 1 ] = 0.5;\r\n\r\n	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\r\n		var segment = thetaStart + s / segments * thetaLength;\r\n\r\n		positions[ i ] = radius * Math.cos( segment );\r\n		positions[ i + 1 ] = radius * Math.sin( segment );\r\n\r\n		normals[ i + 2 ] = 1; // normal z\r\n\r\n		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n	}\r\n\r\n	var indices = [];\r\n\r\n	for ( var i = 1; i <= segments; i ++ ) {\r\n\r\n		indices.push( i );\r\n		indices.push( i + 1 );\r\n		indices.push( 0 );\r\n\r\n	}\r\n\r\n	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\r\nTHREE.CircleBufferGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.CircleBufferGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.segments,\r\n		this.parameters.thetaStart,\r\n		this.parameters.thetaLength\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'CylinderGeometry';\r\n\r\n	this.parameters = {\r\n		radiusTop: radiusTop,\r\n		radiusBottom: radiusBottom,\r\n		height: height,\r\n		radialSegments: radialSegments,\r\n		heightSegments: heightSegments,\r\n		openEnded: openEnded,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n	height = height !== undefined ? height : 100;\r\n\r\n	radialSegments = radialSegments || 8;\r\n	heightSegments = heightSegments || 1;\r\n\r\n	openEnded = openEnded !== undefined ? openEnded : false;\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n	var heightHalf = height / 2;\r\n\r\n	var x, y, vertices = [], uvs = [];\r\n\r\n	for ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n		var verticesRow = [];\r\n		var uvsRow = [];\r\n\r\n		var v = y / heightSegments;\r\n		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n		for ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n			var u = x / radialSegments;\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n			vertex.y = - v * height + heightHalf;\r\n			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			verticesRow.push( this.vertices.length - 1 );\r\n			uvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n		}\r\n\r\n		vertices.push( verticesRow );\r\n		uvs.push( uvsRow );\r\n\r\n	}\r\n\r\n	var tanTheta = ( radiusBottom - radiusTop ) / height;\r\n	var na, nb;\r\n\r\n	for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n		if ( radiusTop !== 0 ) {\r\n\r\n			na = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n		} else {\r\n\r\n			na = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n		}\r\n\r\n		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n		for ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n			var v1 = vertices[ y ][ x ];\r\n			var v2 = vertices[ y + 1 ][ x ];\r\n			var v3 = vertices[ y + 1 ][ x + 1 ];\r\n			var v4 = vertices[ y ][ x + 1 ];\r\n\r\n			var n1 = na.clone();\r\n			var n2 = na.clone();\r\n			var n3 = nb.clone();\r\n			var n4 = nb.clone();\r\n\r\n			var uv1 = uvs[ y ][ x ].clone();\r\n			var uv2 = uvs[ y + 1 ][ x ].clone();\r\n			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n			var uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// top cap\r\n\r\n	if ( openEnded === false && radiusTop > 0 ) {\r\n\r\n		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n		for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ 0 ][ x ];\r\n			var v2 = vertices[ 0 ][ x + 1 ];\r\n			var v3 = this.vertices.length - 1;\r\n\r\n			var n1 = new THREE.Vector3( 0, 1, 0 );\r\n			var n2 = new THREE.Vector3( 0, 1, 0 );\r\n			var n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n			var uv1 = uvs[ 0 ][ x ].clone();\r\n			var uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n			var uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// bottom cap\r\n\r\n	if ( openEnded === false && radiusBottom > 0 ) {\r\n\r\n		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n		for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ heightSegments ][ x + 1 ];\r\n			var v2 = vertices[ heightSegments ][ x ];\r\n			var v3 = this.vertices.length - 1;\r\n\r\n			var n1 = new THREE.Vector3( 0, - 1, 0 );\r\n			var n2 = new THREE.Vector3( 0, - 1, 0 );\r\n			var n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n			var uv2 = uvs[ heightSegments ][ x ].clone();\r\n			var uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\nTHREE.CylinderGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.CylinderGeometry(\r\n		this.parameters.radiusTop,\r\n		this.parameters.radiusBottom,\r\n		this.parameters.height,\r\n		this.parameters.radialSegments,\r\n		this.parameters.heightSegments,\r\n		this.parameters.openEnded,\r\n		this.parameters.thetaStart,\r\n		this.parameters.thetaLength\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/EdgesGeometry.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n	var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\r\n	var edge = [ 0, 0 ], hash = {};\r\n	var sortFunction = function ( a, b ) {\r\n\r\n		return a - b;\r\n\r\n	};\r\n\r\n	var keys = [ 'a', 'b', 'c' ];\r\n\r\n	var geometry2;\r\n\r\n	if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n		geometry2 = new THREE.Geometry();\r\n		geometry2.fromBufferGeometry( geometry );\r\n\r\n	} else {\r\n\r\n		geometry2 = geometry.clone();\r\n\r\n	}\r\n\r\n	geometry2.mergeVertices();\r\n	geometry2.computeFaceNormals();\r\n\r\n	var vertices = geometry2.vertices;\r\n	var faces = geometry2.faces;\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		var face = faces[ i ];\r\n\r\n		for ( var j = 0; j < 3; j ++ ) {\r\n\r\n			edge[ 0 ] = face[ keys[ j ] ];\r\n			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n			edge.sort( sortFunction );\r\n\r\n			var key = edge.toString();\r\n\r\n			if ( hash[ key ] === undefined ) {\r\n\r\n				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n			} else {\r\n\r\n				hash[ key ].face2 = i;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var coords = [];\r\n\r\n	for ( var key in hash ) {\r\n\r\n		var h = hash[ key ];\r\n\r\n		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n			var vertex = vertices[ h.vert1 ];\r\n			coords.push( vertex.x );\r\n			coords.push( vertex.y );\r\n			coords.push( vertex.z );\r\n\r\n			vertex = vertices[ h.vert2 ];\r\n			coords.push( vertex.x );\r\n			coords.push( vertex.y );\r\n			coords.push( vertex.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\r\n};\r\n\r\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n	if ( typeof( shapes ) === \"undefined\" ) {\r\n\r\n		shapes = [];\r\n		return;\r\n\r\n	}\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ExtrudeGeometry';\r\n\r\n	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n	this.addShapeList( shapes, options );\r\n\r\n	this.computeFaceNormals();\r\n\r\n	// can't really use automatic vertex normals\r\n	// as then front and back sides get smoothed too\r\n	// should do separate smoothing just for sides\r\n\r\n	//this.computeVertexNormals();\r\n\r\n	//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n	var sl = shapes.length;\r\n\r\n	for ( var s = 0; s < sl; s ++ ) {\r\n\r\n		var shape = shapes[ s ];\r\n		this.addShape( shape, options );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n	var amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n	var steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n	var extrudePath = options.extrudePath;\r\n	var extrudePts, extrudeByPath = false;\r\n\r\n	// Use default WorldUVGenerator if no UV generators are specified.\r\n	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n	var splineTube, binormal, normal, position2;\r\n	if ( extrudePath ) {\r\n\r\n		extrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n		extrudeByPath = true;\r\n		bevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n		// SETUP TNB variables\r\n\r\n		// Reuse TNB from TubeGeomtry for now.\r\n		// TODO1 - have a .isClosed in spline?\r\n\r\n		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\r\n		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n		binormal = new THREE.Vector3();\r\n		normal = new THREE.Vector3();\r\n		position2 = new THREE.Vector3();\r\n\r\n	}\r\n\r\n	// Safeguards if bevels are not enabled\r\n\r\n	if ( ! bevelEnabled ) {\r\n\r\n		bevelSegments = 0;\r\n		bevelThickness = 0;\r\n		bevelSize = 0;\r\n\r\n	}\r\n\r\n	// Variables initialization\r\n\r\n	var ahole, h, hl; // looping of holes\r\n	var scope = this;\r\n\r\n	var shapesOffset = this.vertices.length;\r\n\r\n	var shapePoints = shape.extractPoints( curveSegments );\r\n\r\n	var vertices = shapePoints.shape;\r\n	var holes = shapePoints.holes;\r\n\r\n	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n	if ( reverse ) {\r\n\r\n		vertices = vertices.reverse();\r\n\r\n		// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n\r\n			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n				holes[ h ] = ahole.reverse();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n	}\r\n\r\n\r\n	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n	/* Vertices */\r\n\r\n	var contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n	for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n		ahole = holes[ h ];\r\n\r\n		vertices = vertices.concat( ahole );\r\n\r\n	}\r\n\r\n\r\n	function scalePt2 ( pt, vec, size ) {\r\n\r\n		if ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n		return vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n	}\r\n\r\n	var b, bs, t, z,\r\n		vert, vlen = vertices.length,\r\n		face, flen = faces.length;\r\n\r\n\r\n	// Find directions for point movement\r\n\r\n\r\n	function getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n		var EPSILON = 0.0000000001;\r\n\r\n		// computes for inPt the corresponding point inPt' on a new contour\r\n		//   shifted by 1 unit (length of normalized vector) to the left\r\n		// if we walk along contour clockwise, this new contour is outside the old one\r\n		//\r\n		// inPt' is the intersection of the two lines parallel to the two\r\n		//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt\r\n\r\n		// good reading for geometry algorithms (here: line-line intersection)\r\n		// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\r\n		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n		// check for collinear edges\r\n		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n		if ( Math.abs( collinear0 ) > EPSILON ) {\r\n\r\n			// not collinear\r\n\r\n			// length of vectors for normalizing\r\n\r\n			var v_prev_len = Math.sqrt( v_prev_lensq );\r\n			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n			// shift adjacent points by unit vectors to the left\r\n\r\n			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n			// scaling factor for v_prev to intersection point\r\n\r\n			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n			// vector from inPt to intersection point\r\n\r\n			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n			// Don't normalize!, otherwise sharp corners become ugly\r\n			//  but prevent crazy spikes\r\n			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n			if ( v_trans_lensq <= 2 ) {\r\n\r\n				return	new THREE.Vector2( v_trans_x, v_trans_y );\r\n\r\n			} else {\r\n\r\n				shrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// handle special case of collinear edges\r\n\r\n			var direction_eq = false;		// assumes: opposite\r\n			if ( v_prev_x > EPSILON ) {\r\n\r\n				if ( v_next_x > EPSILON ) {\r\n\r\n					direction_eq = true;\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				if ( v_prev_x < - EPSILON ) {\r\n\r\n					if ( v_next_x < - EPSILON ) {\r\n\r\n						direction_eq = true;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n						direction_eq = true;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( direction_eq ) {\r\n\r\n				// console.log(\"Warning: lines are a straight sequence\");\r\n				v_trans_x = - v_prev_y;\r\n				v_trans_y =  v_prev_x;\r\n				shrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n			} else {\r\n\r\n				// console.log(\"Warning: lines are a straight spike\");\r\n				v_trans_x = v_prev_x;\r\n				v_trans_y = v_prev_y;\r\n				shrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n	}\r\n\r\n\r\n	var contourMovements = [];\r\n\r\n	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n		if ( j === il ) j = 0;\r\n		if ( k === il ) k = 0;\r\n\r\n		//  (j)---(i)---(k)\r\n		// console.log('i,j,k', i, j , k)\r\n\r\n		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n	}\r\n\r\n	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n	for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n		ahole = holes[ h ];\r\n\r\n		oneHoleMovements = [];\r\n\r\n		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n			if ( j === il ) j = 0;\r\n			if ( k === il ) k = 0;\r\n\r\n			//  (j)---(i)---(k)\r\n			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n		}\r\n\r\n		holesMovements.push( oneHoleMovements );\r\n		verticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n	}\r\n\r\n\r\n	// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n	for ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n		//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n		t = b / bevelSegments;\r\n		z = bevelThickness * ( 1 - t );\r\n\r\n		//z = bevelThickness * t;\r\n		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n		//bs = bevelSize * t; // linear\r\n\r\n		// contract shape\r\n\r\n		for ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n			v( vert.x, vert.y,  - z );\r\n\r\n		}\r\n\r\n		// expand holes\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			oneHoleMovements = holesMovements[ h ];\r\n\r\n			for ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n				v( vert.x, vert.y,  - z );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	bs = bevelSize;\r\n\r\n	// Back facing vertices\r\n\r\n	for ( i = 0; i < vlen; i ++ ) {\r\n\r\n		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n		if ( ! extrudeByPath ) {\r\n\r\n			v( vert.x, vert.y, 0 );\r\n\r\n		} else {\r\n\r\n			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n			v( position2.x, position2.y, position2.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Add stepped vertices...\r\n	// Including front facing vertices\r\n\r\n	var s;\r\n\r\n	for ( s = 1; s <= steps; s ++ ) {\r\n\r\n		for ( i = 0; i < vlen; i ++ ) {\r\n\r\n			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n			if ( ! extrudeByPath ) {\r\n\r\n				v( vert.x, vert.y, amount / steps * s );\r\n\r\n			} else {\r\n\r\n				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n				v( position2.x, position2.y, position2.z );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Add bevel segments planes\r\n\r\n	//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n	for ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n		t = b / bevelSegments;\r\n		z = bevelThickness * ( 1 - t );\r\n		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n		bs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\r\n		// contract shape\r\n\r\n		for ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n			v( vert.x, vert.y,  amount + z );\r\n\r\n		}\r\n\r\n		// expand holes\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			oneHoleMovements = holesMovements[ h ];\r\n\r\n			for ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n				if ( ! extrudeByPath ) {\r\n\r\n					v( vert.x, vert.y,  amount + z );\r\n\r\n				} else {\r\n\r\n					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	/* Faces */\r\n\r\n	// Top and bottom faces\r\n\r\n	buildLidFaces();\r\n\r\n	// Sides faces\r\n\r\n	buildSideFaces();\r\n\r\n\r\n	/////  Internal functions\r\n\r\n	function buildLidFaces() {\r\n\r\n		if ( bevelEnabled ) {\r\n\r\n			var layer = 0; // steps + 1\r\n			var offset = vlen * layer;\r\n\r\n			// Bottom faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n			}\r\n\r\n			layer = steps + bevelSegments * 2;\r\n			offset = vlen * layer;\r\n\r\n			// Top faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// Bottom faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n			}\r\n\r\n			// Top faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Create faces for the z-sides of the shape\r\n\r\n	function buildSideFaces() {\r\n\r\n		var layeroffset = 0;\r\n		sidewalls( contour, layeroffset );\r\n		layeroffset += contour.length;\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			sidewalls( ahole, layeroffset );\r\n\r\n			//, true\r\n			layeroffset += ahole.length;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function sidewalls( contour, layeroffset ) {\r\n\r\n		var j, k;\r\n		i = contour.length;\r\n\r\n		while ( -- i >= 0 ) {\r\n\r\n			j = i;\r\n			k = i - 1;\r\n			if ( k < 0 ) k = contour.length - 1;\r\n\r\n			//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n			var s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n			for ( s = 0; s < sl; s ++ ) {\r\n\r\n				var slen1 = vlen * s;\r\n				var slen2 = vlen * ( s + 1 );\r\n\r\n				var a = layeroffset + j + slen1,\r\n					b = layeroffset + k + slen1,\r\n					c = layeroffset + k + slen2,\r\n					d = layeroffset + j + slen2;\r\n\r\n				f4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	function v( x, y, z ) {\r\n\r\n		scope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n	}\r\n\r\n	function f3( a, b, c ) {\r\n\r\n		a += shapesOffset;\r\n		b += shapesOffset;\r\n		c += shapesOffset;\r\n\r\n		scope.faces.push( new THREE.Face3( a, b, c ) );\r\n\r\n		var uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n		scope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n	}\r\n\r\n	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n		a += shapesOffset;\r\n		b += shapesOffset;\r\n		c += shapesOffset;\r\n		d += shapesOffset;\r\n\r\n		scope.faces.push( new THREE.Face3( a, b, d ) );\r\n		scope.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n	generateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n		var vertices = geometry.vertices;\r\n\r\n		var a = vertices[ indexA ];\r\n		var b = vertices[ indexB ];\r\n		var c = vertices[ indexC ];\r\n\r\n		return [\r\n			new THREE.Vector2( a.x, a.y ),\r\n			new THREE.Vector2( b.x, b.y ),\r\n			new THREE.Vector2( c.x, c.y )\r\n		];\r\n\r\n	},\r\n\r\n	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n		var vertices = geometry.vertices;\r\n\r\n		var a = vertices[ indexA ];\r\n		var b = vertices[ indexB ];\r\n		var c = vertices[ indexC ];\r\n		var d = vertices[ indexD ];\r\n\r\n		if ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\r\n			return [\r\n				new THREE.Vector2( a.x, 1 - a.z ),\r\n				new THREE.Vector2( b.x, 1 - b.z ),\r\n				new THREE.Vector2( c.x, 1 - c.z ),\r\n				new THREE.Vector2( d.x, 1 - d.z )\r\n			];\r\n\r\n		} else {\r\n\r\n			return [\r\n				new THREE.Vector2( a.y, 1 - a.z ),\r\n				new THREE.Vector2( b.y, 1 - b.z ),\r\n				new THREE.Vector2( c.y, 1 - c.z ),\r\n				new THREE.Vector2( d.y, 1 - d.z )\r\n			];\r\n\r\n		}\r\n\r\n	}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *	material: <int> // material index for front and back faces\r\n *	uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ShapeGeometry';\r\n\r\n	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\r\n	this.addShapeList( shapes, options );\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n	for ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n		this.addShape( shapes[ i ], options );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n	if ( options === undefined ) options = {};\r\n	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n	var material = options.material;\r\n	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n	//\r\n\r\n	var i, l, hole;\r\n\r\n	var shapesOffset = this.vertices.length;\r\n	var shapePoints = shape.extractPoints( curveSegments );\r\n\r\n	var vertices = shapePoints.shape;\r\n	var holes = shapePoints.holes;\r\n\r\n	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n	if ( reverse ) {\r\n\r\n		vertices = vertices.reverse();\r\n\r\n		// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n		for ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n			hole = holes[ i ];\r\n\r\n			if ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n				holes[ i ] = hole.reverse();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		reverse = false;\r\n\r\n	}\r\n\r\n	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n	// Vertices\r\n\r\n	for ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n		hole = holes[ i ];\r\n		vertices = vertices.concat( hole );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var vert, vlen = vertices.length;\r\n	var face, flen = faces.length;\r\n\r\n	for ( i = 0; i < vlen; i ++ ) {\r\n\r\n		vert = vertices[ i ];\r\n\r\n		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n	}\r\n\r\n	for ( i = 0; i < flen; i ++ ) {\r\n\r\n		face = faces[ i ];\r\n\r\n		var a = face[ 0 ] + shapesOffset;\r\n		var b = face[ 1 ] + shapesOffset;\r\n		var c = face[ 2 ] + shapesOffset;\r\n\r\n		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'LatheGeometry';\r\n\r\n	this.parameters = {\r\n		points: points,\r\n		segments: segments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength\r\n	};\r\n\r\n	segments = segments || 12;\r\n	phiStart = phiStart || 0;\r\n	phiLength = phiLength || 2 * Math.PI;\r\n\r\n	var inversePointLength = 1.0 / ( points.length - 1 );\r\n	var inverseSegments = 1.0 / segments;\r\n\r\n	for ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n		var phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n		var c = Math.cos( phi ),\r\n			s = Math.sin( phi );\r\n\r\n		for ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n			var pt = points[ j ];\r\n\r\n			var vertex = new THREE.Vector3();\r\n\r\n			vertex.x = c * pt.x - s * pt.y;\r\n			vertex.y = s * pt.x + c * pt.y;\r\n			vertex.z = pt.z;\r\n\r\n			this.vertices.push( vertex );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var np = points.length;\r\n\r\n	for ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n			var base = j + np * i;\r\n			var a = base;\r\n			var b = base + np;\r\n			var c = base + 1 + np;\r\n			var d = base + 1;\r\n\r\n			var u0 = i * inverseSegments;\r\n			var v0 = j * inversePointLength;\r\n			var u1 = u0 + inverseSegments;\r\n			var v1 = v0 + inversePointLength;\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n\r\n			this.faceVertexUvs[ 0 ].push( [\r\n\r\n				new THREE.Vector2( u0, v0 ),\r\n				new THREE.Vector2( u1, v0 ),\r\n				new THREE.Vector2( u0, v1 )\r\n\r\n			] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n			this.faceVertexUvs[ 0 ].push( [\r\n\r\n				new THREE.Vector2( u1, v0 ),\r\n				new THREE.Vector2( u1, v1 ),\r\n				new THREE.Vector2( u0, v1 )\r\n\r\n			] );\r\n\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.mergeVertices();\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'PlaneGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments\r\n	};\r\n\r\n	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\nTHREE.PlaneGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.PlaneGeometry(\r\n		this.parameters.width,\r\n		this.parameters.height,\r\n		this.parameters.widthSegments,\r\n		this.parameters.heightSegments\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'PlaneBufferGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments\r\n	};\r\n\r\n	var width_half = width / 2;\r\n	var height_half = height / 2;\r\n\r\n	var gridX = Math.floor( widthSegments ) || 1;\r\n	var gridY = Math.floor( heightSegments ) || 1;\r\n\r\n	var gridX1 = gridX + 1;\r\n	var gridY1 = gridY + 1;\r\n\r\n	var segment_width = width / gridX;\r\n	var segment_height = height / gridY;\r\n\r\n	var vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n	var normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n	var uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n	var offset = 0;\r\n	var offset2 = 0;\r\n\r\n	for ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n		var y = iy * segment_height - height_half;\r\n\r\n		for ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n			var x = ix * segment_width - width_half;\r\n\r\n			vertices[ offset ] = x;\r\n			vertices[ offset + 1 ] = - y;\r\n\r\n			normals[ offset + 2 ] = 1;\r\n\r\n			uvs[ offset2 ] = ix / gridX;\r\n			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n			offset += 3;\r\n			offset2 += 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	offset = 0;\r\n\r\n	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n	for ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n		for ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n			var a = ix + gridX1 * iy;\r\n			var b = ix + gridX1 * ( iy + 1 );\r\n			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n			var d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n			indices[ offset ] = a;\r\n			indices[ offset + 1 ] = b;\r\n			indices[ offset + 2 ] = d;\r\n\r\n			indices[ offset + 3 ] = b;\r\n			indices[ offset + 4 ] = c;\r\n			indices[ offset + 5 ] = d;\r\n\r\n			offset += 6;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\nTHREE.PlaneBufferGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.PlaneBufferGeometry(\r\n		this.parameters.width,\r\n		this.parameters.height,\r\n		this.parameters.widthSegments,\r\n		this.parameters.heightSegments\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'RingGeometry';\r\n\r\n	this.parameters = {\r\n		innerRadius: innerRadius,\r\n		outerRadius: outerRadius,\r\n		thetaSegments: thetaSegments,\r\n		phiSegments: phiSegments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	innerRadius = innerRadius || 0;\r\n	outerRadius = outerRadius || 50;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\r\n	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\r\n	for ( i = 0; i < phiSegments + 1; i ++ ) {\r\n\r\n		// concentric circles inside ring\r\n\r\n		for ( o = 0; o < thetaSegments + 1; o ++ ) {\r\n\r\n			// number of segments per circle\r\n\r\n			var vertex = new THREE.Vector3();\r\n			var segment = thetaStart + o / thetaSegments * thetaLength;\r\n			vertex.x = radius * Math.cos( segment );\r\n			vertex.y = radius * Math.sin( segment );\r\n\r\n			this.vertices.push( vertex );\r\n			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\r\n		}\r\n\r\n		radius += radiusStep;\r\n\r\n	}\r\n\r\n	var n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n	for ( i = 0; i < phiSegments; i ++ ) {\r\n\r\n		// concentric circles inside ring\r\n\r\n		var thetaSegment = i * ( thetaSegments + 1 );\r\n\r\n		for ( o = 0; o < thetaSegments ; o ++ ) {\r\n\r\n			// number of segments per circle\r\n\r\n			var segment = o + thetaSegment;\r\n\r\n			var v1 = segment;\r\n			var v2 = segment + thetaSegments + 1;\r\n			var v3 = segment + thetaSegments + 2;\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );\r\n\r\n			v1 = segment;\r\n			v2 = segment + thetaSegments + 2;\r\n			v3 = segment + 1;\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\nTHREE.RingGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.RingGeometry(\r\n		this.parameters.innerRadius,\r\n		this.parameters.outerRadius,\r\n		this.parameters.thetaSegments,\r\n		this.parameters.phiSegments,\r\n		this.parameters.thetaStart,\r\n		this.parameters.thetaLength\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'SphereGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\nTHREE.SphereGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.SphereGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.widthSegments,\r\n		this.parameters.heightSegments,\r\n		this.parameters.phiStart,\r\n		this.parameters.phiLength,\r\n		this.parameters.thetaStart,\r\n		this.parameters.thetaLength\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/SphereBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * based on THREE.SphereGeometry\r\n */\r\n\r\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'SphereBufferGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radius = radius || 50;\r\n\r\n	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n	phiStart = phiStart !== undefined ? phiStart : 0;\r\n	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n	var thetaEnd = thetaStart + thetaLength;\r\n\r\n	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\r\n	var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n	var index = 0, vertices = [], normal = new THREE.Vector3();\r\n\r\n	for ( var y = 0; y <= heightSegments; y ++ ) {\r\n\r\n		var verticesRow = [];\r\n\r\n		var v = y / heightSegments;\r\n\r\n		for ( var x = 0; x <= widthSegments; x ++ ) {\r\n\r\n			var u = x / widthSegments;\r\n\r\n			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n			var py = radius * Math.cos( thetaStart + v * thetaLength );\r\n			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n			normal.set( px, py, pz ).normalize();\r\n\r\n			positions.setXYZ( index, px, py, pz );\r\n			normals.setXYZ( index, normal.x, normal.y, normal.z );\r\n			uvs.setXY( index, u, 1 - v );\r\n\r\n			verticesRow.push( index );\r\n\r\n			index ++;\r\n\r\n		}\r\n\r\n		vertices.push( verticesRow );\r\n\r\n	}\r\n\r\n	var indices = [];\r\n\r\n	for ( var y = 0; y < heightSegments; y ++ ) {\r\n\r\n		for ( var x = 0; x < widthSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ y ][ x + 1 ];\r\n			var v2 = vertices[ y ][ x ];\r\n			var v3 = vertices[ y + 1 ][ x ];\r\n			var v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n	this.addAttribute( 'position', positions );\r\n	this.addAttribute( 'normal', normals );\r\n	this.addAttribute( 'uv', uvs );\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\r\nTHREE.SphereBufferGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.SphereBufferGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.widthSegments,\r\n		this.parameters.heightSegments,\r\n		this.parameters.phiStart,\r\n		this.parameters.phiLength,\r\n		this.parameters.thetaStart,\r\n		this.parameters.thetaLength\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: 			<float>, 	// size of the text\r\n *  height: 		<float>, 	// thickness to extrude text\r\n *  curveSegments: 	<int>,		// number of points on the curves\r\n *\r\n *  font: 			<string>,		// font name\r\n *  weight: 		<string>,		// font weight (normal, bold)\r\n *  style: 			<string>,		// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:	<bool>,			// turn on bevel\r\n *  bevelThickness: <float>, 		// how deep into text bevel goes\r\n *  bevelSize:		<float>, 		// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*	Usage Examples\r\n\r\n	// TextGeometry wrapper\r\n\r\n	var text3d = new TextGeometry( text, options );\r\n\r\n	// Complete manner\r\n\r\n	var textShapes = THREE.FontUtils.generateShapes( text, options );\r\n	var text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n	parameters = parameters || {};\r\n\r\n	var textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n	// translate parameters to ExtrudeGeometry API\r\n\r\n	parameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n	// defaults\r\n\r\n	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n	THREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n	this.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TorusGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		tube: tube,\r\n		radialSegments: radialSegments,\r\n		tubularSegments: tubularSegments,\r\n		arc: arc\r\n	};\r\n\r\n	radius = radius || 100;\r\n	tube = tube || 40;\r\n	radialSegments = radialSegments || 8;\r\n	tubularSegments = tubularSegments || 6;\r\n	arc = arc || Math.PI * 2;\r\n\r\n	var center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n	for ( var j = 0; j <= radialSegments; j ++ ) {\r\n\r\n		for ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n			var u = i / tubularSegments * arc;\r\n			var v = j / radialSegments * Math.PI * 2;\r\n\r\n			center.x = radius * Math.cos( u );\r\n			center.y = radius * Math.sin( u );\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n			vertex.z = tube * Math.sin( v );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n			normals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var j = 1; j <= radialSegments; j ++ ) {\r\n\r\n		for ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n			var a = ( tubularSegments + 1 ) * j + i - 1;\r\n			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n			var d = ( tubularSegments + 1 ) * j + i;\r\n\r\n			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n			this.faces.push( face );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\r\n			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n			this.faces.push( face );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\nTHREE.TorusGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.TorusGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.tube,\r\n		this.parameters.radialSegments,\r\n		this.parameters.tubularSegments,\r\n		this.parameters.arc\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TorusKnotGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		tube: tube,\r\n		radialSegments: radialSegments,\r\n		tubularSegments: tubularSegments,\r\n		p: p,\r\n		q: q,\r\n		heightScale: heightScale\r\n	};\r\n\r\n	radius = radius || 100;\r\n	tube = tube || 40;\r\n	radialSegments = radialSegments || 64;\r\n	tubularSegments = tubularSegments || 8;\r\n	p = p || 2;\r\n	q = q || 3;\r\n	heightScale = heightScale || 1;\r\n\r\n	var grid = new Array( radialSegments );\r\n	var tang = new THREE.Vector3();\r\n	var n = new THREE.Vector3();\r\n	var bitan = new THREE.Vector3();\r\n\r\n	for ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n		grid[ i ] = new Array( tubularSegments );\r\n		var u = i / radialSegments * 2 * p * Math.PI;\r\n		var p1 = getPos( u, q, p, radius, heightScale );\r\n		var p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n		tang.subVectors( p2, p1 );\r\n		n.addVectors( p2, p1 );\r\n\r\n		bitan.crossVectors( tang, n );\r\n		n.crossVectors( bitan, tang );\r\n		bitan.normalize();\r\n		n.normalize();\r\n\r\n		for ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n			var v = j / tubularSegments * 2 * Math.PI;\r\n			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n			var cy = tube * Math.sin( v );\r\n\r\n			var pos = new THREE.Vector3();\r\n			pos.x = p1.x + cx * n.x + cy * bitan.x;\r\n			pos.y = p1.y + cx * n.y + cy * bitan.y;\r\n			pos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\r\n			grid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n		for ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n			var ip = ( i + 1 ) % radialSegments;\r\n			var jp = ( j + 1 ) % tubularSegments;\r\n\r\n			var a = grid[ i ][ j ];\r\n			var b = grid[ ip ][ j ];\r\n			var c = grid[ ip ][ jp ];\r\n			var d = grid[ i ][ jp ];\r\n\r\n			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n	function getPos( u, in_q, in_p, radius, heightScale ) {\r\n\r\n		var cu = Math.cos( u );\r\n		var su = Math.sin( u );\r\n		var quOverP = in_q / in_p * u;\r\n		var cs = Math.cos( quOverP );\r\n\r\n		var tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n		var ty = radius * ( 2 + cs ) * su * 0.5;\r\n		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n		return new THREE.Vector3( tx, ty, tz );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\nTHREE.TorusKnotGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.TorusKnotGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.tube,\r\n		this.parameters.radialSegments,\r\n		this.parameters.tubularSegments,\r\n		this.parameters.p,\r\n		this.parameters.q,\r\n		this.parameters.heightScale\r\n	);\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TubeGeometry';\r\n\r\n	this.parameters = {\r\n		path: path,\r\n		segments: segments,\r\n		radius: radius,\r\n		radialSegments: radialSegments,\r\n		closed: closed\r\n	};\r\n\r\n	segments = segments || 64;\r\n	radius = radius || 1;\r\n	radialSegments = radialSegments || 8;\r\n	closed = closed || false;\r\n	taper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n	var grid = [];\r\n\r\n	var scope = this,\r\n\r\n		tangent,\r\n		normal,\r\n		binormal,\r\n\r\n		numpoints = segments + 1,\r\n\r\n		u, v, r,\r\n\r\n		cx, cy,\r\n		pos, pos2 = new THREE.Vector3(),\r\n		i, j,\r\n		ip, jp,\r\n		a, b, c, d,\r\n		uva, uvb, uvc, uvd;\r\n\r\n	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n		tangents = frames.tangents,\r\n		normals = frames.normals,\r\n		binormals = frames.binormals;\r\n\r\n	// proxy internals\r\n	this.tangents = tangents;\r\n	this.normals = normals;\r\n	this.binormals = binormals;\r\n\r\n	function vert( x, y, z ) {\r\n\r\n		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n	}\r\n\r\n	// construct the grid\r\n\r\n	for ( i = 0; i < numpoints; i ++ ) {\r\n\r\n		grid[ i ] = [];\r\n\r\n		u = i / ( numpoints - 1 );\r\n\r\n		pos = path.getPointAt( u );\r\n\r\n		tangent = tangents[ i ];\r\n		normal = normals[ i ];\r\n		binormal = binormals[ i ];\r\n\r\n		r = radius * taper( u );\r\n\r\n		for ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n			v = j / radialSegments * 2 * Math.PI;\r\n\r\n			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n			cy = r * Math.sin( v );\r\n\r\n			pos2.copy( pos );\r\n			pos2.x += cx * normal.x + cy * binormal.x;\r\n			pos2.y += cx * normal.y + cy * binormal.y;\r\n			pos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// construct the mesh\r\n\r\n	for ( i = 0; i < segments; i ++ ) {\r\n\r\n		for ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n			jp = ( j + 1 ) % radialSegments;\r\n\r\n			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***\r\n			b = grid[ ip ][ j ];\r\n			c = grid[ ip ][ jp ];\r\n			d = grid[ i ][ jp ];\r\n\r\n			uva = new THREE.Vector2( i / segments, j / radialSegments );\r\n			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n	return 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n	return Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n	var	normal = new THREE.Vector3(),\r\n\r\n		tangents = [],\r\n		normals = [],\r\n		binormals = [],\r\n\r\n		vec = new THREE.Vector3(),\r\n		mat = new THREE.Matrix4(),\r\n\r\n		numpoints = segments + 1,\r\n		theta,\r\n		epsilon = 0.0001,\r\n		smallest,\r\n\r\n		tx, ty, tz,\r\n		i, u;\r\n\r\n\r\n	// expose internals\r\n	this.tangents = tangents;\r\n	this.normals = normals;\r\n	this.binormals = binormals;\r\n\r\n	// compute the tangent vectors for each segment on the path\r\n\r\n	for ( i = 0; i < numpoints; i ++ ) {\r\n\r\n		u = i / ( numpoints - 1 );\r\n\r\n		tangents[ i ] = path.getTangentAt( u );\r\n		tangents[ i ].normalize();\r\n\r\n	}\r\n\r\n	initialNormal3();\r\n\r\n	/*\r\n	function initialNormal1(lastBinormal) {\r\n		// fixed start binormal. Has dangers of 0 vectors\r\n		normals[ 0 ] = new THREE.Vector3();\r\n		binormals[ 0 ] = new THREE.Vector3();\r\n		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n	}\r\n\r\n	function initialNormal2() {\r\n\r\n		// This uses the Frenet-Serret formula for deriving binormal\r\n		var t2 = path.getTangentAt( epsilon );\r\n\r\n		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n	}\r\n	*/\r\n\r\n	function initialNormal3() {\r\n\r\n		// select an initial normal vector perpendicular to the first tangent vector,\r\n		// and in the direction of the smallest tangent xyz component\r\n\r\n		normals[ 0 ] = new THREE.Vector3();\r\n		binormals[ 0 ] = new THREE.Vector3();\r\n		smallest = Number.MAX_VALUE;\r\n		tx = Math.abs( tangents[ 0 ].x );\r\n		ty = Math.abs( tangents[ 0 ].y );\r\n		tz = Math.abs( tangents[ 0 ].z );\r\n\r\n		if ( tx <= smallest ) {\r\n\r\n			smallest = tx;\r\n			normal.set( 1, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( ty <= smallest ) {\r\n\r\n			smallest = ty;\r\n			normal.set( 0, 1, 0 );\r\n\r\n		}\r\n\r\n		if ( tz <= smallest ) {\r\n\r\n			normal.set( 0, 0, 1 );\r\n\r\n		}\r\n\r\n		vec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n		normals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n	}\r\n\r\n\r\n	// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n	for ( i = 1; i < numpoints; i ++ ) {\r\n\r\n		normals[ i ] = normals[ i - 1 ].clone();\r\n\r\n		binormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n		if ( vec.length() > epsilon ) {\r\n\r\n			vec.normalize();\r\n\r\n			theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n		}\r\n\r\n		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n	}\r\n\r\n\r\n	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n	if ( closed ) {\r\n\r\n		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n		theta /= ( numpoints - 1 );\r\n\r\n		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n			theta = - theta;\r\n\r\n		}\r\n\r\n		for ( i = 1; i < numpoints; i ++ ) {\r\n\r\n			// twist a little...\r\n			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'PolyhedronGeometry';\r\n\r\n	this.parameters = {\r\n		vertices: vertices,\r\n		indices: indices,\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n	radius = radius || 1;\r\n	detail = detail || 0;\r\n\r\n	var that = this;\r\n\r\n	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n	}\r\n\r\n	var p = this.vertices;\r\n\r\n	var faces = [];\r\n\r\n	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n		var v1 = p[ indices[ i ] ];\r\n		var v2 = p[ indices[ i + 1 ] ];\r\n		var v3 = p[ indices[ i + 2 ] ];\r\n\r\n		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\r\n	}\r\n\r\n	var centroid = new THREE.Vector3();\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		subdivide( faces[ i ], detail );\r\n\r\n	}\r\n\r\n\r\n	// Handle case when face straddles the seam\r\n\r\n	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n		var uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n		var x0 = uvs[ 0 ].x;\r\n		var x1 = uvs[ 1 ].x;\r\n		var x2 = uvs[ 2 ].x;\r\n\r\n		var max = Math.max( x0, Math.max( x1, x2 ) );\r\n		var min = Math.min( x0, Math.min( x1, x2 ) );\r\n\r\n		if ( max > 0.9 && min < 0.1 ) {\r\n\r\n			// 0.9 is somewhat arbitrary\r\n\r\n			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Apply radius\r\n\r\n	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n		this.vertices[ i ].multiplyScalar( radius );\r\n\r\n	}\r\n\r\n\r\n	// Merge vertices\r\n\r\n	this.mergeVertices();\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n	// Project vector onto sphere's surface\r\n\r\n	function prepare( vector ) {\r\n\r\n		var vertex = vector.normalize().clone();\r\n		vertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n		var u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n		var v = inclination( vector ) / Math.PI + 0.5;\r\n		vertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n		return vertex;\r\n\r\n	}\r\n\r\n\r\n	// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n	function make( v1, v2, v3, materialIndex ) {\r\n\r\n		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n		that.faces.push( face );\r\n\r\n		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n		var azi = azimuth( centroid );\r\n\r\n		that.faceVertexUvs[ 0 ].push( [\r\n			correctUV( v1.uv, v1, azi ),\r\n			correctUV( v2.uv, v2, azi ),\r\n			correctUV( v3.uv, v3, azi )\r\n		] );\r\n\r\n	}\r\n\r\n\r\n	// Analytically subdivide a face to the required detail level.\r\n\r\n	function subdivide( face, detail ) {\r\n\r\n		var cols = Math.pow( 2, detail );\r\n		var a = prepare( that.vertices[ face.a ] );\r\n		var b = prepare( that.vertices[ face.b ] );\r\n		var c = prepare( that.vertices[ face.c ] );\r\n		var v = [];\r\n\r\n		var materialIndex = face.materialIndex;\r\n\r\n		// Construct all of the vertices for this subdivision.\r\n\r\n		for ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n			v[ i ] = [];\r\n\r\n			var aj = prepare( a.clone().lerp( c, i / cols ) );\r\n			var bj = prepare( b.clone().lerp( c, i / cols ) );\r\n			var rows = cols - i;\r\n\r\n			for ( var j = 0; j <= rows; j ++ ) {\r\n\r\n				if ( j === 0 && i === cols ) {\r\n\r\n					v[ i ][ j ] = aj;\r\n\r\n				} else {\r\n\r\n					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Construct all of the faces.\r\n\r\n		for ( var i = 0; i < cols ; i ++ ) {\r\n\r\n			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n				var k = Math.floor( j / 2 );\r\n\r\n				if ( j % 2 === 0 ) {\r\n\r\n					make(\r\n						v[ i ][ k + 1 ],\r\n						v[ i + 1 ][ k ],\r\n						v[ i ][ k ],\r\n						materialIndex\r\n					);\r\n\r\n				} else {\r\n\r\n					make(\r\n						v[ i ][ k + 1 ],\r\n						v[ i + 1 ][ k + 1 ],\r\n						v[ i + 1 ][ k ],\r\n						materialIndex\r\n					);\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n	function azimuth( vector ) {\r\n\r\n		return Math.atan2( vector.z, - vector.x );\r\n\r\n	}\r\n\r\n\r\n	// Angle above the XZ plane.\r\n\r\n	function inclination( vector ) {\r\n\r\n		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n	}\r\n\r\n\r\n	// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n	function correctUV( uv, vector, azimuth ) {\r\n\r\n		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n		return uv.clone();\r\n\r\n	}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\nTHREE.PolyhedronGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.PolyhedronGeometry(\r\n		this.parameters.vertices,\r\n		this.parameters.indices,\r\n		this.parameters.radius,\r\n		this.parameters.detail\r\n	);\r\n\r\n	return geometry.copy( this );\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype.copy = function ( source ) {\r\n\r\n	THREE.Geometry.prototype.copy.call( this, source );\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n	var t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n	var r = 1 / t;\r\n\r\n	var vertices = [\r\n\r\n		// (±1, ±1, ±1)\r\n		- 1, - 1, - 1,    - 1, - 1,  1,\r\n		- 1,  1, - 1,    - 1,  1,  1,\r\n		 1, - 1, - 1,     1, - 1,  1,\r\n		 1,  1, - 1,     1,  1,  1,\r\n\r\n		// (0, ±1/φ, ±φ)\r\n		 0, - r, - t,     0, - r,  t,\r\n		 0,  r, - t,     0,  r,  t,\r\n\r\n		// (±1/φ, ±φ, 0)\r\n		- r, - t,  0,    - r,  t,  0,\r\n		 r, - t,  0,     r,  t,  0,\r\n\r\n		// (±φ, 0, ±1/φ)\r\n		- t,  0, - r,     t,  0, - r,\r\n		- t,  0,  r,     t,  0,  r\r\n	];\r\n\r\n	var indices = [\r\n		 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n		 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n		17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n		 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n		 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n		 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n		 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n		18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n		 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n		11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n		19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n		 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'DodecahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\nTHREE.DodecahedronGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.DodecahedronGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.detail\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n	var t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n	var vertices = [\r\n		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n	];\r\n\r\n	var indices = [\r\n		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'IcosahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\nTHREE.IcosahedronGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.IcosahedronGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.detail\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n	var vertices = [\r\n		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n	];\r\n\r\n	var indices = [\r\n		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'OctahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\nTHREE.OctahedronGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.OctahedronGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.detail\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n	var vertices = [\r\n		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n	];\r\n\r\n	var indices = [\r\n		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'TetrahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\nTHREE.TetrahedronGeometry.prototype.clone = function () {\r\n\r\n	var geometry = new THREE.TetrahedronGeometry(\r\n		this.parameters.radius,\r\n		this.parameters.detail\r\n	);\r\n\r\n	geometry.copy( this );\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ParametricGeometry';\r\n\r\n	this.parameters = {\r\n		func: func,\r\n		slices: slices,\r\n		stacks: stacks\r\n	};\r\n\r\n	var verts = this.vertices;\r\n	var faces = this.faces;\r\n	var uvs = this.faceVertexUvs[ 0 ];\r\n\r\n	var i, j, p;\r\n	var u, v;\r\n\r\n	var sliceCount = slices + 1;\r\n\r\n	for ( i = 0; i <= stacks; i ++ ) {\r\n\r\n		v = i / stacks;\r\n\r\n		for ( j = 0; j <= slices; j ++ ) {\r\n\r\n			u = j / slices;\r\n\r\n			p = func( u, v );\r\n			verts.push( p );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var a, b, c, d;\r\n	var uva, uvb, uvc, uvd;\r\n\r\n	for ( i = 0; i < stacks; i ++ ) {\r\n\r\n		for ( j = 0; j < slices; j ++ ) {\r\n\r\n			a = i * sliceCount + j;\r\n			b = i * sliceCount + j + 1;\r\n			c = ( i + 1 ) * sliceCount + j + 1;\r\n			d = ( i + 1 ) * sliceCount + j;\r\n\r\n			uva = new THREE.Vector2( j / slices, i / stacks );\r\n			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n			faces.push( new THREE.Face3( a, b, d ) );\r\n			uvs.push( [ uva, uvb, uvd ] );\r\n\r\n			faces.push( new THREE.Face3( b, c, d ) );\r\n			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// console.log(this);\r\n\r\n	// magic bullet\r\n	// var diff = this.mergeVertices();\r\n	// console.log('removed ', diff, ' vertices by merging');\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/geometries/WireframeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeGeometry = function ( geometry ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	var edge = [ 0, 0 ], hash = {};\r\n	var sortFunction = function ( a, b ) {\r\n\r\n		return a - b;\r\n\r\n	};\r\n\r\n	var keys = [ 'a', 'b', 'c' ];\r\n\r\n	if ( geometry instanceof THREE.Geometry ) {\r\n\r\n		var vertices = geometry.vertices;\r\n		var faces = geometry.faces;\r\n		var numEdges = 0;\r\n\r\n		// allocate maximal size\r\n		var edges = new Uint32Array( 6 * faces.length );\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			for ( var j = 0; j < 3; j ++ ) {\r\n\r\n				edge[ 0 ] = face[ keys[ j ] ];\r\n				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n				edge.sort( sortFunction );\r\n\r\n				var key = edge.toString();\r\n\r\n				if ( hash[ key ] === undefined ) {\r\n\r\n					edges[ 2 * numEdges ] = edge[ 0 ];\r\n					edges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n					hash[ key ] = true;\r\n					numEdges ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n		for ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n			for ( var j = 0; j < 2; j ++ ) {\r\n\r\n				var vertex = vertices[ edges [ 2 * i + j ] ];\r\n\r\n				var index = 6 * i + 3 * j;\r\n				coords[ index + 0 ] = vertex.x;\r\n				coords[ index + 1 ] = vertex.y;\r\n				coords[ index + 2 ] = vertex.z;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n	} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n		if ( geometry.index !== null ) {\r\n\r\n			// Indexed BufferGeometry\r\n\r\n			var indices = geometry.index.array;\r\n			var vertices = geometry.attributes.position;\r\n			var drawcalls = geometry.drawcalls;\r\n			var numEdges = 0;\r\n\r\n			if ( drawcalls.length === 0 ) {\r\n\r\n				geometry.addDrawCall( 0, indices.length );\r\n\r\n			}\r\n\r\n			// allocate maximal size\r\n			var edges = new Uint32Array( 2 * indices.length );\r\n\r\n			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {\r\n\r\n				var drawcall = drawcalls[ o ];\r\n\r\n				var start = drawcall.start;\r\n				var count = drawcall.count;\r\n\r\n				for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n					for ( var j = 0; j < 3; j ++ ) {\r\n\r\n						edge[ 0 ] = indices[ i + j ];\r\n						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n						edge.sort( sortFunction );\r\n\r\n						var key = edge.toString();\r\n\r\n						if ( hash[ key ] === undefined ) {\r\n\r\n							edges[ 2 * numEdges ] = edge[ 0 ];\r\n							edges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n							hash[ key ] = true;\r\n							numEdges ++;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n			for ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n				for ( var j = 0; j < 2; j ++ ) {\r\n\r\n					var index = 6 * i + 3 * j;\r\n					var index2 = edges[ 2 * i + j ];\r\n\r\n					coords[ index + 0 ] = vertices.getX( index2 );\r\n					coords[ index + 1 ] = vertices.getY( index2 );\r\n					coords[ index + 2 ] = vertices.getZ( index2 );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n		} else {\r\n\r\n			// non-indexed BufferGeometry\r\n\r\n			var vertices = geometry.attributes.position.array;\r\n			var numEdges = vertices.length / 3;\r\n			var numTris = numEdges / 3;\r\n\r\n			var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n			for ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n				for ( var j = 0; j < 3; j ++ ) {\r\n\r\n					var index = 18 * i + 6 * j;\r\n\r\n					var index1 = 9 * i + 3 * j;\r\n					coords[ index + 0 ] = vertices[ index1 ];\r\n					coords[ index + 1 ] = vertices[ index1 + 1 ];\r\n					coords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n					coords[ index + 3 ] = vertices[ index2 ];\r\n					coords[ index + 4 ] = vertices[ index2 + 1 ];\r\n					coords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n	size = size || 1;\r\n\r\n	var vertices = new Float32Array( [\r\n		0, 0, 0,  size, 0, 0,\r\n		0, 0, 0,  0, size, 0,\r\n		0, 0, 0,  0, 0, size\r\n	] );\r\n\r\n	var colors = new Float32Array( [\r\n		1, 0, 0,  1, 0.6, 0,\r\n		0, 1, 0,  0.6, 1, 0,\r\n		0, 0, 1,  0, 0.6, 1\r\n	] );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n	var lineGeometry = new THREE.Geometry();\r\n	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n	coneGeometry.translate( 0, - 0.5, 0 );\r\n\r\n	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n		// dir is assumed to be normalized\r\n\r\n		THREE.Object3D.call( this );\r\n\r\n		if ( color === undefined ) color = 0xffff00;\r\n		if ( length === undefined ) length = 1;\r\n		if ( headLength === undefined ) headLength = 0.2 * length;\r\n		if ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n		this.position.copy( origin );\r\n		\r\n		if ( headLength < length ) {\r\n			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n			this.line.matrixAutoUpdate = false;\r\n			this.add( this.line );\r\n		}\r\n\r\n		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n		this.cone.matrixAutoUpdate = false;\r\n		this.add( this.cone );\r\n\r\n		this.setDirection( dir );\r\n		this.setLength( length, headLength, headWidth );\r\n\r\n	}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n	var axis = new THREE.Vector3();\r\n	var radians;\r\n\r\n	return function setDirection( dir ) {\r\n\r\n		// dir is assumed to be normalized\r\n\r\n		if ( dir.y > 0.99999 ) {\r\n\r\n			this.quaternion.set( 0, 0, 0, 1 );\r\n\r\n		} else if ( dir.y < - 0.99999 ) {\r\n\r\n			this.quaternion.set( 1, 0, 0, 0 );\r\n\r\n		} else {\r\n\r\n			axis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n			radians = Math.acos( dir.y );\r\n\r\n			this.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n	if ( headLength === undefined ) headLength = 0.2 * length;\r\n	if ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n	if ( headLength < length ){\r\n		this.line.scale.set( 1, length - headLength, 1 );\r\n		this.line.updateMatrix();\r\n	}\r\n\r\n	this.cone.scale.set( headWidth, headLength, headWidth );\r\n	this.cone.position.y = length;\r\n	this.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n	if ( this.line !== undefined ) this.line.material.color.set( color );\r\n	this.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n	var positions = new Float32Array( 8 * 3 );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\r\n	if ( object !== undefined ) {\r\n\r\n		this.update( object );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = ( function () {\r\n\r\n	var box = new THREE.Box3();\r\n\r\n	return function ( object ) {\r\n\r\n		box.setFromObject( object );\r\n\r\n		if ( box.empty() ) return;\r\n\r\n		var min = box.min;\r\n		var max = box.max;\r\n\r\n		/*\r\n		  5____4\r\n		1/___0/|\r\n		| 6__|_7\r\n		2/___3/\r\n\r\n		0: max.x, max.y, max.z\r\n		1: min.x, max.y, max.z\r\n		2: min.x, min.y, max.z\r\n		3: max.x, min.y, max.z\r\n		4: max.x, max.y, min.z\r\n		5: min.x, max.y, min.z\r\n		6: min.x, min.y, min.z\r\n		7: max.x, min.y, min.z\r\n		*/\r\n\r\n		var position = this.geometry.attributes.position;\r\n		var array = position.array;\r\n\r\n		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\r\n		position.needsUpdate = true;\r\n\r\n		this.geometry.computeBoundingSphere();\r\n\r\n	}\r\n\r\n} )();\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n	this.object = object;\r\n\r\n	this.box = new THREE.Box3();\r\n\r\n	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n	this.box.setFromObject( this.object );\r\n\r\n	this.box.size( this.scale );\r\n\r\n	this.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *	- shows frustum, line of sight and up of the camera\r\n *	- suitable for fast updates\r\n * 	- based on frustum visualization in lightgl.js shadowmap example\r\n *		http://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n	var pointMap = {};\r\n\r\n	// colors\r\n\r\n	var hexFrustum = 0xffaa00;\r\n	var hexCone = 0xff0000;\r\n	var hexUp = 0x00aaff;\r\n	var hexTarget = 0xffffff;\r\n	var hexCross = 0x333333;\r\n\r\n	// near\r\n\r\n	addLine( \"n1\", \"n2\", hexFrustum );\r\n	addLine( \"n2\", \"n4\", hexFrustum );\r\n	addLine( \"n4\", \"n3\", hexFrustum );\r\n	addLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n	// far\r\n\r\n	addLine( \"f1\", \"f2\", hexFrustum );\r\n	addLine( \"f2\", \"f4\", hexFrustum );\r\n	addLine( \"f4\", \"f3\", hexFrustum );\r\n	addLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n	// sides\r\n\r\n	addLine( \"n1\", \"f1\", hexFrustum );\r\n	addLine( \"n2\", \"f2\", hexFrustum );\r\n	addLine( \"n3\", \"f3\", hexFrustum );\r\n	addLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n	// cone\r\n\r\n	addLine( \"p\", \"n1\", hexCone );\r\n	addLine( \"p\", \"n2\", hexCone );\r\n	addLine( \"p\", \"n3\", hexCone );\r\n	addLine( \"p\", \"n4\", hexCone );\r\n\r\n	// up\r\n\r\n	addLine( \"u1\", \"u2\", hexUp );\r\n	addLine( \"u2\", \"u3\", hexUp );\r\n	addLine( \"u3\", \"u1\", hexUp );\r\n\r\n	// target\r\n\r\n	addLine( \"c\", \"t\", hexTarget );\r\n	addLine( \"p\", \"c\", hexCross );\r\n\r\n	// cross\r\n\r\n	addLine( \"cn1\", \"cn2\", hexCross );\r\n	addLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n	addLine( \"cf1\", \"cf2\", hexCross );\r\n	addLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n	function addLine( a, b, hex ) {\r\n\r\n		addPoint( a, hex );\r\n		addPoint( b, hex );\r\n\r\n	}\r\n\r\n	function addPoint( id, hex ) {\r\n\r\n		geometry.vertices.push( new THREE.Vector3() );\r\n		geometry.colors.push( new THREE.Color( hex ) );\r\n\r\n		if ( pointMap[ id ] === undefined ) {\r\n\r\n			pointMap[ id ] = [];\r\n\r\n		}\r\n\r\n		pointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n	}\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n	this.camera = camera;\r\n	this.matrix = camera.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.pointMap = pointMap;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n	var geometry, pointMap;\r\n\r\n	var vector = new THREE.Vector3();\r\n	var camera = new THREE.Camera();\r\n\r\n	var setPoint = function ( point, x, y, z ) {\r\n\r\n		vector.set( x, y, z ).unproject( camera );\r\n\r\n		var points = pointMap[ point ];\r\n\r\n		if ( points !== undefined ) {\r\n\r\n			for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n				geometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	return function () {\r\n\r\n		geometry = this.geometry;\r\n		pointMap = this.pointMap;\r\n\r\n		var w = 1, h = 1;\r\n\r\n		// we need just camera projection matrix\r\n		// world matrix must be identity\r\n\r\n		camera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n		// center / target\r\n\r\n		setPoint( \"c\", 0, 0, - 1 );\r\n		setPoint( \"t\", 0, 0,  1 );\r\n\r\n		// near\r\n\r\n		setPoint( \"n1\", - w, - h, - 1 );\r\n		setPoint( \"n2\",   w, - h, - 1 );\r\n		setPoint( \"n3\", - w,   h, - 1 );\r\n		setPoint( \"n4\",   w,   h, - 1 );\r\n\r\n		// far\r\n\r\n		setPoint( \"f1\", - w, - h, 1 );\r\n		setPoint( \"f2\",   w, - h, 1 );\r\n		setPoint( \"f3\", - w,   h, 1 );\r\n		setPoint( \"f4\",   w,   h, 1 );\r\n\r\n		// up\r\n\r\n		setPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n		setPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n		setPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n		// cross\r\n\r\n		setPoint( \"cf1\", - w,   0, 1 );\r\n		setPoint( \"cf2\",   w,   0, 1 );\r\n		setPoint( \"cf3\",   0, - h, 1 );\r\n		setPoint( \"cf4\",   0,   h, 1 );\r\n\r\n		setPoint( \"cn1\", - w,   0, - 1 );\r\n		setPoint( \"cn2\",   w,   0, - 1 );\r\n		setPoint( \"cn3\",   0, - h, - 1 );\r\n		setPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n		geometry.verticesNeedUpdate = true;\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	size = size || 1;\r\n\r\n	var geometry = new THREE.Geometry();\r\n	geometry.vertices.push(\r\n		new THREE.Vector3( - size,   size, 0 ),\r\n		new THREE.Vector3(   size,   size, 0 ),\r\n		new THREE.Vector3(   size, - size, 0 ),\r\n		new THREE.Vector3( - size, - size, 0 ),\r\n		new THREE.Vector3( - size,   size, 0 )\r\n	);\r\n\r\n	var material = new THREE.LineBasicMaterial( { fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	this.lightPlane = new THREE.Line( geometry, material );\r\n	this.add( this.lightPlane );\r\n\r\n	geometry = new THREE.Geometry();\r\n	geometry.vertices.push(\r\n		new THREE.Vector3(),\r\n		new THREE.Vector3()\r\n	);\r\n\r\n	material = new THREE.LineBasicMaterial( { fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	this.targetLine = new THREE.Line( geometry, material );\r\n	this.add( this.targetLine );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n	this.lightPlane.geometry.dispose();\r\n	this.lightPlane.material.dispose();\r\n	this.targetLine.geometry.dispose();\r\n	this.targetLine.material.dispose();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var v3 = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		v1.setFromMatrixPosition( this.light.matrixWorld );\r\n		v2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n		v3.subVectors( v2, v1 );\r\n\r\n		this.lightPlane.lookAt( v3 );\r\n		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n		this.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n		this.targetLine.geometry.verticesNeedUpdate = true;\r\n		this.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimum angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n	THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	// FaceNormalsHelper only supports THREE.Geometry\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	//\r\n\r\n	var nNormals = 0;\r\n\r\n	var objGeometry = this.object.geometry;\r\n\r\n	if ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n		nNormals = objGeometry.faces.length;\r\n\r\n	} else {\r\n\r\n		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n\r\n	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n	geometry.addAttribute( 'position', positions );\r\n\r\n	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n	//\r\n\r\n	this.matrixAutoUpdate = false;\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var normalMatrix = new THREE.Matrix3();\r\n\r\n	return function update() {\r\n\r\n		this.object.updateMatrixWorld( true );\r\n\r\n		normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n		var matrixWorld = this.object.matrixWorld;\r\n\r\n		var position = this.geometry.attributes.position;\r\n\r\n		//\r\n\r\n		var objGeometry = this.object.geometry;\r\n\r\n		var vertices = objGeometry.vertices;\r\n\r\n		var faces = objGeometry.faces;\r\n\r\n		var idx = 0;\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			var normal = face.normal;\r\n\r\n			v1.copy( vertices[ face.a ] )\r\n				.add( vertices[ face.b ] )\r\n				.add( vertices[ face.c ] )\r\n				.divideScalar( 3 )\r\n				.applyMatrix4( matrixWorld );\r\n\r\n			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n			position.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n			idx = idx + 1;\r\n\r\n			position.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n			idx = idx + 1;\r\n\r\n		}\r\n\r\n		position.needsUpdate = true;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n	this.color1 = new THREE.Color( 0x444444 );\r\n	this.color2 = new THREE.Color( 0x888888 );\r\n\r\n	for ( var i = - size; i <= size; i += step ) {\r\n\r\n		geometry.vertices.push(\r\n			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n		);\r\n\r\n		var color = i === 0 ? this.color1 : this.color2;\r\n\r\n		geometry.colors.push( color, color, color, color );\r\n\r\n	}\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n	this.color1.set( colorCenterLine );\r\n	this.color2.set( colorGrid );\r\n\r\n	this.geometry.colorsNeedUpdate = true;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n	geometry.rotateX( - Math.PI / 2 );\r\n\r\n	for ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n	}\r\n\r\n	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n	this.lightSphere = new THREE.Mesh( geometry, material );\r\n	this.add( this.lightSphere );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\r\n	this.lightSphere.geometry.dispose();\r\n	this.lightSphere.material.dispose();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n	var vector = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n		this.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n	}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.matrix = this.light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	/*\r\n	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n	var d = light.distance;\r\n\r\n	if ( d === 0.0 ) {\r\n\r\n		this.lightDistance.visible = false;\r\n\r\n	} else {\r\n\r\n		this.lightDistance.scale.set( d, d, d );\r\n\r\n	}\r\n\r\n	this.add( this.lightDistance );\r\n	*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n	this.geometry.dispose();\r\n	this.material.dispose();\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	/*\r\n	var d = this.light.distance;\r\n\r\n	if ( d === 0.0 ) {\r\n\r\n		this.lightDistance.visible = false;\r\n\r\n	} else {\r\n\r\n		this.lightDistance.visible = true;\r\n		this.lightDistance.scale.set( d, d, d );\r\n\r\n	}\r\n	*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n	this.bones = this.getBoneList( object );\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	for ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n		var bone = this.bones[ i ];\r\n\r\n		if ( bone.parent instanceof THREE.Bone ) {\r\n\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.dynamic = true;\r\n\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n	this.root = object;\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n	var boneList = [];\r\n\r\n	if ( object instanceof THREE.Bone ) {\r\n\r\n		boneList.push( object );\r\n\r\n	}\r\n\r\n	for ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n	}\r\n\r\n	return boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n	var geometry = this.geometry;\r\n\r\n	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n	var boneMatrix = new THREE.Matrix4();\r\n\r\n	var j = 0;\r\n\r\n	for ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n		var bone = this.bones[ i ];\r\n\r\n		if ( bone.parent instanceof THREE.Bone ) {\r\n\r\n			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n			j += 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.verticesNeedUpdate = true;\r\n\r\n	geometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n	geometry.translate( 0, - 0.5, 0 );\r\n	geometry.rotateX( - Math.PI / 2 );\r\n\r\n	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n	this.cone = new THREE.Mesh( geometry, material );\r\n	this.add( this.cone );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\r\n	this.cone.geometry.dispose();\r\n	this.cone.material.dispose();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n	var vector = new THREE.Vector3();\r\n	var vector2 = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		var coneLength = this.light.distance ? this.light.distance : 10000;\r\n		var coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n		this.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n		vector.setFromMatrixPosition( this.light.matrixWorld );\r\n		vector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n		this.cone.lookAt( vector2.sub( vector ) );\r\n\r\n		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	//\r\n\r\n	var nNormals = 0;\r\n\r\n	var objGeometry = this.object.geometry;\r\n\r\n	if ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n		nNormals = objGeometry.faces.length * 3;\r\n\r\n	} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n		nNormals = objGeometry.attributes.normal.count\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n\r\n	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n	geometry.addAttribute( 'position', positions );\r\n\r\n	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n	//\r\n\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var normalMatrix = new THREE.Matrix3();\r\n\r\n	return function update() {\r\n\r\n		var keys = [ 'a', 'b', 'c' ];\r\n\r\n		this.object.updateMatrixWorld( true );\r\n\r\n		normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n		var matrixWorld = this.object.matrixWorld;\r\n\r\n		var position = this.geometry.attributes.position;\r\n\r\n		//\r\n\r\n		var objGeometry = this.object.geometry;\r\n\r\n		if ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n			var vertices = objGeometry.vertices;\r\n\r\n			var faces = objGeometry.faces;\r\n\r\n			var idx = 0;\r\n\r\n			for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n				var face = faces[ i ];\r\n\r\n				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n					var vertex = vertices[ face[ keys[ j ] ] ];\r\n\r\n					var normal = face.vertexNormals[ j ];\r\n\r\n					v1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\r\n					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n					position.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n					idx = idx + 1;\r\n\r\n					position.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n					idx = idx + 1;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var objPos = objGeometry.attributes.position;\r\n\r\n			var objNorm = objGeometry.attributes.normal;\r\n\r\n			var idx = 0;\r\n\r\n			// for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\r\n				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\r\n				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\r\n				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n				position.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n				idx = idx + 1;\r\n\r\n				position.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n				idx = idx + 1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		position.needsUpdate = true;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n	THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.animationsMap = {};\r\n	this.animationsList = [];\r\n\r\n	// prepare default animation\r\n	// (all frames played together in 1 second)\r\n\r\n	var numFrames = this.geometry.morphTargets.length;\r\n\r\n	var name = \"__default\";\r\n\r\n	var startFrame = 0;\r\n	var endFrame = numFrames - 1;\r\n\r\n	var fps = numFrames / 1;\r\n\r\n	this.createAnimation( name, startFrame, endFrame, fps );\r\n	this.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n	var animation = {\r\n\r\n		start: start,\r\n		end: end,\r\n\r\n		length: end - start + 1,\r\n\r\n		fps: fps,\r\n		duration: ( end - start ) / fps,\r\n\r\n		lastFrame: 0,\r\n		currentFrame: 0,\r\n\r\n		active: false,\r\n\r\n		time: 0,\r\n		direction: 1,\r\n		weight: 1,\r\n\r\n		directionBackwards: false,\r\n		mirroredLoop: false\r\n\r\n	};\r\n\r\n	this.animationsMap[ name ] = animation;\r\n	this.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n	var pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n	var firstAnimation, frameRanges = {};\r\n\r\n	var geometry = this.geometry;\r\n\r\n	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n		var morph = geometry.morphTargets[ i ];\r\n		var chunks = morph.name.match( pattern );\r\n\r\n		if ( chunks && chunks.length > 1 ) {\r\n\r\n			var name = chunks[ 1 ];\r\n\r\n			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n			var range = frameRanges[ name ];\r\n\r\n			if ( i < range.start ) range.start = i;\r\n			if ( i > range.end ) range.end = i;\r\n\r\n			if ( ! firstAnimation ) firstAnimation = name;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var name in frameRanges ) {\r\n\r\n		var range = frameRanges[ name ];\r\n		this.createAnimation( name, range.start, range.end, fps );\r\n\r\n	}\r\n\r\n	this.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.direction = 1;\r\n		animation.directionBackwards = false;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.direction = - 1;\r\n		animation.directionBackwards = true;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.fps = fps;\r\n		animation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.duration = duration;\r\n		animation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.weight = weight;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.time = time;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n	var time = 0;\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		time = animation.time;\r\n\r\n	}\r\n\r\n	return time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n	var duration = - 1;\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		duration = animation.duration;\r\n\r\n	}\r\n\r\n	return duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.time = 0;\r\n		animation.active = true;\r\n\r\n	} else {\r\n\r\n		console.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.active = false;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n		var animation = this.animationsList[ i ];\r\n\r\n		if ( ! animation.active ) continue;\r\n\r\n		var frameTime = animation.duration / animation.length;\r\n\r\n		animation.time += animation.direction * delta;\r\n\r\n		if ( animation.mirroredLoop ) {\r\n\r\n			if ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n				animation.direction *= - 1;\r\n\r\n				if ( animation.time > animation.duration ) {\r\n\r\n					animation.time = animation.duration;\r\n					animation.directionBackwards = true;\r\n\r\n				}\r\n\r\n				if ( animation.time < 0 ) {\r\n\r\n					animation.time = 0;\r\n					animation.directionBackwards = false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			animation.time = animation.time % animation.duration;\r\n\r\n			if ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n		}\r\n\r\n		var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n		var weight = animation.weight;\r\n\r\n		if ( keyframe !== animation.currentFrame ) {\r\n\r\n			this.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n			this.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n			animation.lastFrame = animation.currentFrame;\r\n			animation.currentFrame = keyframe;\r\n\r\n		}\r\n\r\n		var mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n		if ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n		if ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n		} else {\r\n\r\n			this.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (true) {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/three.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/three/three.js?");
},function(module,exports,__webpack_require__){eval("/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar arrayEach = __webpack_require__(11),\n    baseEach = __webpack_require__(12),\n    bindCallback = __webpack_require__(17),\n    isArray = __webpack_require__(16);\n\n/**\n * Creates a function for `_.forEach` or `_.forEachRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createForEach(arrayFunc, eachFunc) {\n  return function(collection, iteratee, thisArg) {\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee)\n      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n  };\n}\n\n/**\n * Iterates over elements of `collection` invoking `iteratee` for each element.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection). Iteratee functions may exit iteration early\n * by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n * may be used for object iteration.\n *\n * @static\n * @memberOf _\n * @alias each\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array|Object|string} Returns `collection`.\n * @example\n *\n * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n * // => logs each value from left to right and returns the array\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n */\nvar forEach = createForEach(arrayEach, baseEach);\n\nmodule.exports = forEach;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/index.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/index.js?")},function(module,exports){eval('/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports="npm" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands or `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._arrayeach/index.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash._arrayeach/index.js?')},function(module,exports,__webpack_require__){eval("/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar keys = __webpack_require__(13);\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = baseEach;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._baseeach/index.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash._baseeach/index.js?")},function(module,exports,__webpack_require__){eval("/**\n * lodash 3.1.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar getNative = __webpack_require__(14),\n    isArguments = __webpack_require__(15),\n    isArray = __webpack_require__(16);\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keys;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/index.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/index.js?")},function(module,exports){eval("/**\n * lodash 3.9.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = getNative;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/~/lodash._getnative/index.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/~/lodash._getnative/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/~/lodash.isarguments/index.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/~/lodash.isarguments/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]',\n    funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash.isarray/index.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash.isarray/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = bindCallback;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._bindcallback/index.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.foreach/~/lodash._bindcallback/index.js?");
},function(module,exports,__webpack_require__){eval("/**\n * lodash 3.2.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseAssign = __webpack_require__(19),\n    createAssigner = __webpack_require__(25),\n    keys = __webpack_require__(21);\n\n/**\n * A specialized version of `_.assign` for customizing assigned values without\n * support for argument juggling, multiple sources, and `this` binding `customizer`\n * functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n */\nfunction assignWith(object, source, customizer) {\n  var index = -1,\n      props = keys(source),\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? (result !== value) : (value === value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\n/**\n * Assigns own enumerable properties of source object(s) to the destination\n * object. Subsequent sources overwrite property assignments of previous sources.\n * If `customizer` is provided it is invoked to produce the assigned values.\n * The `customizer` is bound to `thisArg` and invoked with five arguments:\n * (objectValue, sourceValue, key, object, source).\n *\n * **Note:** This method mutates `object` and is based on\n * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).\n *\n * @static\n * @memberOf _\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n * // => { 'user': 'fred', 'age': 40 }\n *\n * // using a customizer callback\n * var defaults = _.partialRight(_.assign, function(value, other) {\n *   return _.isUndefined(value) ? other : value;\n * });\n *\n * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n * // => { 'user': 'barney', 'age': 36 }\n */\nvar assign = createAssigner(function(object, source, customizer) {\n  return customizer\n    ? assignWith(object, source, customizer)\n    : baseAssign(object, source);\n});\n\nmodule.exports = assign;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/index.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/index.js?")},function(module,exports,__webpack_require__){eval('/**\n * lodash 3.2.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports="npm" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseCopy = __webpack_require__(20),\n    keys = __webpack_require__(21);\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._baseassign/index.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash._baseassign/index.js?')},function(module,exports){eval('/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports="npm" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash._basecopy/index.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash._basecopy/index.js?')},function(module,exports,__webpack_require__){eval("/**\n * lodash 3.1.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar getNative = __webpack_require__(22),\n    isArguments = __webpack_require__(23),\n    isArray = __webpack_require__(24);\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keys;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash.keys/index.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash.keys/index.js?")},function(module,exports){eval("/**\n * lodash 3.9.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = getNative;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash.keys/~/lodash._getnative/index.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash.keys/~/lodash._getnative/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash.keys/~/lodash.isarguments/index.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash.keys/~/lodash.isarguments/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]',\n    funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash.keys/~/lodash.isarray/index.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash.keys/~/lodash.isarray/index.js?")},function(module,exports,__webpack_require__){eval("/**\n * lodash 3.1.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar bindCallback = __webpack_require__(26),\n    isIterateeCall = __webpack_require__(27),\n    restParam = __webpack_require__(28);\n\n/**\n * Creates a function that assigns properties of source object(s) to a given\n * destination object.\n *\n * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return restParam(function(object, sources) {\n    var index = -1,\n        length = object == null ? 0 : sources.length,\n        customizer = length > 2 ? sources[length - 2] : undefined,\n        guard = length > 2 ? sources[2] : undefined,\n        thisArg = length > 1 ? sources[length - 1] : undefined;\n\n    if (typeof customizer == 'function') {\n      customizer = bindCallback(customizer, thisArg, 5);\n      length -= 2;\n    } else {\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\n      length -= (customizer ? 1 : 0);\n    }\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/index.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash._createassigner/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = bindCallback;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash._bindcallback/index.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash._bindcallback/index.js?")},function(module,exports){eval("/**\n * lodash 3.0.9 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isIterateeCall;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash._isiterateecall/index.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash._isiterateecall/index.js?");
},function(module,exports){eval("/**\n * lodash 3.6.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of the\n * created function and arguments from `start` and beyond provided as an array.\n *\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var say = _.restParam(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n *\n * say('hello', 'fred', 'barney', 'pebbles');\n * // => 'hello fred, barney, & pebbles'\n */\nfunction restParam(func, start) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        rest = Array(length);\n\n    while (++index < length) {\n      rest[index] = args[start + index];\n    }\n    switch (start) {\n      case 0: return func.call(this, rest);\n      case 1: return func.call(this, args[0], rest);\n      case 2: return func.call(this, args[0], args[1], rest);\n    }\n    var otherArgs = Array(start + 1);\n    index = -1;\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = rest;\n    return func.apply(this, otherArgs);\n  };\n}\n\nmodule.exports = restParam;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash.restparam/index.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash.restparam/index.js?")},function(module,exports){eval("module.exports = new RegExp(\n	'^' +\n\n	// protocol identifier\n	'(?:(?:(?:https?):)?//)' +\n\n	// user:pass authentication\n	'(?:\\\\S+(?::\\\\S*)?@)?' +\n	'(?:' +\n\n	// IP address exclusion\n	// private & local networks\n	'(' +\n	'(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})' +\n	'(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})' +\n	'(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})' +\n\n	// IP address dotted notation octets\n	// excludes loopback network 0.0.0.0\n	// excludes reserved space >= 224.0.0.0\n	// excludes network & broacast addresses\n	// (first & last IP address of each class)\n	'(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])' +\n	'(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}' +\n	'(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))' +\n	'|' +\n\n	// host name\n	'(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n\n	// domain name\n	'(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*' +\n\n	// TLD identifier\n	'(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))?' +\n	')' +\n\n	')' +\n\n	// port number\n	'(?::(\\\\d{2,5}))?' +\n\n	// resource path\n	'(?:/\\\\S*)?' +\n	'$', 'i'\n);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/urlregex.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/utils/urlregex.js?")},function(module,exports,__webpack_require__){eval('var map = {\n	"./asphalt.jpg": 31,\n	"./brick-tiles.jpg": 32,\n	"./bricks-normal.jpg": 33,\n	"./bricks-specular.jpg": 34,\n	"./bricks.jpg": 35,\n	"./checkerboard.png": 36,\n	"./grass.jpg": 37,\n	"./metal-floor.jpg": 38,\n	"./metal.jpg": 39,\n	"./stone.jpg": 40,\n	"./tiles.jpg": 41,\n	"./weathered-wood.jpg": 42,\n	"./wood.jpg": 43\n};\nfunction webpackContext(req) {\n	return __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n	return map[req] || (function() { throw new Error("Cannot find module \'" + req + "\'.") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n	return Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 30;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images ^\\.\\/.*$\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images_^\\.\\/.*$?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/asphalt.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/asphalt.jpg\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/asphalt.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/brick-tiles.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/brick-tiles.jpg\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/brick-tiles.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/bricks-normal.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/bricks-normal.jpg\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/bricks-normal.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/bricks-specular.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/bricks-specular.jpg\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/bricks-specular.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/bricks.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/bricks.jpg\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/bricks.jpg?')},function(module,exports){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAABlBMVEUsLCzp6enLhVdXAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB94KFBIOCP7R3TQAAAA4SURBVGje7dAhEgAACMOw/f/T4Gc5XKqjmlRTBQAAAAAAAAAAAAAA4AiMAQAAAAAAAAAAAADgGSyKafDiEFszywAAAABJRU5ErkJggg=="\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/checkerboard.png\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/checkerboard.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/grass.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/grass.jpg\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/grass.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/metal-floor.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/metal-floor.jpg\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/metal-floor.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/metal.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/metal.jpg\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/metal.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/stone.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/stone.jpg\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/stone.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/tiles.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/tiles.jpg\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/tiles.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/weathered-wood.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/weathered-wood.jpg\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/weathered-wood.jpg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "image/wood.jpg"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/wood.jpg\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/images/wood.jpg?')},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var	NEAR_DISTANCE = 3,\n		materials = __webpack_require__(8),\n		THREE = __webpack_require__(9),\n		eventEmitter = __webpack_require__(45),\n\n		xAxis = new THREE.Vector3(1, 0, 0),\n		yAxis = new THREE.Vector3(0, 1, 0),\n		zAxis = new THREE.Vector3(0, 0, 1),\n\n		scratchVector1 = new THREE.Vector3(),\n		scratchVector2 = new THREE.Vector3(),\n\n		allObjects = window.WeakMap ? new window.WeakMap() : {};\n\n	function distance(object, origin) {\n		var geometry;\n\n		geometry = object.geometry;\n\n		//assumes object world matrix has been updated\n		scratchVector1.setFromMatrixPosition(origin.matrixWorld);\n\n		if (!geometry) {\n			//first convert to world coordinate\n			scratchVector2.setFromMatrixPosition(object.matrixWorld);\n			return scratchVector2.distanceTo(scratchVector1);\n		}\n\n		object.worldToLocal(scratchVector1);\n		return object.geometry.boundingBox.distanceToPoint(scratchVector1);\n	}\n\n	function VRObject(parent, creator, camera, options) {\n		var material,\n			object,\n			self = this,\n\n			isNear = false,\n			isTarget = false,\n			raycaster;\n\n		options = options || {};\n\n		eventEmitter(this);\n\n		if (camera) {\n			// raycaster = new THREE.Raycaster();\n\n			this.update = function () {\n				var wasNear = isNear,\n					wasTarget = isTarget,\n\n					intersects, intersect, i;\n\n				isNear = self.distance < NEAR_DISTANCE;\n				if (isNear !== wasNear) {\n					if (isNear) {\n						self.emit('near', self);\n					} else {\n						self.emit('far', self);\n					}\n				}\n\n				/*\n				raycaster.ray.origin.copy(origin);\n				raycaster.ray.direction.set(0, 0, 0.5).unproject(camera).sub(origin).normalize();\n\n				//todo: consider whether this needs to be recursive. maybe a different event\n				intersects = raycaster.intersectObject(object);\n				if (intersects.length) {\n					isTarget = true;\n					if (!wasTarget) {\n						self.emit('target-on', intersects[0]);\n					}\n				} else if (wasTarget) {\n					self.emit('target-off');\n				}\n				*/\n			};\n		}\n\n		//todo: get material from options\n		this.object = object = creator.call(this, parent, options);\n		this.parent = this.object.parent || parent;\n\n		if (object instanceof THREE.Mesh) {\n			if (options.castShadow !== false) {\n				object.castShadow = true;\n			}\n			if (options.receiveShadow !== false) {\n				object.receiveShadow = true;\n			}\n\n			if (object.geometry) {\n				object.geometry.computeBoundingBox();\n			}\n		}\n\n		if (options.name !== undefined) {\n			object.name = options.name;\n		}\n		self.name = object.name;\n\n		if (allObjects.set) {\n			allObjects.set(object, this);\n		} else {\n			allObjects[object.id] = this;\n		}\n\n		object.position.set(\n			parseFloat(options.x) || 0,\n			parseFloat(options.y) || 0,\n			parseFloat(options.z) || 0\n		);\n\n		this.setMaterial(options.material);\n\n		if (options.color) {\n			material = object.material;\n			material.color = new THREE.Color(options.color);\n			material.ambient = material.color;\n		}\n\n		['position', 'scale', 'rotation', 'quaternion', 'material'].forEach(function (prop) {\n			if (prop in object && !self[prop]) {\n				self[prop] = object[prop];\n			}\n		});\n\n		Object.defineProperty(this, 'visible', {\n			set: function (val) {\n				self.object.visible = !!val;\n			},\n			get: function () {\n				return self.object.visible;\n			}\n		});\n\n		Object.defineProperty(this, 'distance', {\n			get: function () {\n				return distance(self.object, camera || parent);\n			}\n		});\n	}\n\n	VRObject.prototype.hide = function () {\n		this.object.visible = false;\n		return this;\n	};\n\n	VRObject.prototype.show = function () {\n		this.object.visible = true;\n		return this;\n	};\n\n	VRObject.prototype.moveTo = function (x, y, z) {\n		var position = this.object.position;\n\n		x = !isNaN(x) ? x : position.x;\n		y = !isNaN(y) ? y : position.y;\n		z = !isNaN(z) ? z : position.z;\n\n		position.set(x, y, z);\n\n		return this;\n	};\n\n	VRObject.prototype.moveX = function (distance) {\n		this.object.translateX(distance);\n		return this;\n	};\n\n	VRObject.prototype.moveY = function (distance) {\n		this.object.translateY(distance);\n		return this;\n	};\n	VRObject.prototype.moveUp = VRObject.prototype.moveY;\n	VRObject.prototype.moveDown = function (distance) {\n		this.moveY(-distance);\n		return this;\n	};\n\n	VRObject.prototype.moveZ = function (distance) {\n		this.object.translateZ(distance);\n		return this;\n	};\n\n	VRObject.prototype.rotateX = function (angle) {\n		this.object.rotateOnAxis(xAxis, angle);\n		return this;\n	};\n\n	VRObject.prototype.rotateY = function (angle) {\n		this.object.rotateOnAxis(yAxis, angle);\n		return this;\n	};\n\n	VRObject.prototype.rotateZ = function (angle) {\n		this.object.rotateOnAxis(zAxis, angle);\n		return this;\n	};\n\n	VRObject.prototype.setScale = function (x, y, z) {\n		var scale = this.object.scale;\n\n		if (x !== undefined && !isNaN(x)) {\n			if (y === undefined && z === undefined) {\n				y = z = x;\n			}\n		}\n\n		x = !isNaN(x) ? x : scale.x;\n		y = !isNaN(y) ? y : scale.y;\n		z = !isNaN(z) ? z : scale.z;\n\n		scale.set(x, y, z);\n\n		return this;\n	};\n\n	VRObject.prototype.setMaterial = function (material, options) {\n		if (material && this.object instanceof THREE.Mesh) {\n			if (typeof material === 'function') {\n				material = material();\n			} else if (typeof material === 'string' && materials[material]) {\n				material = materials[material](options);\n			} else if (material && !(material instanceof THREE.Material) && typeof material !== 'number') {\n				try {\n					material = materials.material(material);\n				} catch (e) {}\n			}\n\n			if (material instanceof THREE.Material) {\n				this.object.material = material;\n			}\n		}\n\n		return this;\n	};\n\n	VRObject.prototype.update = function () {};\n\n	VRObject.prototype.raycastable = true;\n\n	VRObject.repeat = function (count, options) {\n		var i,\n			change = false,\n			lastObject = this,\n			currentPosition = new THREE.Vector3(),\n			deltaPosition = new THREE.Vector3(),\n			currentQuaternion = new THREE.Quaternion(),\n			deltaQuaternion = new THREE.Quaternion();\n\n		if (!options) {\n			return;\n		}\n\n		if (options.offset) {}\n\n		for (i = 0; i < count; i++) {\n\n		}\n	};\n\n	VRObject.findObject = function (object) {\n		if (object instanceof VRObject) {\n			return object;\n		}\n\n		if (object && object instanceof THREE.Object3D) {\n			if (allObjects.get) {\n				return allObjects.get(object);\n			}\n\n			return allObjects[object.id];\n		}\n\n		// if (typeof object === 'number') {\n		// 	return allObjects[object];\n		// }\n	};\n\n	return VRObject;\n\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vr-object.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/vr-object.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar d        = __webpack_require__(46)\n  , callable = __webpack_require__(59)\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n	var data;\n\n	callable(listener);\n\n	if (!hasOwnProperty.call(this, '__ee__')) {\n		data = descriptor.value = create(null);\n		defineProperty(this, '__ee__', descriptor);\n		descriptor.value = null;\n	} else {\n		data = this.__ee__;\n	}\n	if (!data[type]) data[type] = listener;\n	else if (typeof data[type] === 'object') data[type].push(listener);\n	else data[type] = [data[type], listener];\n\n	return this;\n};\n\nonce = function (type, listener) {\n	var once, self;\n\n	callable(listener);\n	self = this;\n	on.call(this, type, once = function () {\n		off.call(self, type, once);\n		apply.call(listener, this, arguments);\n	});\n\n	once.__eeOnceListener__ = listener;\n	return this;\n};\n\noff = function (type, listener) {\n	var data, listeners, candidate, i;\n\n	callable(listener);\n\n	if (!hasOwnProperty.call(this, '__ee__')) return this;\n	data = this.__ee__;\n	if (!data[type]) return this;\n	listeners = data[type];\n\n	if (typeof listeners === 'object') {\n		for (i = 0; (candidate = listeners[i]); ++i) {\n			if ((candidate === listener) ||\n					(candidate.__eeOnceListener__ === listener)) {\n				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n				else listeners.splice(i, 1);\n			}\n		}\n	} else {\n		if ((listeners === listener) ||\n				(listeners.__eeOnceListener__ === listener)) {\n			delete data[type];\n		}\n	}\n\n	return this;\n};\n\nemit = function (type) {\n	var i, l, listener, listeners, args;\n\n	if (!hasOwnProperty.call(this, '__ee__')) return;\n	listeners = this.__ee__[type];\n	if (!listeners) return;\n\n	if (typeof listeners === 'object') {\n		l = arguments.length;\n		args = new Array(l - 1);\n		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n		listeners = listeners.slice();\n		for (i = 0; (listener = listeners[i]); ++i) {\n			apply.call(listener, this, args);\n		}\n	} else {\n		switch (arguments.length) {\n		case 1:\n			call.call(listeners, this);\n			break;\n		case 2:\n			call.call(listeners, this, arguments[1]);\n			break;\n		case 3:\n			call.call(listeners, this, arguments[1], arguments[2]);\n			break;\n		default:\n			l = arguments.length;\n			args = new Array(l - 1);\n			for (i = 1; i < l; ++i) {\n				args[i - 1] = arguments[i];\n			}\n			apply.call(listeners, this, args);\n		}\n	}\n};\n\nmethods = {\n	on: on,\n	once: once,\n	off: off,\n	emit: emit\n};\n\ndescriptors = {\n	on: d(on),\n	once: d(once),\n	off: d(off),\n	emit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/index.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar assign        = __webpack_require__(47)\n  , normalizeOpts = __webpack_require__(54)\n  , isCallable    = __webpack_require__(55)\n  , contains      = __webpack_require__(56)\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n	var c, e, w, options, desc;\n	if ((arguments.length < 2) || (typeof dscr !== 'string')) {\n		options = value;\n		value = dscr;\n		dscr = null;\n	} else {\n		options = arguments[2];\n	}\n	if (dscr == null) {\n		c = w = true;\n		e = false;\n	} else {\n		c = contains.call(dscr, 'c');\n		e = contains.call(dscr, 'e');\n		w = contains.call(dscr, 'w');\n	}\n\n	desc = { value: value, configurable: c, enumerable: e, writable: w };\n	return !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n	var c, e, options, desc;\n	if (typeof dscr !== 'string') {\n		options = set;\n		set = get;\n		get = dscr;\n		dscr = null;\n	} else {\n		options = arguments[3];\n	}\n	if (get == null) {\n		get = undefined;\n	} else if (!isCallable(get)) {\n		options = get;\n		get = set = undefined;\n	} else if (set == null) {\n		set = undefined;\n	} else if (!isCallable(set)) {\n		options = set;\n		set = undefined;\n	}\n	if (dscr == null) {\n		c = true;\n		e = false;\n	} else {\n		c = contains.call(dscr, 'c');\n		e = contains.call(dscr, 'e');\n	}\n\n	desc = { get: get, set: set, configurable: c, enumerable: e };\n	return !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/d/index.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/d/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(48)()\n	? Object.assign\n	: __webpack_require__(49);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/assign/index.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/assign/index.js?")},function(module,exports){eval("'use strict';\n\nmodule.exports = function () {\n	var assign = Object.assign, obj;\n	if (typeof assign !== 'function') return false;\n	obj = { foo: 'raz' };\n	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/assign/is-implemented.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/assign/is-implemented.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar keys  = __webpack_require__(50)\n  , value = __webpack_require__(53)\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, …srcn*/) {\n	var error, i, l = max(arguments.length, 2), assign;\n	dest = Object(value(dest));\n	assign = function (key) {\n		try { dest[key] = src[key]; } catch (e) {\n			if (!error) error = e;\n		}\n	};\n	for (i = 1; i < l; ++i) {\n		src = arguments[i];\n		keys(src).forEach(assign);\n	}\n	if (error !== undefined) throw error;\n	return dest;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/assign/shim.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/assign/shim.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(51)()\n	? Object.keys\n	: __webpack_require__(52);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/keys/index.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/keys/index.js?")},function(module,exports){eval("'use strict';\n\nmodule.exports = function () {\n	try {\n		Object.keys('primitive');\n		return true;\n	} catch (e) { return false; }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/keys/is-implemented.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/keys/is-implemented.js?")},function(module,exports){eval("'use strict';\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n	return keys(object == null ? object : Object(object));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/keys/shim.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/keys/shim.js?")},function(module,exports){eval("'use strict';\n\nmodule.exports = function (value) {\n	if (value == null) throw new TypeError(\"Cannot use null or undefined\");\n	return value;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/valid-value.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/valid-value.js?")},function(module,exports){eval("'use strict';\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n	var key;\n	for (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, …options*/) {\n	var result = create(null);\n	forEach.call(arguments, function (options) {\n		if (options == null) return;\n		process(Object(options), result);\n	});\n	return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/normalize-options.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/normalize-options.js?")},function(module,exports){eval("// Deprecated\n\n'use strict';\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/is-callable.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/is-callable.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(57)()\n	? String.prototype.contains\n	: __webpack_require__(58);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/string/#/contains/index.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/string/#/contains/index.js?")},function(module,exports){eval("'use strict';\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n	if (typeof str.contains !== 'function') return false;\n	return ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/string/#/contains/is-implemented.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/string/#/contains/is-implemented.js?")},function(module,exports){eval("'use strict';\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n	return indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/string/#/contains/shim.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/string/#/contains/shim.js?")},function(module,exports){eval("'use strict';\n\nmodule.exports = function (fn) {\n	if (typeof fn !== 'function') throw new TypeError(fn + \" is not a function\");\n	return fn;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/valid-callable.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/~/es5-ext/object/valid-callable.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	return function empty(parent, options) {\n		var obj = new THREE.Object3D();\n\n		obj.name = 'empty';\n\n		parent.add(obj);\n\n		return obj;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/empty.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/empty.js?")},function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\n/**\n * @author richt / http://richt.me\n * @author WestLangley / http://github.com/WestLangley\n *\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\n */\n\nTHREE.DeviceOrientationControls = function ( object ) {\n\n	var scope = this;\n\n	this.object = object;\n	this.object.rotation.reorder( \"YXZ\" );\n\n	this.enabled = true;\n\n	this.deviceOrientation = {};\n	this.screenOrientation = 0;\n\n	var onDeviceOrientationChangeEvent = function ( event ) {\n\n		scope.deviceOrientation = event;\n\n	};\n\n	var onScreenOrientationChangeEvent = function () {\n\n		scope.screenOrientation = window.orientation || 0;\n\n	};\n\n	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\n\n	var setObjectQuaternion = function () {\n\n		var zee = new THREE.Vector3( 0, 0, 1 );\n\n		var euler = new THREE.Euler();\n\n		var q0 = new THREE.Quaternion();\n\n		var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\n\n		return function ( quaternion, alpha, beta, gamma, orient ) {\n\n			euler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us\n\n			quaternion.setFromEuler( euler );                               // orient the device\n\n			quaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top\n\n			quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation\n\n		}\n\n	}();\n\n	this.connect = function() {\n\n		onScreenOrientationChangeEvent(); // run once on load\n\n		window.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n		window.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\n		scope.enabled = true;\n\n	};\n\n	this.disconnect = function() {\n\n		window.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n		window.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\n		scope.enabled = false;\n\n	};\n\n	this.update = function () {\n\n		if ( scope.enabled === false ) return;\n\n		var alpha  = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) : 0; // Z\n		var beta   = scope.deviceOrientation.beta  ? THREE.Math.degToRad( scope.deviceOrientation.beta  ) : 0; // X'\n		var gamma  = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''\n		var orient = scope.screenOrientation       ? THREE.Math.degToRad( scope.screenOrientation       ) : 0; // O\n\n		setObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\n\n	};\n\n	this.connect();\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/DeviceOrientationControls/index.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/DeviceOrientationControls/index.js?./~/imports-loader?THREE=three")},function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls = function ( object, domElement ) {\n\n	this.object = object;\n	this.domElement = ( domElement !== undefined ) ? domElement : document;\n\n	// API\n\n	// Set to false to disable this control\n	this.enabled = true;\n\n	// \"target\" sets the location of focus, where the control orbits around\n	// and where it pans with respect to.\n	this.target = new THREE.Vector3();\n\n	// center is old, deprecated; use \"target\" instead\n	this.center = this.target;\n\n	// This option actually enables dollying in and out; left as \"zoom\" for\n	// backwards compatibility\n	this.noZoom = false;\n	this.zoomSpeed = 1.0;\n\n	// Limits to how far you can dolly in and out ( PerspectiveCamera only )\n	this.minDistance = 0;\n	this.maxDistance = Infinity;\n\n	// Limits to how far you can zoom in and out ( OrthographicCamera only )\n	this.minZoom = 0;\n	this.maxZoom = Infinity;\n\n	// Set to true to disable this control\n	this.noRotate = false;\n	this.rotateSpeed = 1.0;\n\n	// Set to true to disable this control\n	this.noPan = false;\n	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push\n\n	// Set to true to automatically rotate around the target\n	this.autoRotate = false;\n	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n	// How far you can orbit vertically, upper and lower limits.\n	// Range is 0 to Math.PI radians.\n	this.minPolarAngle = 0; // radians\n	this.maxPolarAngle = Math.PI; // radians\n\n	// How far you can orbit horizontally, upper and lower limits.\n	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n	this.minAzimuthAngle = - Infinity; // radians\n	this.maxAzimuthAngle = Infinity; // radians\n\n	// Set to true to disable use of the keys\n	this.noKeys = false;\n\n	// The four arrow keys\n	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n	// Mouse buttons\n	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n	////////////\n	// internals\n\n	var scope = this;\n\n	var EPS = 0.000001;\n\n	var rotateStart = new THREE.Vector2();\n	var rotateEnd = new THREE.Vector2();\n	var rotateDelta = new THREE.Vector2();\n\n	var panStart = new THREE.Vector2();\n	var panEnd = new THREE.Vector2();\n	var panDelta = new THREE.Vector2();\n	var panOffset = new THREE.Vector3();\n\n	var offset = new THREE.Vector3();\n\n	var dollyStart = new THREE.Vector2();\n	var dollyEnd = new THREE.Vector2();\n	var dollyDelta = new THREE.Vector2();\n\n	var theta;\n	var phi;\n	var phiDelta = 0;\n	var thetaDelta = 0;\n	var scale = 1;\n	var pan = new THREE.Vector3();\n\n	var lastPosition = new THREE.Vector3();\n	var lastQuaternion = new THREE.Quaternion();\n\n	var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n	var state = STATE.NONE;\n\n	// for reset\n\n	this.target0 = this.target.clone();\n	this.position0 = this.object.position.clone();\n	this.zoom0 = this.object.zoom;\n\n	// so camera.up is the orbit axis\n\n	var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n	var quatInverse = quat.clone().inverse();\n\n	// events\n\n	var changeEvent = { type: 'change' };\n	var startEvent = { type: 'start' };\n	var endEvent = { type: 'end' };\n\n	this.rotateLeft = function ( angle ) {\n\n		if ( angle === undefined ) {\n\n			angle = getAutoRotationAngle();\n\n		}\n\n		thetaDelta -= angle;\n\n	};\n\n	this.rotateUp = function ( angle ) {\n\n		if ( angle === undefined ) {\n\n			angle = getAutoRotationAngle();\n\n		}\n\n		phiDelta -= angle;\n\n	};\n\n	// pass in distance in world space to move left\n	this.panLeft = function ( distance ) {\n\n		var te = this.object.matrix.elements;\n\n		// get X column of matrix\n		panOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n		panOffset.multiplyScalar( - distance );\n\n		pan.add( panOffset );\n\n	};\n\n	// pass in distance in world space to move up\n	this.panUp = function ( distance ) {\n\n		var te = this.object.matrix.elements;\n\n		// get Y column of matrix\n		panOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n		panOffset.multiplyScalar( distance );\n\n		pan.add( panOffset );\n\n	};\n\n	// pass in x,y of change desired in pixel space,\n	// right and down are positive\n	this.pan = function ( deltaX, deltaY ) {\n\n		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n		if ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n			// perspective\n			var position = scope.object.position;\n			var offset = position.clone().sub( scope.target );\n			var targetDistance = offset.length();\n\n			// half of the fov is center to top of screen\n			targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n			// we actually don't use screenWidth, since perspective camera is fixed to screen height\n			scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\n			scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\n\n		} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n			// orthographic\n			scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\n			scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\n		} else {\n\n			// camera neither orthographic or perspective\n			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n		}\n\n	};\n\n	this.dollyIn = function ( dollyScale ) {\n\n		if ( dollyScale === undefined ) {\n\n			dollyScale = getZoomScale();\n\n		}\n\n		if ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n			scale /= dollyScale;\n\n		} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n			scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );\n			scope.object.updateProjectionMatrix();\n			scope.dispatchEvent( changeEvent );\n\n		} else {\n\n			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n		}\n\n	};\n\n	this.dollyOut = function ( dollyScale ) {\n\n		if ( dollyScale === undefined ) {\n\n			dollyScale = getZoomScale();\n\n		}\n\n		if ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n			scale *= dollyScale;\n\n		} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n			scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );\n			scope.object.updateProjectionMatrix();\n			scope.dispatchEvent( changeEvent );\n\n		} else {\n\n			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n		}\n\n	};\n\n	this.update = function () {\n\n		var position = this.object.position;\n\n		offset.copy( position ).sub( this.target );\n\n		// rotate offset to \"y-axis-is-up\" space\n		offset.applyQuaternion( quat );\n\n		// angle from z-axis around y-axis\n\n		theta = Math.atan2( offset.x, offset.z );\n\n		// angle from y-axis\n\n		phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n		if ( this.autoRotate && state === STATE.NONE ) {\n\n			this.rotateLeft( getAutoRotationAngle() );\n\n		}\n\n		theta += thetaDelta;\n		phi += phiDelta;\n\n		// restrict theta to be between desired limits\n		theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\n		// restrict phi to be between desired limits\n		phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n		// restrict phi to be betwee EPS and PI-EPS\n		phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n		var radius = offset.length() * scale;\n\n		// restrict radius to be between desired limits\n		radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\n		// move target to panned location\n		this.target.add( pan );\n\n		offset.x = radius * Math.sin( phi ) * Math.sin( theta );\n		offset.y = radius * Math.cos( phi );\n		offset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n		// rotate offset back to \"camera-up-vector-is-up\" space\n		offset.applyQuaternion( quatInverse );\n\n		position.copy( this.target ).add( offset );\n\n		this.object.lookAt( this.target );\n\n		thetaDelta = 0;\n		phiDelta = 0;\n		scale = 1;\n		pan.set( 0, 0, 0 );\n\n		// update condition is:\n		// min(camera displacement, camera rotation in radians)^2 > EPS\n		// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n		if ( lastPosition.distanceToSquared( this.object.position ) > EPS\n		    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {\n\n			this.dispatchEvent( changeEvent );\n\n			lastPosition.copy( this.object.position );\n			lastQuaternion.copy (this.object.quaternion );\n\n		}\n\n	};\n\n\n	this.reset = function () {\n\n		state = STATE.NONE;\n\n		this.target.copy( this.target0 );\n		this.object.position.copy( this.position0 );\n		this.object.zoom = this.zoom0;\n\n		this.object.updateProjectionMatrix();\n		this.dispatchEvent( changeEvent );\n\n		this.update();\n\n	};\n\n	this.getPolarAngle = function () {\n\n		return phi;\n\n	};\n\n	this.getAzimuthalAngle = function () {\n\n		return theta\n\n	};\n\n	function getAutoRotationAngle() {\n\n		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n	}\n\n	function getZoomScale() {\n\n		return Math.pow( 0.95, scope.zoomSpeed );\n\n	}\n\n	function onMouseDown( event ) {\n\n		if ( scope.enabled === false ) return;\n		event.preventDefault();\n\n		if ( event.button === scope.mouseButtons.ORBIT ) {\n			if ( scope.noRotate === true ) return;\n\n			state = STATE.ROTATE;\n\n			rotateStart.set( event.clientX, event.clientY );\n\n		} else if ( event.button === scope.mouseButtons.ZOOM ) {\n			if ( scope.noZoom === true ) return;\n\n			state = STATE.DOLLY;\n\n			dollyStart.set( event.clientX, event.clientY );\n\n		} else if ( event.button === scope.mouseButtons.PAN ) {\n			if ( scope.noPan === true ) return;\n\n			state = STATE.PAN;\n\n			panStart.set( event.clientX, event.clientY );\n\n		}\n\n		if ( state !== STATE.NONE ) {\n			document.addEventListener( 'mousemove', onMouseMove, false );\n			document.addEventListener( 'mouseup', onMouseUp, false );\n			scope.dispatchEvent( startEvent );\n		}\n\n	}\n\n	function onMouseMove( event ) {\n\n		if ( scope.enabled === false ) return;\n\n		event.preventDefault();\n\n		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n		if ( state === STATE.ROTATE ) {\n\n			if ( scope.noRotate === true ) return;\n\n			rotateEnd.set( event.clientX, event.clientY );\n			rotateDelta.subVectors( rotateEnd, rotateStart );\n\n			// rotating across whole screen goes 360 degrees around\n			scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n			// rotating up and down along whole screen attempts to go 360, but limited to 180\n			scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n			rotateStart.copy( rotateEnd );\n\n		} else if ( state === STATE.DOLLY ) {\n\n			if ( scope.noZoom === true ) return;\n\n			dollyEnd.set( event.clientX, event.clientY );\n			dollyDelta.subVectors( dollyEnd, dollyStart );\n\n			if ( dollyDelta.y > 0 ) {\n\n				scope.dollyIn();\n\n			} else if ( dollyDelta.y < 0 ) {\n\n				scope.dollyOut();\n\n			}\n\n			dollyStart.copy( dollyEnd );\n\n		} else if ( state === STATE.PAN ) {\n\n			if ( scope.noPan === true ) return;\n\n			panEnd.set( event.clientX, event.clientY );\n			panDelta.subVectors( panEnd, panStart );\n\n			scope.pan( panDelta.x, panDelta.y );\n\n			panStart.copy( panEnd );\n\n		}\n\n		if ( state !== STATE.NONE ) scope.update();\n\n	}\n\n	function onMouseUp( /* event */ ) {\n\n		if ( scope.enabled === false ) return;\n\n		document.removeEventListener( 'mousemove', onMouseMove, false );\n		document.removeEventListener( 'mouseup', onMouseUp, false );\n		scope.dispatchEvent( endEvent );\n		state = STATE.NONE;\n\n	}\n\n	function onMouseWheel( event ) {\n\n		if ( scope.enabled === false || scope.noZoom === true || state !== STATE.NONE ) return;\n\n		event.preventDefault();\n		event.stopPropagation();\n\n		var delta = 0;\n\n		if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\n\n			delta = event.wheelDelta;\n\n		} else if ( event.detail !== undefined ) { // Firefox\n\n			delta = - event.detail;\n\n		}\n\n		if ( delta > 0 ) {\n\n			scope.dollyOut();\n\n		} else if ( delta < 0 ) {\n\n			scope.dollyIn();\n\n		}\n\n		scope.update();\n		scope.dispatchEvent( startEvent );\n		scope.dispatchEvent( endEvent );\n\n	}\n\n	function onKeyDown( event ) {\n\n		if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\n\n		switch ( event.keyCode ) {\n\n			case scope.keys.UP:\n				scope.pan( 0, scope.keyPanSpeed );\n				scope.update();\n				break;\n\n			case scope.keys.BOTTOM:\n				scope.pan( 0, - scope.keyPanSpeed );\n				scope.update();\n				break;\n\n			case scope.keys.LEFT:\n				scope.pan( scope.keyPanSpeed, 0 );\n				scope.update();\n				break;\n\n			case scope.keys.RIGHT:\n				scope.pan( - scope.keyPanSpeed, 0 );\n				scope.update();\n				break;\n\n		}\n\n	}\n\n	function touchstart( event ) {\n\n		if ( scope.enabled === false ) return;\n\n		switch ( event.touches.length ) {\n\n			case 1:	// one-fingered touch: rotate\n\n				if ( scope.noRotate === true ) return;\n\n				state = STATE.TOUCH_ROTATE;\n\n				rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n				break;\n\n			case 2:	// two-fingered touch: dolly\n\n				if ( scope.noZoom === true ) return;\n\n				state = STATE.TOUCH_DOLLY;\n\n				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n				var distance = Math.sqrt( dx * dx + dy * dy );\n				dollyStart.set( 0, distance );\n				break;\n\n			case 3: // three-fingered touch: pan\n\n				if ( scope.noPan === true ) return;\n\n				state = STATE.TOUCH_PAN;\n\n				panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n				break;\n\n			default:\n\n				state = STATE.NONE;\n\n		}\n\n		if ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\n	}\n\n	function touchmove( event ) {\n\n		if ( scope.enabled === false ) return;\n\n		event.preventDefault();\n		event.stopPropagation();\n\n		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n		switch ( event.touches.length ) {\n\n			case 1: // one-fingered touch: rotate\n\n				if ( scope.noRotate === true ) return;\n				if ( state !== STATE.TOUCH_ROTATE ) return;\n\n				rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n				rotateDelta.subVectors( rotateEnd, rotateStart );\n\n				// rotating across whole screen goes 360 degrees around\n				scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n				// rotating up and down along whole screen attempts to go 360, but limited to 180\n				scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n				rotateStart.copy( rotateEnd );\n\n				scope.update();\n				break;\n\n			case 2: // two-fingered touch: dolly\n\n				if ( scope.noZoom === true ) return;\n				if ( state !== STATE.TOUCH_DOLLY ) return;\n\n				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n				var distance = Math.sqrt( dx * dx + dy * dy );\n\n				dollyEnd.set( 0, distance );\n				dollyDelta.subVectors( dollyEnd, dollyStart );\n\n				if ( dollyDelta.y > 0 ) {\n\n					scope.dollyOut();\n\n				} else if ( dollyDelta.y < 0 ) {\n\n					scope.dollyIn();\n\n				}\n\n				dollyStart.copy( dollyEnd );\n\n				scope.update();\n				break;\n\n			case 3: // three-fingered touch: pan\n\n				if ( scope.noPan === true ) return;\n				if ( state !== STATE.TOUCH_PAN ) return;\n\n				panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n				panDelta.subVectors( panEnd, panStart );\n\n				scope.pan( panDelta.x, panDelta.y );\n\n				panStart.copy( panEnd );\n\n				scope.update();\n				break;\n\n			default:\n\n				state = STATE.NONE;\n\n		}\n\n	}\n\n	function touchend( /* event */ ) {\n\n		if ( scope.enabled === false ) return;\n\n		scope.dispatchEvent( endEvent );\n		state = STATE.NONE;\n\n	}\n\n	this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n	this.domElement.addEventListener( 'mousedown', onMouseDown, false );\n	this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n	this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n	this.domElement.addEventListener( 'touchstart', touchstart, false );\n	this.domElement.addEventListener( 'touchend', touchend, false );\n	this.domElement.addEventListener( 'touchmove', touchmove, false );\n\n	window.addEventListener( 'keydown', onKeyDown, false );\n\n	// force an update at start\n	this.update();\n\n};\n\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/OrbitControls/index.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/OrbitControls/index.js?./~/imports-loader?THREE=three");
},function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\n( function() {\n\n	var _oldConsole = console.log;\n\n	var supportedTypes = [];\n\n	function addSupportedType( type, format ) {\n\n		supportedTypes.push( {\n			type: type,\n			format: format\n		} );\n\n	}\n\n	addSupportedType( THREE.Matrix4, function( v ) {\n\n		var e = v.elements;\n				\n		return [\n			[ e[ 0 ], e[ 4 ], e[ 8 ], e[ 12 ] ],\n			[ e[ 1 ], e[ 5 ], e[ 9 ], e[ 13 ] ],\n			[ e[ 2 ], e[ 6 ], e[ 10 ], e[ 14 ] ],\n			[ e[ 3 ], e[ 7 ], e[ 11 ], e[ 15 ] ]\n		];\n\n	} );\n\n	addSupportedType( THREE.Matrix3, function( v ) {\n\n		var e = v.elements;\n				\n		return [\n			[ e[ 0 ], e[ 3 ], e[ 6 ] ],\n			[ e[ 1 ], e[ 4 ], e[ 7 ] ],\n			[ e[ 2 ], e[ 5 ], e[ 8 ] ]\n		];\n\n	} );\n\n	addSupportedType( THREE.Vector2, function( v ) {\n\n		return {\n			Vector2: { x: v.x, y: v.y }\n		};\n\n	} );\n\n	addSupportedType( THREE.Vector3, function( v ) {\n\n		return {\n			Vector3: { x: v.x, y: v.y, z: v.z }\n		};\n\n	} );\n\n	addSupportedType( THREE.Vector4, function( v ) {\n\n		return {\n			Vector4: { x: v.x, y: v.y, z: v.z, w: v.w }\n		};\n\n	} );\n\n	addSupportedType( THREE.Euler, function( v ) {\n\n		return {\n			Vector4: { x: v.x, y: v.y, z: v.z, order: v.order }\n		};\n\n	} );\n\n	addSupportedType( THREE.Ray, function( v ) {\n\n		return { \n			'Ray origin': { x: v.origin.x, y: v.origin.y, z: v.origin.z },\n			'Ray direction': { x: v.direction.x, y: v.direction.y, z: v.direction.z }\n		};\n\n	} );\n\n	function stacktrace() { \n		var err = new Error();\n		return err.stack;\n	}\n\n	console.log = function() {\n\n		//console.trace ();\n\n		var special = false;\n\n		[].forEach.call( arguments, function( a ) { \n			supportedTypes.forEach( function( t ) {\n				if( a instanceof t.type ) special = true;;\n			} );\n		} );\n\n		if( special ) {\n\n			[].forEach.call( arguments, function( a ) { \n			\n				_oldConsole.apply( console, [ a ] );\n\n				supportedTypes.forEach( function( t ) {\n\n					if( a instanceof t.type ) {\n\n						console.table( t.format( a ) );\n\n					}\n					\n				} );\n\n			} );\n\n		} else {\n\n			_oldConsole.apply( console, arguments );\n\n		}\n\n	}\n\n} )();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/AugmentedConsole/index.js\n ** module id = 63\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/AugmentedConsole/index.js?./~/imports-loader?THREE=three")},function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\n/**\n * @author bchirls / http://bchirls.com/\n */\n\nTHREE.VRStereoEffect = function ( renderer, fullScreenElement, options ) {\n\n	// internals\n	var self = this;\n	var width = 0, height = 0;\n	var hmdWidth, hmdHeight;\n\n	var hmdDevice;\n	var vrMode;\n	var vrPreview = false;\n	var eyeOffsetLeft = new THREE.Vector3();\n	var eyeOffsetRight = new THREE.Vector3();\n\n	var position = new THREE.Vector3();\n	var quaternion = new THREE.Quaternion();\n	var scale = new THREE.Vector3();\n\n	var cameraLeft = new THREE.PerspectiveCamera();\n	var cameraRight = new THREE.PerspectiveCamera();\n	var leftRenderRect = {\n		x: 0, y: 0, width: 0, height: 0\n	};\n	var rightRenderRect = {\n		x: 0, y: 0, width: 0, height: 0\n	};\n\n	var near = 2;\n	var far = 40000;\n\n	var requestFullscreen;\n	var fullScreenParam = {\n		vrDisplay: null\n	};\n	var fovScale;\n\n	var RADIANS = Math.PI / 180;\n\n	var poll = options && options.poll || 1000;\n	var pollTimeout;\n\n	function perspectiveMatrixFromVRFieldOfView(fov, zNear, zFar) {\n		var outMat = new THREE.Matrix4(),\n			out = outMat.elements,\n			upTan = Math.tan(fov.upDegrees * RADIANS),\n			downTan = Math.tan(fov.downDegrees * RADIANS),\n			leftTan = Math.tan(fov.leftDegrees * RADIANS),\n			rightTan = Math.tan(fov.rightDegrees * RADIANS),\n\n			xScale = 2 / (leftTan + rightTan),\n			yScale = 2 / (upTan + downTan);\n\n		out[0] = xScale;\n		out[4] = 0;\n		out[8] = -((leftTan - rightTan) * xScale * 0.5);\n		out[12] = 0;\n\n		out[1] = 0;\n		out[5] = yScale;\n		out[9] = ((upTan - downTan) * yScale * 0.5);\n		out[13] = 0;\n\n		out[2] = 0;\n		out[6] = 0;\n		out[10] = zFar / (zNear - zFar);\n		out[14] = (zFar * zNear) / (zNear - zFar);\n\n		out[3] = 0;\n		out[7] = 0;\n		out[11] = -1;\n		out[15] = 0;\n\n		return outMat;\n	}\n\n	function resize() {\n		var w, h;\n\n		if (hmdDevice && vrMode) {\n			w = hmdWidth;// / Math.pow(window.devicePixelRatio || 1, 2);\n			h = hmdHeight;// / Math.pow(window.devicePixelRatio || 1, 2);\n		} else {\n			w = width || renderer.domElement.offsetWidth || window.innerWidth;\n			h = height || renderer.domElement.offsetHeight || window.innerHeight;\n		}\n\n		renderer.setSize(w, h);\n	}\n\n	function updateProjection() {\n		var fovLeft,\n			fovRight,\n\n			leftEyeParams,\n			rightEyeParams,\n			leftEyeRect,\n			rightEyeRect,\n\n			leftEyeViewport,\n			rightEyeViewport;\n\n		if (!hmdDevice) {\n			cameraLeft.fov = 80;\n			cameraRight.fov = 80;\n			return;\n		}\n\n		// if (amount && hmdDevice.setFieldOfView) {\n		// 	fovScale += amount;\n		// 	fovScale = Math.max(0.1, fovScale);\n\n		// 	fovLeft = hmdDevice.getRecommendedEyeFieldOfView('left');\n\n		// 	fovLeft.upDegrees *= fovScale;\n		// 	fovLeft.downDegrees *= fovScale;\n		// 	fovLeft.leftDegrees *= fovScale;\n		// 	fovLeft.rightDegrees *= fovScale;\n\n		// 	fovRight = hmdDevice.getRecommendedEyeFieldOfView('right');\n		// 	fovRight.upDegrees *= fovScale;\n		// 	fovRight.downDegrees *= fovScale;\n		// 	fovRight.leftDegrees *= fovScale;\n		// 	fovRight.rightDegrees *= fovScale;\n\n		// 	hmdDevice.setFieldOfView(fovLeft, fovRight);\n		// }\n\n		if (hmdDevice.getEyeParameters) {\n			leftEyeParams = hmdDevice.getEyeParameters('left');\n			rightEyeParams = hmdDevice.getEyeParameters('right');\n			leftEyeRect = leftEyeParams.renderRect;\n			rightEyeRect = rightEyeParams.renderRect;\n\n			hmdWidth = rightEyeRect.x + rightEyeRect.width;\n			hmdHeight = Math.max(leftEyeRect.y + leftEyeRect.height, rightEyeRect.y + rightEyeRect.height);\n\n			fovLeft = leftEyeParams.currentFieldOfView;\n			fovRight = rightEyeParams.currentFieldOfView;\n\n			hmdDevice.setFieldOfView(fovLeft, fovRight, near, far);\n\n			eyeOffsetLeft.copy(leftEyeParams.eyeTranslation);\n			eyeOffsetRight.copy(rightEyeParams.eyeTranslation);\n\n			leftRenderRect = leftEyeParams.renderRect;\n			rightRenderRect = rightEyeParams.renderRect;\n		} else if (hmdDevice.getRecommendedEyeRenderRect) {\n			leftEyeViewport = hmdDevice.getRecommendedEyeRenderRect('left');\n			rightEyeViewport = hmdDevice.getRecommendedEyeRenderRect('right');\n\n			hmdWidth = leftEyeViewport.width + rightEyeViewport.width;\n			hmdHeight = Math.max(leftEyeViewport.height, rightEyeViewport.height);\n\n			if (hmdDevice.getCurrentEyeFieldOfView) {\n				fovLeft = hmdDevice.getCurrentEyeFieldOfView('left');\n				fovRight = hmdDevice.getCurrentEyeFieldOfView('right');\n			} else {\n				fovLeft = hmdDevice.getRecommendedEyeFieldOfView('left');\n				fovRight = hmdDevice.getRecommendedEyeFieldOfView('right');\n			}\n\n			eyeOffsetLeft.copy(hmdDevice.getEyeTranslation('left'));\n			eyeOffsetRight.copy(hmdDevice.getEyeTranslation('right'));\n\n			leftRenderRect.x = leftEyeViewport.left;\n			leftRenderRect.y = leftEyeViewport.top;\n			leftRenderRect.width = leftEyeViewport.width;\n			leftRenderRect.height = leftEyeViewport.height;\n\n			rightRenderRect.x = rightEyeViewport.left;\n			rightRenderRect.y = rightEyeViewport.top;\n			rightRenderRect.width = rightEyeViewport.width;\n			rightRenderRect.height = rightEyeViewport.height;\n		}\n\n		resize();\n\n		cameraLeft.projectionMatrix = perspectiveMatrixFromVRFieldOfView(fovLeft, near, far);\n		cameraRight.projectionMatrix = perspectiveMatrixFromVRFieldOfView(fovRight, near, far);\n	}\n\n	function gotVRDevices(devices) {\n		var i,\n			device;\n\n		for (i = 0; i < devices.length; i++) {\n			device = devices[i];\n			if ( device instanceof HMDVRDevice ) {\n\n				if ( hmdDevice && device.hardwareUnitId === hmdDevice.hardwareUnitId ) {\n					break;\n				}\n\n				hmdDevice = device;\n				console.log('Using HMD Device:', hmdDevice.deviceName);\n\n				if (hmdDevice.setTimewarp) {\n					//hmdDevice.setTimewarp(false);\n				}\n\n				updateProjection();\n\n				fullScreenParam.vrDisplay = hmdDevice;\n\n				self.dispatchEvent( {\n					type: \"devicechange\"\n				} );\n\n				break;\n			}\n		}\n\n		if (poll) {\n			clearTimeout(pollTimeout);\n			setTimeout(self.scan, poll);\n		}\n	}\n\n	function onFullscreenChange() {\n		if (!document.webkitFullscreenElement &&\n				!document.mozFullScreenElement &&\n				!document.msFullscreenElement) {\n			vrMode = false;\n		}\n\n		updateProjection();\n\n		self.dispatchEvent( {\n			type: \"fullscreenchange\"\n		} );\n	}\n\n	// API\n\n	this.separation = 0.01;\n\n	// initialization\n\n	renderer.autoClear = false;\n\n	if (!fullScreenElement) {\n		fullScreenElement = renderer.domElement;\n	}\n	requestFullscreen = fullScreenElement.webkitRequestFullscreen ||\n		fullScreenElement.mozRequestFullScreen ||\n		fullScreenElement.msRequestFullscreen;\n	if (requestFullscreen) {\n		requestFullscreen = requestFullscreen.bind(fullScreenElement, fullScreenParam);\n	}\n\n	document.addEventListener('fullscreenchange', onFullscreenChange, false);\n	document.addEventListener('webkitfullscreenchange', onFullscreenChange, false);\n	document.addEventListener('mozfullscreenchange', onFullscreenChange, false);\n	document.addEventListener('MSFullscreenChange', onFullscreenChange, false);\n\n	//todo: method for adjusting HMD FOV\n\n	this.scan = function () {\n		if (navigator.getVRDevices) {\n			navigator.getVRDevices().then(gotVRDevices);\n		} else if (navigator.mozGetVRDevices) {\n			navigator.mozGetVRDevices(gotVRDevices);\n		}\n	};\n\n	this.requestFullScreen = function () {\n		vrMode = true;\n		requestFullscreen();\n	};\n\n	this.exit = function () {\n		vrMode = false;\n		vrPreview = false;\n	};\n\n	this.setSize = function ( w, h ) {\n		width = w;\n		height = h;\n\n		resize();\n	};\n\n	this.vrPreview = function (val) {\n		if (val !== undefined) {\n			vrPreview = !!val;\n		}\n		return vrPreview;\n	};\n\n	this.isFullscreen = function () {\n		return vrMode;\n	};\n\n	this.hmd = function () {\n		return hmdDevice;\n	};\n\n	this.render = function ( leftScene, rightScene, camera, renderTarget, forceClear ) {\n		var w, h;\n\n		if ( rightScene && rightScene instanceof THREE.Scene ) {\n			//rightScene.updateMatrixWorld();\n		} else {\n			if ( (!camera || camera instanceof THREE.WebGLRenderTarget) && rightScene instanceof THREE.Camera ) {\n				forceClear = renderTarget;\n				renderTarget = camera;\n				camera = rightScene;\n			}\n			rightScene = leftScene;\n		}\n\n		//leftScene.updateMatrixWorld();\n\n		if ( camera.parent === undefined ) {\n			camera.updateMatrixWorld();\n		}\n\n		w = width || renderer.domElement.width;\n		h = height || renderer.domElement.height;\n		// w /= window.devicePixelRatio || 1;\n		// h /= window.devicePixelRatio || 1;\n\n		/*\n		todo: make this work when CSS VR Rendering is fixed\n		http://blog.bitops.com/blog/2014/08/20/updated-firefox-vr-builds/\n		if (renderer instanceof THREE.CSS3DRenderer) {\n			renderer.render( leftScene, camera );\n			return;\n		}\n		*/\n\n		if (!vrMode && !vrPreview) {\n			renderer.enableScissorTest( false );\n			renderer.setViewport( 0, 0, w, h );\n			renderer.render( leftScene, camera, renderTarget, true );\n			return;\n		}\n\n		camera.matrixWorld.decompose( position, quaternion, scale );\n\n		if (!hmdDevice) {\n			// left\n			//cameraLeft.fov = camera.fov;\n			cameraLeft.aspect = 0.5 * camera.aspect;\n			cameraLeft.near = camera.near;\n			cameraLeft.far = camera.far;\n			cameraLeft.updateProjectionMatrix();\n\n			// right\n\n			// cameraRight.fov = camera.fov;\n			cameraRight.aspect = 0.5 * camera.aspect;\n			cameraRight.near = camera.near;\n			cameraRight.far = camera.far;\n			cameraRight.updateProjectionMatrix();\n		}\n\n		cameraLeft.position.copy( position );\n		cameraLeft.quaternion.copy( quaternion );\n\n		cameraRight.position.copy( position );\n		cameraRight.quaternion.copy( quaternion );\n\n		if (hmdDevice) {\n			cameraLeft.position.add( eyeOffsetLeft ) ;\n			cameraRight.position.add( eyeOffsetRight );\n		} else {\n			cameraLeft.translateX( - this.separation );\n			cameraRight.translateX( this.separation );\n		}\n\n		cameraLeft.updateMatrixWorld();\n		cameraRight.updateMatrixWorld();\n\n		//\n\n		renderer.enableScissorTest(true);\n\n		w = renderer.context.drawingBufferWidth / 2;\n\n		if (renderTarget) {\n			renderer.setRenderTarget(renderTarget);\n		}\n\n		rightScene.traverseVisible(function (obj) {\n			if (obj.material && obj.material.map) {\n				if (obj.userData.stereo === 'vertical') {\n					obj.material.map.offset.set(0, 0.5);\n				} else if (obj.userData.stereo) {\n					obj.material.map.offset.set(0.5, 0);\n				}\n			}\n		});\n		renderer.setScissor( w, 0, w, h );\n		renderer.setViewport( w, 0, w, h );\n		renderer.render( rightScene, cameraRight, renderTarget, forceClear );\n\n		leftScene.traverseVisible(function (obj) {\n			if (obj.userData.stereo && obj.material && obj.material.map) {\n				obj.material.map.offset.set(0, 0);\n			}\n		});\n		renderer.setScissor( 0, 0, w, h );\n		renderer.setViewport( 0, 0, w, h );\n		renderer.render( leftScene, cameraLeft, renderTarget, forceClear );\n\n		//reset viewport, scissor\n		w *= 2;\n		renderer.setViewport( 0, 0, w, h );\n		renderer.setScissor( 0, 0, w, h );\n		renderer.enableScissorTest( false );\n	};\n\n	Object.defineProperty(this, 'near', {\n		get: function () {\n			return near;\n		},\n		set: function (val) {\n			val = parseFloat(val);\n			if (val && !isNaN(val)) {\n				near = Math.max(0, val);\n				updateProjection();\n			}\n		}\n	});\n\n	Object.defineProperty(this, 'far', {\n		get: function () {\n			return far;\n		},\n		set: function (val) {\n			val = parseFloat(val);\n			if (val && !isNaN(val)) {\n				far = Math.max(0, val);\n				updateProjection();\n			}\n		}\n	});\n\n	this.scan();\n	resize();\n};\n\nTHREE.VRStereoEffect.prototype = Object.create( THREE.EventDispatcher.prototype );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./src/lib/VRStereoEffect.js\n ** module id = 64\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/lib/VRStereoEffect.js?./~/imports-loader?THREE=three")},function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\ncallback = function(device){\n};\n\nTHREE.VRControls = function ( object, options ) {\n\n	var self = this;\n\n	//HMD sensor stuff\n	var sensorDevice;\n	var vrState;\n\n	//device orientation stuff\n	var deviceControls;\n	var zeroAngle = 0;\n\n	var mode = '';\n\n	var vrBrowser = navigator.getVRDevices || navigator.mozGetVRDevices;\n\n	var poll = options && options.poll || 1000;\n	var pollTimeout;\n\n	function gotVRDevices( devices ) {\n		var i,\n			device;\n\n		for ( i = 0; i < devices.length; ++i ) {\n			device = devices[i];\n			if ( devices[i] instanceof PositionSensorVRDevice ) {\n\n				if ( sensorDevice && devices[i].hardwareUnitId === sensorDevice.hardwareUnitId ) {\n					break;\n				}\n\n				sensorDevice = device;\n				console.log('Using Sensor Device:', sensorDevice.deviceName);\n				callback(sensorDevice);\n\n				if ( sensorDevice.zeroSensor ) {\n					self.zeroSensor = sensorDevice.zeroSensor.bind(sensorDevice);\n				} else if ( sensorDevice.resetSensor ) {\n					self.zeroSensor = sensorDevice.resetSensor.bind(sensorDevice);\n				}\n				self.zeroSensor();\n\n				mode = 'hmd';\n\n				self.dispatchEvent( {\n					type: \"devicechange\"\n				} );\n\n				break; // We keep the first we encounter\n			}\n		}\n\n		if (poll) {\n			clearTimeout(pollTimeout);\n			setTimeout(self.scan, poll);\n		}\n	}\n\n	function deviceOrientationChange( event ) {\n		if ( typeof event.gamma === 'number' ) {\n			mode = 'deviceorientation';\n			window.removeEventListener( 'deviceorientation', deviceOrientationChange, false );\n			deviceControls = new THREE.DeviceOrientationControls( object );\n			deviceControls.connect();\n\n			self.dispatchEvent( {\n				type: \"devicechange\"\n			} );\n		}\n	}\n\n	this.update = function() {\n		// Applies head rotation from sensor data.\n			return;\n\n		if ( sensorDevice ) {\n			vrState = sensorDevice.getState();\n			if ( vrState ) {\n				if ( vrState.orientation && vrState.hasOrientation !== false ) {\n					object.quaternion.copy( vrState.orientation );\n				}\n\n				if ( vrState.position && vrState.hasPosition !== false ) {\n					// vrState.position is null if using DK1 or if DK2 camera is not plugged in\n					object.position.copy( vrState.position );\n				}\n\n				object.updateMatrixWorld();\n			}\n		} else if (deviceControls && deviceControls.deviceOrientation.gamma !== undefined) {\n			deviceControls.update();\n			object.rotateY(-zeroAngle);\n			object.updateMatrixWorld();\n		}\n	};\n\n	//only useful when frozen\n	this.reset = function () {\n		if ( object ) {\n			object.quaternion.set( 0, 0, 0, 1 );\n			object.position.set( 0, 0, 0 );\n		}\n	};\n\n	//zeros only rotation on Y axis\n	//todo: find out if it zeros out position. need a DK2 to test\n	this.zeroSensor = function () {\n		if (sensorDevice && sensorDevice.zeroSensor) {\n			sensorDevice.zeroSensor();\n		}\n		zeroAngle = object.rotation.y;\n		self.update();\n	};\n\n	this.freeze = true;\n\n	//method to query which tech we're using\n	this.mode = function () {\n		return mode;\n	};\n\n	this.scan = function () {\n		if ( navigator.getVRDevices ) {\n			navigator.getVRDevices().then( gotVRDevices );\n		} else if ( navigator.mozGetVRDevices ) {\n			navigator.mozGetVRDevices( gotVRDevices );\n		}\n	};\n\n	//todo: connect/disconnect methods\n	//todo: method to query orientation/position without changing object\n	//todo: work without an object\n\n	if ( vrBrowser ) {\n		this.scan();\n	} else if ( \"DeviceOrientationEvent\" in window && THREE.DeviceOrientationControls) {\n		//device orientation\n		window.addEventListener( \"deviceorientation\", deviceOrientationChange, false );\n	}\n};\n\nTHREE.VRControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./src/lib/VRControls.js\n ** module id = 65\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/lib/VRControls.js?./~/imports-loader?THREE=three")},function(module,exports,__webpack_require__){eval('var map = {\n	"./box": 67,\n	"./box.js": 67,\n	"./cylinder": 68,\n	"./cylinder.js": 68,\n	"./empty": 60,\n	"./empty.js": 60,\n	"./floor": 69,\n	"./floor.js": 69,\n	"./grid": 70,\n	"./grid.js": 70,\n	"./image": 71,\n	"./image.js": 71,\n	"./lvideo": 72,\n	"./lvideo.js": 72,\n	"./panorama": 73,\n	"./panorama.js": 73,\n	"./sky": 74,\n	"./sky.js": 74,\n	"./sound": 76,\n	"./sound.js": 76,\n	"./sphere": 78,\n	"./sphere.js": 78,\n	"./text": 79,\n	"./text.js": 79,\n	"./torus": 80,\n	"./torus.js": 80,\n	"./video": 81,\n	"./video.js": 81\n};\nfunction webpackContext(req) {\n	return __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n	return map[req] || (function() { throw new Error("Cannot find module \'" + req + "\'.") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n	return Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 66;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects ^\\.\\/.*$\n ** module id = 66\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects_^\\.\\/.*$?')},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9),\n		geometry = new THREE.BoxGeometry( 1, 1, 1 );\n\n	return function box(parent, options) {\n		var mesh;\n\n		mesh = new THREE.Mesh(geometry, materials.standard());\n		mesh.name = 'box';\n\n		parent.add(mesh);\n\n		return mesh;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/box.js\n ** module id = 67\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/box.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	function cylinder(parent, options) {\n		var geometry,\n			mesh;\n\n		geometry = new THREE.CylinderGeometry(\n			options.radiusTop === undefined ? 0.5 : options.radiusTop,\n			options.radiusBottom === undefined ? 0.5 : options.radiusBottom,\n			options.height === undefined ? 1 : options.height,\n			options.radiusSegments === undefined ? 16 : options.radiusSegments,\n			options.heightSegments,\n			options.openEnded\n		);\n		mesh = new THREE.Mesh(geometry, materials.standard());\n		mesh.name = 'cylinder';\n\n		parent.add(mesh);\n\n		return mesh;\n	}\n\n	return cylinder;\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/cylinder.js\n ** module id = 68\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/cylinder.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	function floor(parent, options) {\n		var obj,\n			geometry;\n\n		geometry = new THREE.CircleGeometry( options.radius || 100, options.segments || 16 );\n		geometry.applyMatrix( new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n\n		obj = new THREE.Mesh(\n			geometry,\n			materials.checkerboard({\n				repeat: 100\n			})\n		);\n		obj.name = 'floor';\n\n		obj.receiveShadow = true;\n\n		parent.add(obj);\n\n		return obj;\n	}\n\n	return floor;\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/floor.js\n ** module id = 69\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/floor.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var THREE = __webpack_require__(9);\n\n	return function box(parent, options) {\n		var obj,\n			size = options && options.size || 10,\n			step = options && options.step || 1;\n\n		obj = new THREE.GridHelper(size, step);\n		obj.name = 'grid';\n		if (options) {\n			obj.setColors(options.colorCenterLine || obj.color1, options.colorGrid || obj.color2);\n		}\n		obj.geometry.computeBoundingBox();\n\n		parent.add(obj);\n\n		return obj;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/grid.js\n ** module id = 70\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/grid.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	return function image(parent, options) {\n		var geometry,\n			material,\n			mesh,\n			src,\n			tex,\n			self = this;\n\n		if (typeof options === 'string') {\n			src = options;\n		} else if (options) {\n			src = options.src;\n		}\n\n		if (src) {\n			tex = materials.imageTexture(src, THREE.UVMapping, function (t, image) {\n				//todo: don't do any of this if object has been deleted\n				geometry.applyMatrix(new THREE.Matrix4().makeScale(1, image.naturalHeight / image.naturalWidth, 1));\n				material.map = tex;\n				material.visible = true;\n				mesh.visible = true;\n				parent.add(mesh);\n\n				self.emit('loaded');\n			});\n		}\n\n		geometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n\n		material = new THREE.MeshBasicMaterial({\n			side: THREE.DoubleSide,\n			transparent: true,\n			map: tex\n		});\n\n		mesh = new THREE.Mesh( geometry, material );\n\n		mesh.visible = false;\n\n		parent.add(mesh);\n\n		return mesh;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/image.js\n ** module id = 71\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/image.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var THREE = __webpack_require__(9),\n		urlRegex = __webpack_require__(29),\n		extRegex = /\\.(webm|ogg|ogv|m4v|mp4|mov)/i,\n		lvideo;\n\n	lvideo = function (parent, options) {\n		var geometry,\n			material,\n			mesh,\n			vid,\n			tex,\n			aspectRatio = 1,\n			playing = false,\n			self = this;\n\n		function isPowerOfTwo(num) {\n			return num > 0 && (num & (num-1)) === 0; // jshint ignore:line\n		}\n\n		function loadedMetadata() {\n			//todo: don't do any of this if object has been deleted\n\n			var newAspectRatio = vid.videoWidth / vid.videoHeight;\n			if (!options || !options.sphere) {\n				geometry.applyMatrix(new THREE.Matrix4().makeScale(1, aspectRatio / newAspectRatio, 1));\n			}\n			aspectRatio = newAspectRatio;\n\n			if (vid.videoWidth === vid.videoHeight &&\n				isPowerOfTwo(vid.videoWidth) && isPowerOfTwo(vid.videoHeight)) {\n\n				tex.minFilter = THREE.LinearMipMapLinearFilter;\n				tex.generateMipmaps = true;\n			} else {\n				tex.minFilter = THREE.LinearFilter;\n				tex.generateMipmaps = false;\n			}\n\n			material.map = tex;\n			material.visible = true;\n\n			if (playing) {\n				vid.play();\n			}\n		}\n\n		function setSource(sources) {\n			sources.forEach(function (src) {\n				var parse,\n					ext,\n					source;\n\n				if (!src) {\n					return;\n				}\n\n				parse = urlRegex.exec(src);\n				if (parse &&\n					(parse[1] && parse[1] !== window.location.hostΩ ||\n					parse[2] && parse[2] !== window.location.port)) {\n\n					if (vid.crossOrigin !== undefined) {\n						vid.crossOrigin = 'anonymous';\n					} else {\n						console.warn('Browser does not support cross-origin video');\n						return;\n					}\n				}\n				source = document.createElement('source');\n				source.src = src;\n\n				ext = extRegex.exec(src);\n				if (!ext || vid.canPlayType('video/' + ext[1])) {\n					vid.appendChild(source);\n				}\n			});\n		}\n\n		/*\n		 Pause the video when this browser tab is in the background or minimized.\n		 Resume when it comes back in focus, but only if the user didn't pause manually.\n		 */\n		function visibilityChange() {\n			if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n				vid.pause();\n			} else if (playing) {\n				vid.play();\n			}\n		}\n\n		vid = document.createElement('video');\n		vid.loop = true;\n		vid.addEventListener('loadedmetadata', loadedMetadata, false);\n\n		if (Array.isArray(options)) {\n			setSource(options);\n		} if (typeof options === 'string') {\n			setSource([options]);\n		} else if (typeof options.src === 'string') {\n			setSource([options.src]);\n		} else if (Array.isArray(options.src)) {\n			setSource(options.src);\n		}\n\n		vid.load();\n\n		tex = new THREE.VideoTexture(vid, THREE.UVMapping);\n		tex.format = THREE.RGBFormat;\n\n		if (options && options.sphere) {\n			geometry = new THREE.SphereGeometry(\n				994, //radius\n				60, //widthSegments\n				60, //heightSegments\n				(parseFloat(options.phiStart) || 0) * Math.PI * 2,\n				(parseFloat(options.phiLength) || 1) * Math.PI * 2,\n				(parseFloat(options.thetaStart) || 0) * Math.PI,\n				(parseFloat(options.thetaLength) || 1) * Math.PI\n			);\n			geometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n			geometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n		} else {\n			geometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n		}\n\n		var uniforms = {\n			OpticalCenter: {\n				type: 'v2',\n				value: new THREE.Vector2( 0.4939155, 0.5298627 )\n			},\n			FCoff: {\n				type: 'v2',\n				value: new THREE.Vector2( 0.5459919,0.97142231 )\n			},\n			KCoff: {\n				type: 'v4',\n				value: new THREE.Vector4( -0.26265967,0.11121539,-0.00042497579,-0.00015385781 )\n			},\n			texture1 : { type : 't', value: tex },\n			edgeColor: {\n				type: 'v4',\n				value: new THREE.Vector4(0, 0, 0, 0)\n			},\n			edge: {\n				type: 'i',\n				value: true\n			}\n		};\n\n		material = new THREE.ShaderMaterial({\n			uniforms:uniforms,\n			// シェーダーを割り当てる\n			fragmentShader: window.fs,\n			vertexShader: window.vs\n		});\n\n		/*\n		 material = new THREE.MeshBasicMaterial({\n		 side: THREE.DoubleSide,\n		 map: tex,\n		 visible: false\n		 });\n		 */\n\n		mesh = new THREE.Mesh(geometry, material);\n\n		if (options && options.stereo) {\n			if (options.stereo === 'vertical') {\n				tex.repeat.y = 0.5;\n			} else {\n				tex.repeat.x = 0.5;\n			}\n			mesh.userData.stereo = options.stereo;\n		}\n\n		if (vid.readyState) {\n			loadedMetadata();\n		}\n\n		this.play = function play() {\n			playing = true;\n			vid.play();\n			return this;\n		};\n\n		this.pause = function pause() {\n			playing = false;\n			vid.pause();\n			return this;\n		};\n\n		this.canPlayType = lvideo.canPlayType;\n\n		Object.defineProperty(this, 'width', {\n			get: function () {\n				return vid.videoWidth;\n			}\n		});\n\n		Object.defineProperty(this, 'height', {\n			get: function () {\n				return vid.videoHeight;\n			}\n		});\n\n		Object.defineProperty(this, 'paused', {\n			get: function () {\n				return !playing;\n			}\n		});\n\n		Object.defineProperty(this, 'volume', {\n			get: function () {\n				return vid.volume;\n			},\n			set: function (vol) {\n				vid.volume = vol;\n			}\n		});\n\n		Object.defineProperty(this, 'muted', {\n			get: function () {\n				return vid.muted;\n			},\n			set: function (muted) {\n				vid.muted = muted;\n			}\n		});\n\n		Object.defineProperty(this, 'duration', {\n			get: function () {\n				return vid.duration || 0;\n			}\n		});\n\n		Object.defineProperty(this, 'currentTime', {\n			get: function () {\n				return vid.currentTime;\n			},\n			set: function (currentTime) {\n				if (vid.readyState && currentTime < vid.duration && currentTime >= 0) {\n					vid.currentTime = currentTime;\n				}\n			}\n		});\n\n		[\n			'loadedmetadata',\n			'play',\n			'pause',\n			'playing',\n			'progress'\n		].forEach(function registerMediaEvent(event) {\n				vid.addEventListener(event, self.emit.bind(self, event));\n			});\n\n		//sometimes video fails to play because it's too big. remove it and try again\n		vid.addEventListener('error', function (evt) {\n			if (vid.error.code === window.MediaError.MEDIA_ERR_DECODE && vid.childNodes.length > 1) {\n				material.visible = false;\n				vid.removeChild(vid.firstChild);\n				vid.load();\n			}\n\n			self.emit(event, evt);\n		}, true);\n\n		this.element = vid;\n\n		window.addEventListener('touchstart', function touchStart() {\n			if (playing) {\n				vid.play();\n			} else {\n				vid.load();\n			}\n			window.removeEventListener('touchstart', touchStart, true);\n		}, true);\n\n		//pause when window is hidden\n		document.addEventListener('visibilitychange', visibilityChange);\n		document.addEventListener('mozvisibilitychange', visibilityChange);\n		document.addEventListener('msvisibilitychange', visibilityChange);\n		document.addEventListener('webkitvisibilitychange', visibilityChange);\n\n		mesh.name = 'lvideo';\n		this.raycastable = !(options && options.sphere);\n		parent.add(mesh);\n\n		return mesh;\n	};\n\n	lvideo.canPlayType = function canPlayType(type) {\n		var element = document.createElement('video');\n		return element.canPlayType(type);\n	};\n\n	return lvideo;\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/lvideo.js\n ** module id = 72\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/lvideo.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9),\n		geometry = new THREE.SphereGeometry(1000, 60, 60);\n\n	geometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n	geometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n\n	return function panorama(parent, options) {\n		var material,\n			mesh,\n			src,\n			tex,\n			self = this;\n\n		if (typeof options === 'string') {\n			src = options;\n		} else if (options) {\n			src = options.src;\n		}\n\n		if (src) {\n			tex = materials.imageTexture(src, THREE.UVMapping, function () {\n				self.emit('loaded');\n			});\n		}\n\n		material = new THREE.MeshBasicMaterial({\n			transparent: true,\n			map: tex\n		});\n\n		mesh = new THREE.Mesh(geometry, material);\n\n		if (options && options.stereo) {\n			if (options.stereo === 'vertical') {\n				tex.repeat.y = 0.5;\n			} else {\n				tex.repeat.x = 0.5;\n			}\n			mesh.userData.stereo = options.stereo;\n		}\n\n		mesh.name = 'panorama';\n\n		parent.add(mesh);\n\n		this.raycastable = false;\n\n		return mesh;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/panorama.js\n ** module id = 73\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/panorama.js?");
},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9),\n		TAU = Math.PI * 2,\n		HALF_PI = Math.PI / 2,\n\n		distance = 400000,\n		scratchVector = new THREE.Vector3(),\n\n		params = [\n			'luminance',\n			'turbidity',\n			'reileigh',\n			'mieCoefficient',\n			'mieDirectionalG'\n		];\n\n	__webpack_require__(75);\n\n	return function sky(parent, options) {\n		var obj = new THREE.Sky(),\n			self = this,\n			scene = parent,\n			light,\n			sunPosition,\n			azimuth = Math.PI / 6,\n			altitude = Math.PI / 6;\n\n		function mod(x, y) {\n			return x - y * Math.floor(x / y);\n		}\n\n		function update() {\n			var sinTheta,\n				cosTheta,\n				phi,\n				sinPhi,\n				cosPhi;\n\n			sinTheta = Math.sin(altitude);\n			cosTheta = Math.cos(altitude);\n			phi = -HALF_PI - azimuth;\n			sinPhi = Math.sin(phi);\n			cosPhi = Math.cos(phi);\n\n			sunPosition.set(\n				distance * cosPhi * cosTheta,\n				distance * sinTheta,\n				distance * sinPhi * cosTheta\n			);\n\n			if (light) {\n				light.intensity = 1.5 * Math.max(0.0, 1.0 - Math.exp(-((Math.PI / 1.95 - Math.abs(HALF_PI - altitude)) / 1.5)));\n				light.position.copy(sunPosition).normalize().multiplyScalar(100);\n			}\n		}\n\n		obj.mesh.name = 'sky';\n\n		parent.add(obj.mesh);\n\n		while (!(scene instanceof THREE.Scene) && scene.parent) {\n			scene = scene.parent;\n		}\n		light = scene.getObjectByName('directional-light');\n\n		this.setOptions = function (options) {\n			var needUpdate = false,\n				altitude,\n				azimuth;\n\n			if (options) {\n				params.forEach(function (param) {\n					var val = options[param];\n					if (val !== undefined) {\n						val = parseFloat(val);\n						if (!isNaN(val)) {\n							obj.uniforms[param].value = val;\n						}\n					}\n				});\n\n				if (options.sunPosition instanceof THREE.Vector3) {\n					obj.uniforms.sunPosition.value.copy(options.sunPosition);\n				} else if (Array.isArray(options.sunPosition)) {\n					obj.uniforms.sunPosition.value.set(obj.uniforms.sunPosition.value, options.sunPosition);\n				} else {\n					self.altitude = options.altitude;\n					self.azimuth = options.azimuth;\n				}\n			}\n		};\n\n		Object.defineProperty(this, 'azimuth', {\n			set: function (val) {\n				val = mod(parseFloat(val), TAU);\n				if (!isNaN(val) && val !== azimuth) {\n					azimuth = val;\n					update();\n				}\n			},\n			get: function () {\n				return azimuth;\n			}\n		});\n\n		Object.defineProperty(this, 'altitude', {\n			set: function (val) {\n				val = mod(parseFloat(val), TAU);\n				if (!isNaN(val) && val !== altitude) {\n					altitude = val;\n					update();\n				}\n			},\n			get: function() {\n				return altitude;\n			}\n		});\n\n		this.setAltitude = function (val) {\n			self.altitude = val;\n			return this;\n		};\n\n		this.setAzimuth = function (val) {\n			self.azimuth = val;\n			return this;\n		};\n\n		sunPosition = obj.uniforms.sunPosition.value;\n		update();\n\n		this.setOptions(options);\n\n		this.raycastable = false;\n\n		return obj.mesh;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/sky.js\n ** module id = 74\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/sky.js?")},function(module,exports,__webpack_require__){eval('/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\n/**\n * @author zz85 / https://github.com/zz85\n *\n * Based on "A Practical Analytic Model for Daylight"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n*/\n\nTHREE.ShaderLib[\'sky\'] = {\n\n	uniforms: {\n\n		luminance:	 { type: "f", value:1 },\n		turbidity:	 { type: "f", value:2 },\n		reileigh:	 { type: "f", value:1 },\n		mieCoefficient:	 { type: "f", value:0.005 },\n		mieDirectionalG: { type: "f", value:0.8 },\n		sunPosition: 	 { type: "v3", value: new THREE.Vector3() }\n\n	},\n\n	vertexShader: [\n\n		"varying vec3 vWorldPosition;",\n\n		"void main() {",\n\n			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",\n			"vWorldPosition = worldPosition.xyz;",\n\n			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",\n\n		"}",\n\n	].join("\\n"),\n\n	fragmentShader: [\n\n		"uniform sampler2D skySampler;",\n		"uniform vec3 sunPosition;",\n		"varying vec3 vWorldPosition;",\n\n		"vec3 cameraPos = vec3(0., 0., 0.);",\n		"// uniform sampler2D sDiffuse;",\n		"// const float turbidity = 10.0; //",\n		"// const float reileigh = 2.; //",\n		"// const float luminance = 1.0; //",\n		"// const float mieCoefficient = 0.005;",\n		"// const float mieDirectionalG = 0.8;",\n\n		"uniform float luminance;",\n		"uniform float turbidity;",\n		"uniform float reileigh;",\n		"uniform float mieCoefficient;",\n		"uniform float mieDirectionalG;",\n\n		"vec3 sunDirection = normalize(sunPosition);",\n		"float reileighCoefficient = reileigh;",\n\n		"// constants for atmospheric scattering",\n		"const float e = 2.71828182845904523536028747135266249775724709369995957;",\n		"const float pi = 3.141592653589793238462643383279502884197169;",\n\n		"const float n = 1.0003; // refractive index of air",\n		"const float N = 2.545E25; // number of molecules per unit volume for air at",\n								"// 288.15K and 1013mb (sea level -45 celsius)",\n		"const float pn = 0.035;	// depolatization factor for standard air",\n\n		"// wavelength of used primaries, according to preetham",\n		"const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);",\n\n		"// mie stuff",\n		"// K coefficient for the primaries",\n		"const vec3 K = vec3(0.686, 0.678, 0.666);",\n		"const float v = 4.0;",\n\n		"// optical length at zenith for molecules",\n		"const float rayleighZenithLength = 8.4E3;",\n		"const float mieZenithLength = 1.25E3;",\n		"const vec3 up = vec3(0.0, 1.0, 0.0);",\n\n		"const float EE = 1000.0;",\n		"const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",\n		"// 66 arc seconds -> degrees, and the cosine of that",\n\n		"// earth shadow hack",\n		"const float cutoffAngle = pi/1.95;",\n		"const float steepness = 1.5;",\n\n\n		"vec3 totalRayleigh(vec3 lambda)",\n		"{",\n			"return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));",\n		"}",\n\n		// see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\n		"// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE",\n		"vec3 simplifiedRayleigh()",\n		"{",\n			"return 0.0005 / vec3(94, 40, 18);",\n			// return 0.00054532832366 / (3.0 * 2.545E25 * pow(vec3(680E-9, 550E-9, 450E-9), vec3(4.0)) * 6.245);\n		"}",\n\n		"float rayleighPhase(float cosTheta)",\n		"{	 ",\n			"return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));",\n		"//	return (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));",\n		"//	return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));",\n		"}",\n\n		"vec3 totalMie(vec3 lambda, vec3 K, float T)",\n		"{",\n			"float c = (0.2 * T ) * 10E-18;",\n			"return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;",\n		"}",\n\n		"float hgPhase(float cosTheta, float g)",\n		"{",\n			"return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));",\n		"}",\n\n		"float sunIntensity(float zenithAngleCos)",\n		"{",\n			"return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));",\n		"}",\n\n		"// float logLuminance(vec3 c)",\n		"// {",\n		"// 	return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);",\n		"// }",\n\n		"// Filmic ToneMapping http://filmicgames.com/archives/75",\n		"float A = 0.15;",\n		"float B = 0.50;",\n		"float C = 0.10;",\n		"float D = 0.20;",\n		"float E = 0.02;",\n		"float F = 0.30;",\n		"float W = 1000.0;",\n\n		"vec3 Uncharted2Tonemap(vec3 x)",\n		"{",\n		   "return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;",\n		"}",\n\n\n		"void main() ",\n		"{",\n			"float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);",\n\n			"// luminance =  1.0 ;// vWorldPosition.y / 450000. + 0.5; //sunPosition.y / 450000. * 1. + 0.5;",\n\n			 "// gl_FragColor = vec4(sunfade, sunfade, sunfade, 1.0);",\n\n			"reileighCoefficient = reileighCoefficient - (1.0* (1.0-sunfade));",\n\n			"float sunE = sunIntensity(dot(sunDirection, up));",\n\n			"// extinction (absorbtion + out scattering) ",\n			"// rayleigh coefficients",\n\n			// "vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;",\n			"vec3 betaR = simplifiedRayleigh() * reileighCoefficient;",\n\n			"// mie coefficients",\n			"vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;",\n\n			"// optical length",\n			"// cutoff angle at 90 to avoid singularity in next formula.",\n			"float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));",\n			"float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));",\n			"float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));",\n\n\n\n			"// combined extinction factor	",\n			"vec3 Fex = exp(-(betaR * sR + betaM * sM));",\n\n			"// in scattering",\n			"float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirection);",\n\n			"float rPhase = rayleighPhase(cosTheta*0.5+0.5);",\n			"vec3 betaRTheta = betaR * rPhase;",\n\n			"float mPhase = hgPhase(cosTheta, mieDirectionalG);",\n			"vec3 betaMTheta = betaM * mPhase;",\n\n\n			"vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));",\n			"Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));",\n\n			"//nightsky",\n			"vec3 direction = normalize(vWorldPosition - cameraPos);",\n			"float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]",\n			"float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]",\n			"vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);",\n			"// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;",\n			"vec3 L0 = vec3(0.1) * Fex;",\n\n			"// composition + solar disc",\n			"//if (cosTheta > sunAngularDiameterCos)",\n			"float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);",\n			"// if (normalize(vWorldPosition - cameraPos).y>0.0)",\n			"L0 += (sunE * 19000.0 * Fex)*sundisk;",\n\n\n			"vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));",\n\n			"vec3 texColor = (Lin+L0);   ",\n			"texColor *= 0.04 ;",\n			"texColor += vec3(0.0,0.001,0.0025)*0.3;",\n\n			"float g_fMaxLuminance = 1.0;",\n			"float fLumScaled = 0.1 / luminance;     ",\n			"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); ",\n\n			"float ExposureBias = fLumCompressed;",\n\n			"vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);",\n			"vec3 color = curr*whiteScale;",\n\n			"vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));",\n\n\n			"gl_FragColor.rgb = retColor;",\n\n			"gl_FragColor.a = 1.0;",\n		"}",\n\n	].join("\\n")\n\n};\n\nTHREE.Sky = function () {\n\n	var skyShader = THREE.ShaderLib[ "sky" ];\n	var skyUniforms = THREE.UniformsUtils.clone( skyShader.uniforms );\n\n	var skyMat = new THREE.ShaderMaterial( {\n		fragmentShader: skyShader.fragmentShader,\n		vertexShader: skyShader.vertexShader,\n		uniforms: skyUniforms,\n		side: THREE.BackSide\n	} );\n\n	var skyGeo = new THREE.SphereGeometry( 450000, 32, 15 );\n	var skyMesh = new THREE.Mesh( skyGeo, skyMat );\n\n\n	// Expose variables\n	this.mesh = skyMesh;\n	this.uniforms = skyUniforms;\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/SkyShader/index.js\n ** module id = 75\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/SkyShader/index.js?./~/imports-loader?THREE=three')},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	__webpack_require__(77);\n\n	return function sound(parent, options) {\n		var obj,\n			src,\n			listener,\n			scene = parent;\n\n		if (typeof options === 'string' || Array.isArray(options)) {\n			src = options;\n		} else if (options) {\n			src = options.src;\n		}\n\n		while (!(scene instanceof THREE.Scene) && scene.parent) {\n			scene = scene.parent;\n		}\n\n		listener = scene.getObjectByName('audio-listener');\n		obj = new THREE.Audio(listener);\n		// obj.setLoop(true);\n		obj.load(src);\n\n		this.start = obj.start.bind(obj);\n		this.volume = obj.volume.bind(obj);\n\n		parent.add(obj);\n\n		return obj;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/sound.js\n ** module id = 76\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/sound.js?")},function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar THREE = __webpack_require__(9);\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n	THREE.Object3D.call( this );\n\n	this.type = 'Audio';\n	this.started = false;\n\n	if (listener.context) {\n\n		this.context = listener.context;\n		// this.source = this.context.createBufferSource();\n\n		this.gain = this.context.createGain();\n		this.gain.connect( listener.input );\n\n		this.panner = this.context.createPanner();\n		this.panner.connect( this.gain );\n\n	} else {\n\n		this.source = new Audio();\n\n	}\n};\n\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Audio.prototype.load = function ( sources ) {\n	//todo: support multiple sources for different audio formats\n\n	var scope = this;\n	var file;\n	var i;\n	var match;\n	var element = this.source instanceof window.HTMLAudioElement ? this.source : new Audio();\n\n	if (typeof sources === 'string') {\n		sources = [sources];\n	}\n\n	for (i = 0; i < sources.length; i++) {\n		file = sources[i];\n		match = /\\.([a-z0-9]+)$/i.exec(file);\n		if (match && element.canPlayType('audio/' + match[1])) {\n			break;\n		}\n	}\n\n	if (this.context) {\n		var request = new XMLHttpRequest();\n		request.open( 'GET', file, true );\n		request.responseType = 'arraybuffer';\n		request.onload = function ( e ) {\n			console.log('audio buffer loaded. decoding...', e );\n			scope.context.decodeAudioData( this.response, function ( buffer ) {\n\n				scope.buffer = buffer;\n				if (scope.started) {\n					scope.start();\n				}\n\n			}, function onFailure(e) {\n				console.log('Decoding the audio buffer failed', e);\n			} );\n\n		};\n\n		request.onerror = function ( e ) {\n			console.log('error', e);\n		};\n\n		request.send();\n\n	} else {\n\n		this.source.src = file;\n		this.source.play();\n\n	}\n\n	return this;\n};\n\nTHREE.Audio.prototype.stop = function ( value ) {\n\n	if (this.context) {\n		this.source.stop();\n		this.source.disconnect( this.panner );\n		this.source = null;\n	} else {\n		this.source.pause();\n		this.source.currentTime = 0;\n	}\n	this.started = false;\n};\n\nTHREE.Audio.prototype.start = function ( value ) {\n\n	this.started = true;\n	if (this.context) {\n		if (this.source) {\n			this.source.disconnect( this.panner );\n		}\n\n		if (this.buffer) {\n			this.source = this.context.createBufferSource();\n			this.source.buffer = this.buffer;\n			this.source.connect( this.panner );\n			this.source.start( 0 );\n		}\n	} else {\n		this.source.currentTime = 0;\n		this.source.play();\n	}\n\n};\n\nTHREE.Audio.prototype.setLoop = function ( value ) {\n\n	this.source.loop = value;\n\n};\n\nTHREE.Audio.prototype.setRefDistance = function ( value ) {\n\n	if ( this.panner ) {\n\n		this.panner.refDistance = value;\n\n	}\n\n};\n\nTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\n\n	if ( this.panner ) {\n\n		this.panner.rolloffFactor = value;\n\n	}\n\n};\n\nTHREE.Audio.prototype.volume = function ( volume, time ) {\n\n	if ( this.gain ) {\n\n		if ( volume !== undefined ) {\n			this.gain.gain.linearRampToValueAtTime( volume, this.context.currentTime + (time || 0));\n		}\n\n		return this.gain.gain.value;\n	}\n\n	if ( volume !== undefined ) {\n		this.source.volume = volume;\n	}\n\n	return this.source.volume;\n};\n\nTHREE.Audio.prototype.updateMatrixWorld = ( function () {\n\n	var position = new THREE.Vector3();\n\n	return function ( force ) {\n\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n		position.setFromMatrixPosition( this.matrixWorld );\n\n		if (this.panner) {\n\n			this.panner.setPosition( position.x, position.y, position.z );\n\n		}\n\n	};\n\n} )();\n\n// File:src/extras/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n	var AudioContext = window.AudioContext || window.webkitAudioContext;\n\n	THREE.Object3D.call( this );\n\n	this.type = 'AudioListener';\n\n	if (AudioContext) {\n		this.context = new AudioContext();\n		this.input = this.context.createGain();\n\n		this.input.connect( this.context.destination );\n	}\n};\n\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.AudioListener.prototype.volume = function (val) {\n	if (this.input) {\n		val = val !== undefined && parseFloat(val);\n		if (!isNaN(val)) {\n			this.input.gain.value = val;\n		}\n\n		return this.input.gain.value;\n	}\n};\n\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\n\n	var position = new THREE.Vector3();\n	var quaternion = new THREE.Quaternion();\n	var scale = new THREE.Vector3();\n\n	var orientation = new THREE.Vector3();\n\n	return function ( force ) {\n\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n		var listener;\n\n		if (this.context) {\n			listener = this.context.listener;\n\n			this.matrixWorld.decompose( position, quaternion, scale );\n\n			orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\n\n			listener.setPosition( position.x, position.y, position.z );\n			listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );\n\n		}\n	};\n\n} ());\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./src/lib/ThreeAudio.js\n ** module id = 77\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/lib/ThreeAudio.js?./~/imports-loader?THREE=three")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	return function box(parent, options) {\n		var geometry,\n			mesh;\n\n		geometry = new THREE.SphereGeometry(\n			options.radius === undefined ? 0.5 : options.radius,\n			options.widthSegments === undefined ? 16 : options.widthSegments,\n			options.heightSegments === undefined ? 12 : options.heightSegments,\n			options.phiStart,\n			options.phiLength,\n			options.thetaStart,\n			options.thetaLength\n		);\n		mesh = new THREE.Mesh(geometry, materials.standard());\n		mesh.name = 'sphere';\n\n		parent.add(mesh);\n\n		return mesh;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/sphere.js\n ** module id = 78\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/sphere.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var THREE = __webpack_require__(9),\n		fontSizeRegex = /(\\d+)px/i,\n		newLineRegex = /[\\n\\r]/,\n		spaceRegex = /[\\t ]/,\n		log2 = Math.log(2),\n		geometry = new THREE.PlaneBufferGeometry(1, 1);\n\n	return function text(parent, options) {\n		var self = this,\n			material,\n			canvas,\n			ctx,\n			mesh,\n			container,\n			src,\n			textWidth = 0,\n			textHeight = 0,\n			props = {\n				text: '',\n				font: '80px sans-serif',\n				textAlign: 'center',\n				textBaseline: '',\n				direction: '',\n				fillStyle: 'white',\n				resolution: 256, //pixels per meter\n				wrap: 5 //in meters\n			},\n			tex;\n\n		function nextPowerOfTwo(n) {\n			return Math.pow(2, Math.ceil(Math.log(n) / log2));\n		}\n\n		function Line(word) {\n			this.spaceWidth = ctx.measureText(' ').width;\n			this.totalWidth = 0;\n			this.wordsWidth = 0;\n			this.words = [];\n			this.wrap = false;\n			if (word) {\n				this.add(word);\n			}\n		}\n\n		Line.prototype.text = function () {\n			return this.words.join(' ');\n		};\n\n		Line.prototype.add = function(word) {\n			var wordWidth;\n			if (this.words.length) {\n				this.totalWidth += this.spaceWidth;\n			}\n			this.words.push(word);\n			wordWidth = Line.measure(word);\n			this.totalWidth += wordWidth;\n			this.wordsWidth += wordWidth;\n		};\n\n		Line.prototype.measure = function(word) {\n			var width = this.totalWidth;\n			if (word) {\n				width += Line.measure(word);\n				if (this.words.length) {\n					width += this.spaceWidth;\n				}\n			}\n			return width;\n		};\n\n		Line.measure = function(word) {\n			return ctx.measureText(word).width;\n		};\n\n		function update() {\n			//text stuffs\n			var text,\n				word = '',\n				letter,\n				isSpace,\n				line,\n				lines = [],\n				parse,\n\n				//layout\n				direction = getComputedStyle(document.body).direction,\n				inherit,\n				resolution = parseFloat(props.resolution) || 256,\n				wrap,\n				wrapped = false,\n				fontSize,\n				padding,\n\n				//measurements\n				lineHeight,\n				i, start, y, measure,\n				width,\n				height = 0;\n\n			wrap = parseFloat(props.wrap);\n			if (isNaN(wrap) || wrap < 0) {\n				wrap = 5;\n			}\n			width = resolution * wrap;\n\n			ctx.font = props.font;\n			parse = fontSizeRegex.exec(ctx.font);\n			fontSize = parseFloat(parse && parse[1]) || 50;\n\n			lineHeight = fontSize * 1.5;\n\n			line = new Line();\n\n			text = props.text === 0 ? '0' : String(props.text || '');\n			if (wrap) {\n				text = text.trim() + ' ';\n				for (i = 0; i < text.length; i++) {\n					letter = text.charAt(i);\n					if (newLineRegex.test(letter)) {\n						line.add(word);\n						lines.push(line);\n						word = '';\n						line = new Line();\n					} else if (spaceRegex.test(letter)) {\n						measure = line.measure(word);\n						if (measure < width) {\n							if (line) {\n								line.add(word);\n							} else {\n								line = new Line(word);\n							}\n						} else if (!line && Line.measure(word) >= width) {\n							//one very long word\n							lines.push(new Line(word));\n							word = '';\n							line = new Line();\n							wrapped = true;\n						} else {\n							line.wrap = true;\n							lines.push(line);\n							line = new Line(word);\n							wrapped = true;\n						}\n						word = '';\n					} else {\n						word += letter;\n					}\n				}\n				if (line) {\n					lines.push(line);\n				}\n			} else {\n				lines.push(new Line(text));\n			}\n\n			if (!width || !wrapped) {\n				width = lines.reduce(function (previous, line) {\n					return Math.max(previous, line.totalWidth);\n				}, 0);\n			}\n			width = Math.min(width, 2048);\n\n			height = lines.length * lineHeight;\n\n			if (options && options.mipmap === false) {\n				canvas.width = width;\n				canvas.height = height;\n			} else {\n				canvas.width = nextPowerOfTwo(width);\n				canvas.height = nextPowerOfTwo(height);\n			}\n\n			mesh.scale.set(canvas.width / resolution, canvas.height / resolution, 1);\n\n			//debug\n			// ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';\n			// ctx.fillRect(0, 0, canvas.width, canvas.height);\n			// document.body.appendChild(canvas);\n			// canvas.style.cssText = 'position: absolute; width: auto !important; height: auto !important; max-width: 80%';\n\n			/*\n			set all these properties again because they get reset\n			when you resize the canvas\n			*/\n			ctx.font = props.font;\n			ctx.textAlign = props.textAlign;\n			ctx.textBaseline = props.textBaseline;\n			ctx.direction = props.direction;\n			ctx.fillStyle = props.fillStyle;\n			//todo: add maxWidth?\n\n			padding = (canvas.width - width) / 2;\n			y = (canvas.height - height) / 2 + lineHeight / 2;\n\n			inherit = (ctx.direction === '' || ctx.direction === 'inherit');\n			if (ctx.textAlign === 'center') {\n				start = canvas.width / 2;\n			} else if (ctx.textAlign === 'right' ||\n				ctx.textAlign === 'end' && (ctx.direction === 'ltr' || inherit && direction === 'ltr') ||\n				ctx.textAlign === 'start' && (ctx.direction === 'rtl' || inherit && direction === 'rtl')) {\n\n				start = canvas.width - padding;\n			} else {\n				start = padding;\n			}\n\n			lines.forEach(function (line) {\n				var x,\n					space;\n				if (props.textAlign === 'justify' && line.wrap && line.words.length > 1) {\n					x = start;\n					space = (width - line.wordsWidth) / (line.words.length - 1);\n					line.words.forEach(function (word) {\n						ctx.fillText(word, x, y);\n						x += space + Line.measure(word);\n					});\n				} else {\n					ctx.fillText(line.text(), start, y);\n				}\n				y += lineHeight;\n			});\n\n			textWidth = width / resolution;\n			textHeight = lines.length * lineHeight / resolution;\n\n			tex.needsUpdate = true;\n\n			mesh.name = text.trim();\n		}\n\n		canvas = document.createElement('canvas');\n		ctx = canvas.getContext('2d');\n		tex = new THREE.Texture(canvas);\n\n		if (canvas.width === nextPowerOfTwo(canvas.width) &&\n			canvas.height === nextPowerOfTwo(canvas.height)) {\n\n			tex.minFilter = THREE.LinearMipMapLinearFilter;\n			tex.generateMipmaps = true;\n		}\n\n		material = new THREE.MeshBasicMaterial({\n			side: THREE.DoubleSide,\n			transparent: true,\n			map: tex\n		});\n\n		mesh = new THREE.Mesh(geometry, material);\n\n		container = new THREE.Object3D();\n		container.name = 'text';\n		container.add(mesh);\n		parent.add(container);\n\n		if (typeof options === 'string') {\n			props.text = options;\n		} else if (options) {\n			Object.keys(props).forEach(function (key) {\n				props[key] = options[key] || props[key];\n			});\n		}\n		update();\n\n		Object.keys(props).forEach(function (key) {\n			Object.defineProperty(self, key, {\n				get: function () {\n					return props[key];\n				},\n				set: function (val) {\n					props[key] = val;\n					update();\n				}\n			});\n		});\n\n		Object.defineProperty(self, 'width', {\n			get: function () {\n				return textWidth;\n			}\n		});\n\n		Object.defineProperty(self, 'height', {\n			get: function () {\n				return textHeight;\n			}\n		});\n\n		this.material = material;\n\n		return container;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/text.js\n ** module id = 79\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/text.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var materials = __webpack_require__(8),\n		THREE = __webpack_require__(9);\n\n	return function torus(parent, options) {\n		var geometry,\n			mesh;\n\n		geometry = new THREE.TorusGeometry(\n			options.radius === undefined ? 0.5 : options.radius,\n			options.tube === undefined ? 0.125 : options.tube,\n			options.radialSegments === undefined ? 12 : options.radialSegments,\n			options.tubularSegments === undefined ? 16 : options.tubularSegments,\n			options.arc\n		);\n		mesh = new THREE.Mesh(geometry, materials.standard());\n		mesh.name = 'torus';\n\n		parent.add(mesh);\n\n		return mesh;\n	};\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/torus.js\n ** module id = 80\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/torus.js?")},function(module,exports,__webpack_require__){eval("module.exports = (function () {\n	'use strict';\n\n	var THREE = __webpack_require__(9),\n		urlRegex = __webpack_require__(29),\n		extRegex = /\\.(webm|ogg|ogv|m4v|mp4|mov)/i,\n		video;\n\n	video = function (parent, options) {\n		var geometry,\n			material,\n			mesh,\n			vid,\n			tex,\n			aspectRatio = 1,\n			playing = false,\n			self = this;\n\n		function isPowerOfTwo(num) {\n			return num > 0 && (num & (num-1)) === 0; // jshint ignore:line\n		}\n\n		function loadedMetadata() {\n			//todo: don't do any of this if object has been deleted\n\n			var newAspectRatio = vid.videoWidth / vid.videoHeight;\n			if (!options || !options.sphere) {\n				geometry.applyMatrix(new THREE.Matrix4().makeScale(1, aspectRatio / newAspectRatio, 1));\n			}\n			aspectRatio = newAspectRatio;\n\n			if (vid.videoWidth === vid.videoHeight &&\n				isPowerOfTwo(vid.videoWidth) && isPowerOfTwo(vid.videoHeight)) {\n\n				tex.minFilter = THREE.LinearMipMapLinearFilter;\n				tex.generateMipmaps = true;\n			} else {\n				tex.minFilter = THREE.LinearFilter;\n				tex.generateMipmaps = false;\n			}\n\n			material.map = tex;\n			material.visible = true;\n\n			if (playing) {\n				vid.play();\n			}\n		}\n\n		function setSource(sources) {\n			sources.forEach(function (src) {\n				var parse,\n					ext,\n					source;\n\n				if (!src) {\n					return;\n				}\n\n				parse = urlRegex.exec(src);\n				if (parse &&\n					(parse[1] && parse[1] !== window.location.hostΩ ||\n					parse[2] && parse[2] !== window.location.port)) {\n\n					if (vid.crossOrigin !== undefined) {\n						vid.crossOrigin = 'anonymous';\n					} else {\n						console.warn('Browser does not support cross-origin video');\n						return;\n					}\n				}\n				source = document.createElement('source');\n				source.src = src;\n\n				ext = extRegex.exec(src);\n				if (!ext || vid.canPlayType('video/' + ext[1])) {\n					vid.appendChild(source);\n				}\n			});\n		}\n\n		/*\n		 Pause the video when this browser tab is in the background or minimized.\n		 Resume when it comes back in focus, but only if the user didn't pause manually.\n		 */\n		function visibilityChange() {\n			if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n				vid.pause();\n			} else if (playing) {\n				vid.play();\n			}\n		}\n\n		vid = document.createElement('video');\n		vid.loop = true;\n		vid.addEventListener('loadedmetadata', loadedMetadata, false);\n\n		if (Array.isArray(options)) {\n			setSource(options);\n		} if (typeof options === 'string') {\n			setSource([options]);\n		} else if (typeof options.src === 'string') {\n			setSource([options.src]);\n		} else if (Array.isArray(options.src)) {\n			setSource(options.src);\n		}\n\n		vid.load();\n\n		tex = new THREE.VideoTexture(vid, THREE.UVMapping);\n		tex.format = THREE.RGBFormat;\n\n		if (options && options.sphere) {\n			geometry = new THREE.SphereGeometry(\n				994, //radius\n				60, //widthSegments\n				60, //heightSegments\n				(parseFloat(options.phiStart) || 0) * Math.PI * 2,\n				(parseFloat(options.phiLength) || 1) * Math.PI * 2,\n				(parseFloat(options.thetaStart) || 0) * Math.PI,\n				(parseFloat(options.thetaLength) || 1) * Math.PI\n			);\n			geometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n			geometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n		} else {\n			geometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n		}\n\n		var uniforms = {\n			OpticalCenter: {\n				type: 'v2',\n				value: new THREE.Vector2( 0.4939155, 0.5298627 )\n			},\n			FCoff: {\n				type: 'v2',\n				value: new THREE.Vector2( 0.5459919,0.97142231 )\n			},\n			KCoff: {\n				type: 'v4',\n				value: new THREE.Vector4( -0.26265967,0.11121539,-0.00042497579,-0.00015385781 )\n			},\n			texture1 : { type : 't', value: tex },\n			edgeColor: {\n				type: 'v4',\n				value: new THREE.Vector4(0, 0, 0, 0)\n			},\n			edge: {\n				type: 'i',\n				value: true\n			}\n		};\n\n		material = new THREE.ShaderMaterial({\n			uniforms:uniforms,\n			// シェーダーを割り当てる\n			fragmentShader: window.fs,\n			vertexShader: window.vs\n		});\n\n		/*\n		 material = new THREE.MeshBasicMaterial({\n		 side: THREE.DoubleSide,\n		 map: tex,\n		 visible: false\n		 });\n		 */\n\n		mesh = new THREE.Mesh(geometry, material);\n\n		if (options && options.stereo) {\n			if (options.stereo === 'vertical') {\n				tex.repeat.y = 0.5;\n			} else {\n				tex.repeat.x = 0.5;\n			}\n			mesh.userData.stereo = options.stereo;\n		}\n\n		if (vid.readyState) {\n			loadedMetadata();\n		}\n\n		this.play = function play() {\n			playing = true;\n			vid.play();\n			return this;\n		};\n\n		this.pause = function pause() {\n			playing = false;\n			vid.pause();\n			return this;\n		};\n\n		this.canPlayType = video.canPlayType;\n\n		Object.defineProperty(this, 'width', {\n			get: function () {\n				return vid.videoWidth;\n			}\n		});\n\n		Object.defineProperty(this, 'height', {\n			get: function () {\n				return vid.videoHeight;\n			}\n		});\n\n		Object.defineProperty(this, 'paused', {\n			get: function () {\n				return !playing;\n			}\n		});\n\n		Object.defineProperty(this, 'volume', {\n			get: function () {\n				return vid.volume;\n			},\n			set: function (vol) {\n				vid.volume = vol;\n			}\n		});\n\n		Object.defineProperty(this, 'muted', {\n			get: function () {\n				return vid.muted;\n			},\n			set: function (muted) {\n				vid.muted = muted;\n			}\n		});\n\n		Object.defineProperty(this, 'duration', {\n			get: function () {\n				return vid.duration || 0;\n			}\n		});\n\n		Object.defineProperty(this, 'currentTime', {\n			get: function () {\n				return vid.currentTime;\n			},\n			set: function (currentTime) {\n				if (vid.readyState && currentTime < vid.duration && currentTime >= 0) {\n					vid.currentTime = currentTime;\n				}\n			}\n		});\n\n		[\n			'loadedmetadata',\n			'play',\n			'pause',\n			'playing',\n			'progress'\n		].forEach(function registerMediaEvent(event) {\n				vid.addEventListener(event, self.emit.bind(self, event));\n			});\n\n		//sometimes video fails to play because it's too big. remove it and try again\n		vid.addEventListener('error', function (evt) {\n			if (vid.error.code === window.MediaError.MEDIA_ERR_DECODE && vid.childNodes.length > 1) {\n				material.visible = false;\n				vid.removeChild(vid.firstChild);\n				vid.load();\n			}\n\n			self.emit(event, evt);\n		}, true);\n\n		this.element = vid;\n\n		window.addEventListener('touchstart', function touchStart() {\n			if (playing) {\n				vid.play();\n			} else {\n				vid.load();\n			}\n			window.removeEventListener('touchstart', touchStart, true);\n		}, true);\n\n		//pause when window is hidden\n		document.addEventListener('visibilitychange', visibilityChange);\n		document.addEventListener('mozvisibilitychange', visibilityChange);\n		document.addEventListener('msvisibilitychange', visibilityChange);\n		document.addEventListener('webkitvisibilitychange', visibilityChange);\n\n		mesh.name = 'video';\n		this.raycastable = !(options && options.sphere);\n		parent.add(mesh);\n\n		return mesh;\n	};\n\n	video.canPlayType = function canPlayType(type) {\n		var element = document.createElement('video');\n		return element.canPlayType(type);\n	};\n\n	return video;\n}());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/video.js\n ** module id = 81\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/objects/video.js?");
},function(module,exports){eval('module.exports = "<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"8\\" height=\\"8\\" viewBox=\\"0 0 8 8\\">\\n  <path d=\\"M0 0v4l1.5-1.5 1.5 1.5 1-1-1.5-1.5 1.5-1.5h-4zm5 4l-1 1 1.5 1.5-1.5 1.5h4v-4l-1.5 1.5-1.5-1.5z\\" />\\n</svg>"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/fullscreen-enter.svg\n ** module id = 82\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/open-iconic/svg/fullscreen-enter.svg?./~/raw-loader')},function(module,exports){eval('module.exports = "<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"8\\" height=\\"8\\" viewBox=\\"0 0 8 8\\">\\n  <path d=\\"M1 0l-1 1 1.5 1.5-1.5 1.5h4v-4l-1.5 1.5-1.5-1.5zm3 4v4l1.5-1.5 1.5 1.5 1-1-1.5-1.5 1.5-1.5h-4z\\" />\\n</svg>"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/fullscreen-exit.svg\n ** module id = 83\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/open-iconic/svg/fullscreen-exit.svg?./~/raw-loader')},function(module,exports){eval('module.exports = "<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"8\\" height=\\"8\\" viewBox=\\"0 0 8 8\\">\\n  <path d=\\"M4.03 0c-2.53 0-4.03 3-4.03 3s1.5 3 4.03 3c2.47 0 3.97-3 3.97-3s-1.5-3-3.97-3zm-.03 1c1.11 0 2 .9 2 2 0 1.11-.89 2-2 2-1.1 0-2-.89-2-2 0-1.1.9-2 2-2zm0 1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.04-.19-.06-.28-.08.16-.24.28-.44.28-.28 0-.5-.22-.5-.5 0-.2.12-.36.28-.44-.09-.03-.18-.06-.28-.06z\\"\\n  transform=\\"translate(0 1)\\" />\\n</svg>"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/eye.svg\n ** module id = 84\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/open-iconic/svg/eye.svg?./~/raw-loader')},function(module,exports){eval('module.exports = "<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"8\\" height=\\"8\\" viewBox=\\"0 0 8 8\\">\\n  <path d=\\"M4 0c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 1c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm2 1l-3 1-1 3 3-1 1-3zm-2 1.5c.28 0 .5.22.5.5s-.22.5-.5.5-.5-.22-.5-.5.22-.5.5-.5z\\" />\\n</svg>"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/compass.svg\n ** module id = 85\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/open-iconic/svg/compass.svg?./~/raw-loader')}]);var __extends=this&&this.__extends||function(n,r){function e(){this.constructor=n}for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t]);n.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)},View;!function(n){var r=function(n){function r(){n.call(this),this.OnChangePeer="onChangePeer",this.OnKeyPress="onKeyPress",this._startListening()}return __extends(r,n),r.prototype._startListening=function(){var n=this;$(document).keydown(function(r){return r.keyCode==="U".charCodeAt(0)?n.emit(n.OnChangePeer):r.keyCode===" ".charCodeAt(0)||r.keyCode==="S".charCodeAt(0),!0})},r}(EventEmitter2);n.KeyboardListener=r}(View||(View={}));var View;!function(n){var r=function(){function n(){var n=this;this._currentNeighbor=null,this.OnKeyPress="onKeyPress",this.setNeighbor=function(r){n._currentNeighbor&&n._currentNeighbor.removeListener(n._currentNeighbor.OnMediaReceivedEvent,n._displayVideo),n._currentNeighbor=r,r.on(r.OnMediaReceivedEvent,n._displayVideo)},this._displayVideo=function(n,r){if(1===n){var e=$("#leftVideo").get(0);e.src=window.URL.createObjectURL(r)}else{var t=$("#rightVideo").get(0);t.src=window.URL.createObjectURL(r)}},this._displayHMD=function(n,r){window.setTimeout(function(){var n=r.getVideoTracks(),e=new webkitMediaStream,t=new webkitMediaStream;e.addTrack(n[0]),t.addTrack(n[1]);var i=VR.video([window.URL.createObjectURL(t)],!1);i.play();var a=VR.lvideo([window.URL.createObjectURL(e)],!0);console.log(a),a.play()},2e3,!0)}}return n}();n.DisplayVideo=r}(View||(View={}));var __extends=this&&this.__extends||function(n,r){function e(){this.constructor=n}for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t]);n.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)},Model;!function(n){var r=function(n){function r(){n.call(this),this.cameraReadyEvent="onCameraReady",this.cameraStreamEvent="onCameraStream",navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia}return __extends(r,n),r.prototype.getCamera=function(){var n=this;MediaStreamTrack.getSources(function(r){n.emit(n.cameraReadyEvent,r)})},r.prototype.getMinimulStream=function(n){navigator.getUserMedia({audio:!0,video:!0},function(r){n(r)},function(n){console.log(n)})},r.prototype.createMultiTrackStream=function(n){$("#comment").get(0).innerHTML="create multi track stream<br/>",navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia;var r=640,e=480;navigator.getUserMedia({audio:!0,video:{mandatory:{frameRate:60,width:r,height:e}}},function(t){$("#comment").get(0).innerHTML+="<h1>success left stream</h1><br/>",navigator.getUserMedia({audio:!0,video:{mandatory:{minFrameRate:60,maxFrameRate:60,maxWidth:r,minWidth:r,maxHeight:e,minHeight:e}}},function(r){$("#comment").get(0).innerHTML+="<h1>success right stream</h1><br/>";var e=new webkitMediaStream;e.addTrack(t.getVideoTracks()[0]),e.addTrack(r.getVideoTracks()[0]),n(e)},function(n){console.log(n),$("#comment").get(0).innerHTML+="status 2 <br/>",$("#comment").get(0).innerHTML+="<br/>"+n.constraintName,$("#comment").get(0).innerHTML+="<br/>"+n.name,$("#comment").get(0).innerHTML+="<br/>"+JSON.stringify(n),$("#comment").get(0).innerHTML+="<br/>だめかー"})},function(n){console.log(n),$("#comment").get(0).innerHTML+="status 1 <br/>",$("#comment").get(0).innerHTML+="<br/>"+n.constraintName,$("#comment").get(0).innerHTML+="<br/>"+n.name,$("#comment").get(0).innerHTML+="<br/>"+JSON.stringify(n),$("#comment").get(0).innerHTML+="<br/>だめかー"})},r}(EventEmitter2);n.CameraManager=r}(Model||(Model={}));var __extends=this&&this.__extends||function(n,r){function e(){this.constructor=n}for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t]);n.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)},Model;!function(n){!function(n){n[n.video=1]="video",n[n.data=2]="data"}(n.NeighborTypeEnum||(n.NeighborTypeEnum={}));var r=n.NeighborTypeEnum,e=function(n){function e(r){n.call(this),this._peerID=r,this._dataChannel=null,this.connected=!1,this.OnDataReceivedEvent="DataFromNeighbor"}return __extends(e,n),e.prototype.peerID=function(){return this._peerID},e.prototype.type=function(){return r.data},e.prototype.send=function(n){this.connected&&this._dataChannel&&this._dataChannel.send(n)},e.prototype.setChannel=function(n){var r=this;n&&(this._dataChannel=n,this.connected=!1,n.on("open",function(){r.connected=!0}),n.on("close",function(){r._dataChannel=null,r.connected=!1}),n.on("error",function(n){r._dataChannel=null,r.connected=!1}),n.on("data",function(n){r.emit(r.OnDataReceivedEvent,n)}))},e.prototype.close=function(){this._dataChannel.close(),this._dataChannel=null,this.connected=!1},e}(EventEmitter2);n.DataNeighbor=e;var t=function(n){function e(r){n.call(this),this._peerID=r,this._mediaConnection=null,this._streamCount=0,this.connected=!1,this.OnMediaReceivedEvent="MediaFromNeighbor"}return __extends(e,n),e.prototype.peerID=function(){return this._peerID},e.prototype.type=function(){return r.video},e.prototype.setChannel=function(n){var r=this;this._mediaConnection=n,this.connected=!1,n.on("stream",function(n){r._streamCount++,r._mediaConnection=n,r.connected=!0,r.emit(r.OnMediaReceivedEvent,r._streamCount,n)}),n.on("close",function(){r._mediaConnection=null,r.connected=!1}),n.on("error",function(n){r._mediaConnection=null,r.connected=!1})},e.prototype.send=function(n){},e.prototype.close=function(){this._mediaConnection.close(),this._mediaConnection=null,this.connected=!1},e}(EventEmitter2);n.VideoNeighbor=t;var i=function(){function n(){}return n.createNeighbor=function(n,i){switch(i){case r.video:return new t(n);case r.data:return new e(n)}},n}();n.NeighborFactory=i}(Model||(Model={}));var __extends=this&&this.__extends||function(n,r){function e(){this.constructor=n}for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t]);n.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)},Model;!function(n){var r=function(r){function e(e,t){var i=this;r.call(this),this._peer=e,this._targetNeighbors=t,this.OnMediaLinkEstablished="onMediaLinkEstablished",this.OnMediaReceivedEvent="onMeidaReceived",this.OnPeerOpendEvent="onPeerOpend",this._connectedNeighbors=[],this._openedState=function(){i._peer.on("disconnected",i._timeoutState),i._peer.on("error",function(n){}),i._peer.on("connection",i._onRecvConnect),i._peer.on("call",i._onRecvCall),i._targetNeighbors.on(i._targetNeighbors.OnNeedEstablishP2P,i._onNeedsEstablish),i.emit(i.OnPeerOpendEvent)},this._onNeedsEstablish=function(r){switch(console.log("onneedconnect============"),r.type()){case n.NeighborTypeEnum.video:i._tryCall(r);break;case n.NeighborTypeEnum.data:i._tryConnect(r)}},this._timeoutState=function(){},this._onRecvCall=function(r){r.answer(window.localStream);var e=r.peer,t=_.find(i._connectedNeighbors,function(r){return r.peerID()===e&&r.type()===n.NeighborTypeEnum.video});t?r.close():(t=n.NeighborFactory.createNeighbor(e,n.NeighborTypeEnum.video),i._connectedNeighbors.push(t),t.setChannel(r),i.emit(i.OnMediaLinkEstablished,t))},this._onRecvConnect=function(r){console.log("recvconnect==============");var e=r.peer,t=_.find(i._connectedNeighbors,function(r){return r.peerID()===e&&r.type()===n.NeighborTypeEnum.data});t?r.close():(t=n.NeighborFactory.createNeighbor(e,n.NeighborTypeEnum.data),i._connectedNeighbors.push(t),t.setChannel(r))},e.on("open",this._openedState)}return __extends(e,r),e.prototype._tryCall=function(n){var r=this._peer.call(n.peerID(),window.localStream);n.setChannel(r),this._connectedNeighbors.push(n),this.emit(this.OnMediaLinkEstablished,n)},e.prototype._tryConnect=function(n){console.log("tryconnect==========");var r=this._peer.connect(n.peerID(),{label:"json",serialization:"none",reliable:!1});n.setChannel(r),this._connectedNeighbors.push(n)},e}(EventEmitter2);n.PeerJsManager=r}(Model||(Model={}));var __extends=this&&this.__extends||function(n,r){function e(){this.constructor=n}for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t]);n.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)},Model;!function(n){var r=function(n){function r(){n.call(this),this._neighbors=[],this.OnNeedEstablishP2P="onNeedEstablishP2Pr",this.OnNeedCloseP2P="onNeedCloseP2Pr"}return __extends(r,n),r.prototype.addNeighbor=function(n){var r=_.find(this._neighbors,function(r){return r.peerID()===n.peerID()&&r.type()===n.type()});return r?void this.emit(this.OnNeedCloseP2P,n):(this._neighbors.push(n),void(n.connected||this.emit(this.OnNeedEstablishP2P,n)))},r.prototype.removeNeighbor=function(n){var r=this,e=_.remove(this._neighbors,function(r){return r.peerID()===n});_.each(e,function(n){n.connected&&r.emit(r.OnNeedCloseP2P,n)})},r.prototype.targetNeighbors=function(){var n=_.filter(this._neighbors,function(n){return!n.connected});return n},r}(EventEmitter2);n.TargetNeighbors=r}(Model||(Model={}));var __extends=this&&this.__extends||function(n,r){function e(){this.constructor=n}for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t]);n.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)},Model;!function(n){var r=function(r){function e(n,e,t){r.call(this),this._myPeerId=n,this._targetNeighbor=e,this._sourceUpdater=t,this._currentPeerID=""}return __extends(e,r),e.prototype.switchConnectTarget=function(){var r=this;this._sourceUpdater(function(e){if(e=_(e).filter(function(n){return n!==r._myPeerId}).sort().value(),!(e.length<=0||1===e.length&&e[0]===r._currentPeerID)){if(""===r._currentPeerID)r._currentPeerID=e[0];else{try{r._currentPeerID=r._getNext(e,r._currentPeerID)}catch(t){return}r._targetNeighbor.removeNeighbor(r._currentPeerID)}var i=n.NeighborFactory.createNeighbor(r._currentPeerID,n.NeighborTypeEnum.video),a=n.NeighborFactory.createNeighbor(r._currentPeerID,n.NeighborTypeEnum.data);r._targetNeighbor.addNeighbor(i),r._targetNeighbor.addNeighbor(a)}})},e.prototype._getNext=function(n,r){var e=_.findLastIndex(n,function(n){return n===r}),t=(e+1)%n.length,i=n[t];if(i!==this._myPeerId)return i;throw"error"},e}(EventEmitter2);n.TargetNeighborSwitcher=r}(Model||(Model={}));var Controller;!function(n){var r=function(){function n(n,r){var e=this;this._robotFlag=r;var t=new Model.CameraManager;r?t.createMultiTrackStream(function(r){window.localStream=r,e._initialize(n)}):t.getMinimulStream(function(r){window.localStream=r,e._initialize(n)})}return n.prototype._initialize=function(n){var r=this;callback=function(n){console.log("=========\n\n========hogehogehogheo"),console.log(n)};var e=new View.DisplayVideo,t=new Peer(n,{config:{iceServers:[{url:"stun:stun.skyway.io:3478"}]},host:"robo.paas.jp-e1.cloudn-service.com",port:443,secure:!0,key:"DEl4XWDPustUHICCl8cZ",debug:3}),i=new Model.TargetNeighbors,a=new Model.PeerJsManager(t,i);a.on(a.OnPeerOpendEvent,function(){var e=new Model.TargetNeighborSwitcher(n,i,function(n){t.listAllPeers(function(r){n(r)})}),a=new View.KeyboardListener;a.on(a.OnChangePeer,function(){console.log("switch"),e.switchConnectTarget()}),r._robotFlag||(console.log("switch"),e.switchConnectTarget())}),a.on(a.OnMediaLinkEstablished,e.setNeighbor)},n}();n.Controller=r}(Controller||(Controller={}));